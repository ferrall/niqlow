<?xml version="1.0" encoding="UTF-8"?>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<link rel="stylesheet" type="text/css" href="oxdoc.css">
<link rel="stylesheet" type="text/css" media="print" href="print.css">
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_CHTML"></script>
<title>niqlow.ox - niqlow solution software</title>
</head>
<body>
<div class="header">
[ <img class="icon" src="icons/project_s.png">&nbsp;<a href="default.html">Project home</a>
 | <img class="icon" src="icons/index_s.png">&nbsp;<a href="index.html">Index</a>
 | <img class="icon" src="icons/hierarchy_s.png">&nbsp;<a href="hierarchy.html">Class hierarchy</a> ]</div>
<h1><span class="icon"><img class="icon" src="icons/file.png">&nbsp;</span><span class="text">niqlow.ox</span></h1>

A package written in Ox for designing, solving and estimating empirical dynamic programming models.
<table class="doctable">
<P/>
<tr>
<tr><th colspan="3"  class="sep">Getting started &hellip; </th></tr>
<td><details class="over"><summary>Install &amp; Explore</summary><a target="_blank" href="About/Install.html">Installation instructions</a> to get <span class="n">niqlow</span> going on your system(s).<br/>
Browse and run <a  target="_blank" href="examples/default.html">test code, examples, and replications</a></details></td>
<td><details class="over"><summary>Tutorials</summary>
<a href="https://screencast-o-matic.com/u/hLxC/niqlow" target="_blank"><img src="icons/niqlow_video.png" style="float: left"/></a>
</details></td>
<td><details class="over"><summary>OODP</summary>Read the latest draft of the <a href="https://ferrall.github.io/OODP/">OODP academic paper</a> that provides a <span class="n">niqlow</span>-based definition of structural estimation and the existing literature.</details></td>
</tr>
<tr><th colspan="3"  class="sep"><span class="n">niqlow</span> has 3 components (separate but integrated) </th></tr>
<tr><th><h2><a href="DDP/default.html">DDP</a></h2></td>
<th><h2><a href="FiveO/default.html">FiveO</a></h2></th><th><h2><a href="CFMPI/default.html">CFMPI</a></h2></th></tr>
<tr><th>Derived Dynamic Programs</th><th>Object Oriented Objective<br>Optimization in Ox</th><th>CF's Ox Inteface to the MPI Library</th></tr>
<P/>
<tr ><th colspan="3" class="sep">Stages of using <span class="n">niqlow</span> &hellip;</th></tr>
<tr><th width="33%"><h2>DESIGN</h2></td><th  width="33%"><h2>SOLVE</h2></th><th  width="33%"><h2>ESTIMATE</h2></th></tr>
<P/>
<!--<tr><td colspan="3" >&nbsp;</td></tr>-->
<P/>
<tr><td><details class="over"><summary>Step 1. Design Your DP model</summary>
<UL>
<LI>Build the mode using  the <a href="DDP/default.html">DDP</a> section of <span class="n">niqlow</span>.</LI>
<LI>See a simple search model built using 7 executable statements in <a href="DDP/GetStarted.html">Get Started with DDP</a></LI>
<LI><b>Or</b> start from scratch with <a href="DDP/DDP.ox.html">static discrete choice</a> and learn how to work up to a DP model.</LI>
<LI><b>Or</b> follow replications of classic papers in  <a href="https://ferrall.github.io/OODP/">OODP</a> and start from the <a href="">replication code</a></LI>
</UL>
</td>
<P/>
<td><details class="over"><summary>Step 2. Solve the model</summary>
<ul>
<li>Use of the solution built in <a href="">Method</a>s to solve Bellman's equation for your model.</li>
<li>Create <a href="">Data</a> outcomes for the solution.</td>
</ul></details>
<td><details class="over"><summary>Step 3. Find parameter values</summary>
<UL><li>Use the integrated  <a href="FiveO/default.html">FiveO</a> tools to maximize an objective or solve a system of
equations that depends on the solved DP model.</li>
<li>See how to maximize a function in <a href="FiveO/GetStarted.html">Get Started with FiveO</a></li>
<li>Select among standard algorithms</li>
<LI>Use objectives that are integrated with DP models and external data or create your own.</li>
</UL></details>
</td></tr>
<P/>
<tr><td><details class="over"><summary>Required DP Components </summary>
    <UL>
    <li><a href="DDP/">Choose among <a href="">Bellman</a> classes to base your template for each point <span class="expressions">\(\theta\)</span> of the state space.</a></li>
     <li>Choose key/required features of <span class="expressions">\(\theta\)</span>:</li>
     <UL><li>Set the <a href="DDP/">Clock</a> (properties of <span class="expressions">\(t\)</span>)</li>
        <li>Add <a href="DDP/">Action Variables</a> to create your action vector <span class="expressions">\(\alpha\)</span>.</li>
        <li>Add <a href="DDP/">State Variables</a> to <span class="expressions">\(\theta\)</span>, from which the model's transition emerges</li>
        </UL>
     <li>Code <a href="">Utility()</a> </li>
     <li>Set the <a href="">Discount Factor</a></li>
     </UL></details><br/>
<details class="over"><summary>Further customizations</summary>
     <ul>
       <LI>Create multiple problems by adding <a href="DDP/">Group Variables</a></LI>
       <li>Make values of state variables <a href="">Terminal Values</a></li>
       <li>Restrict actions depending on <span class="expressions">\(\theta\)</span> by coding <a href="">FeasibleActions()</a> to define <span class="expressions">\(A(\theta)\)</span>.</li>
       <li>Restrict which states can be reached by coding <a href="">Reachable()</a></li>
     <LI>Let <span class="n">niqlow</span> handle the mapping between discrete <a href="">counter values</a> of
        variables and their <a href="">actual values</a> that enter your formulas</LI>
     <LI>Set the point in the solution algorithm when transitions must be recomputed depending on the reliance on parameters or group variables
        without computing the transitions unnecessarily.</LI>
     </ul></details><br/>
<details class="over"><summary>When ready create the spaces</summary>
<ul>
  <li>As your code executes the model is built until you <a href="">CreateSpaces</a></li>
  <li><span class="n">DDP</span> will built your state space <span class="expressions">\(\Theta\)</span>, the feasible action spaces <span class="expressions">\(A(\theta)\)</span> and the space of problems (group
    space <span class="expressions">\(\Gamma\)</span>).</li>
  <li>Storage is economized by limiting storage at each point <span class="expressions">\(\theta\)</span> and relying heavily on shared (<em>static</em>) variables</li>
  <li>Now your code can solve and use the model &hellip;</li>
</ul>
</details>
</td>
<td><details class="over"><summary>Choose &amp; apply a solution method.</summary>
    <UL>
    <LI>Solve for discrete choice probabilities (CCPs) under different assumptions or solve for reservation values of continuous
        random shocks.</LI>
    <li>Apply the solution to your model using its <a href="">Solve()</a> function.</li>
    <LI>Let the method handle storage and computation efficiently accounting for your clock and other details.</LI>
    <LI>Create more than one method "object" and compare their performance</LI>
    </UL></details><br/>
<details class="over"><summary>Create outcomes for the solved model</summary>
    <UL>
    <LI>Create a <a href="">Panel</a> of outcomes so you can <a href="">Simulate</a> outcomes from the model <em>or</em> read in external data to compute likelihood .</LI>
    <li>Create a <a href="">PanelPrediction</a> to <a href="">Predict</a> expected outcomes (averaged over all random elements) and read in
        external moments to compare them to.</li>
    <LI>Send a solution method to the data object: when any prediction or econometric calculation is needed the model will be resolved (a nested algorithm).</li>
    </UL>
    </details><br/>
<details class="over"><summary>Map model outcomes to data</summary>
    <UL>
    <LI>Map components (actions, state variables) to external data</LI>
     <LI>Treat unmapped components as missing.</LI>
    <li>Add auxiliary outcomes to the data to augment incomplete information.</li>
    <LI>Automatically integrate over "random effects" when computing econometrics objectives and the add values across
        fixed effects (observed groups)</LI>
    </UL></details>
</td>
<td>
<details class="over"><summary>Parameterize your DP model</summary>
    <UL>
    <LI>Make parameters of Utility and state transitions objects of a <a href="">Parameter</a> or <a href="">ParameterBlock</a>
        class.<li>
    <LI>Use built-in types of parameters to constrain them to open intervals in one or more related dimensions.</LI>
    <LI>Control which parameters are free to vary or should be held fixed by solution algorithms.</LI>
    </UL></details><br/>
<details class="over"><summary>Create a criterion (objective) </summary>
    <UL>
    <LI>Use an automatically generated econometric objective already available that depend on external data.</LI>
    <LI>Create a system of equations to find <a href="">Equilibrium</a> prices.</LI>
    <LI>Add DP parameters to the objective/system so they are associated with it.</LI>
    <LI>Use built-in features to handle <a href="">BHHH iteration</a> </LI>
    <LI>Choose among GMM weighting options</LI>
    </UL>
</details><br/>
<details class="over"><summary>Optimize your objective.</summary>
    <UL><li>Apply an <a href="">Algorithm(s)</a> using its <a href="">Iterate()</a> function.  </LI>
    <LI>Apply different methods, monitor and <a href="">checkpoint</a> progress</LI>
    <LI>Rest assured: the DP model is re-solved each time the criterion is re-evaluated because you sent the solution method to the data objects.</LI>
    <LI>Turn DP iteration on and off in order to carry out <a href="">Two-Stage Estimation.</a></LI>
    </UL></details><br/></td></td></tr>
<P/>
<tr><th colspan="3"  class="sep">When your model &hellip;</th></tr>
<P/>
<tr><td><details class="over"><summary>Becomes Big</summary>
<UL>
<LI>Use <a href="CFMPI">CFMPI</a> package to work in parallel on a Linux cluster</LI>
<LI>Let <span class="n">niqlow</span> handle parallel processing in optimization and model solving with no recoding</LI>
<LI>Or use high levels tools provided to create your own Client/Server and Peer-to-Peer tasks</LI>
<li>Or use the low-level interfaces with the MPI library to customize. </li>
</UL></details></th>
<P/>
<td><details  class="over"><summary>Is Estimated</summary>
<UL><LI>Use the estimated/equilibrium parameters to conduct policy experiments:</LI>
<LI>Change a parameter value at the top level of your code and be assured its propagates down to the DP solution and
    back up through predictions or simulated outcomes.</LI>
<LI>Create your own <em>derived</em> class to change the clock, expand the state space, allow more choice re-using the existing code and
changing only what is necessary</LI></UL></details></td>
<P/>
<td><details class="over"><summary>Is a Contribution</summary>
<UL>
<LI>Add new elements of your model to the <span class="n">niqlow</span> source code on your computer then request your  changes be implemented (pulled) into <span class="n">niqlow</span>.</LI>
<li>Create test or demonstration code for your new components or for core parts of <span class="n">niqlow</span>.</li>
<LI>Post your model code as a github repository to share it with others.</LI>
<LI>When your paper is published request your code be added to the <a href="Examples/replications">replications</a>.</LI>
</UL></details>
</td></tr>
<P/>
<tr ><th class="sep" colspan="3">The fine print &hellip;</th></tr>
<tr><th><h2 class="over"><a target="_blank" href="About/License.html">License</a></h2></th>
<th><h2 class="over"><a  target="_blank" href="About/Citation.html">Citation</a></h2></th>
<th><h2 class="over"><a  target="_blank" href="About/Acknowledgements.html">Acknowledgements</a></h2></th></tr>
<P/>
</table>
<!--0
<UL>
<LI>tools for designing and solving a dynamic programming problem</LI>
    <UL> Among the help documents listed there:
     <li></li>
     </UL>
<LI><a href="FiveO/default.html">FiveO</a>: tools for defining and maximizing an objective function or solving a non-linear system of equations</LI>
    <UL>
    <li>The famous Rosenbrock function is coded and maximized by the code <a href="../examples/FiveO/Rosenbrock.ox">examples/FiveO/Rosenbrock.ox</a> and explained </li>
    </UL>
<LI>If your ultimate goal is to <em>estimate parameters of a dynamic program</em> then your code will rely on both DDP and FiveO</LI>
    <UL>
    <li>You might read <a href="https://ferrall.github.io/OODP/">my academic paper</a> that discusses how to build a model from scratch and estimate it using <span class="n">niqlow</span>.</li>
    <LI>That paper discusses some of the replications that are available in the Examples folder.</li>
    </UL>
<LI><a href="CFMPI/default.html">CFMPI</a>: tools to run Ox code in parallel on a cluster using the <cite title="Message Passing Interface">MPI</cite> library</LI>
    <UL>
    <li><span class="n">niqlow</span> integrates MPI into estimation, so you can move your code seamlessly from a laptop to a supercomputer with no extra coding on your part.</li>
    <li> Or, use the more basic interface routines to write your own MPI-ready applications.</li>
    </UL>
</UL>-->

<div class="footer">
Generated by <a href="http://oxdoc.sourceforge.net">oxdoc 1.1</a> &copy Copyright 2005-2014 by Y. Zwols<br>
Math typesetting by <a href="http://www.mathjax.org/">Mathjax</a>
</div>
