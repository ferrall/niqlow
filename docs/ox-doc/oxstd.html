<!DOCTYPE html>
<!-- saved from url=(0026)http://www.doornik.com/ox/ -->
<html>
<head>
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" type="text/css" href="style/basic.css">
	<link rel="stylesheet" type="text/css" href="style/theme-green.css">
	<title>Ox function reference</title>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	<meta name="author" lang="en" content="Jurgen A Doornik">
	<meta name="copyright" content="&copy; Jurgen A Doornik">
	<base target="content-frame">
	<script src="style/loadincontent.js" type="text/javascript"></script>

<!-- Copyright Jurgen A. Doornik -->
<body>
<div class="page-frame">

<hr>
<h1>Ox Function Reference</h1>

<h2>Chapter contents:</h2>

<div>
<ul class="column-list">
<li class="newline"><b>A</b>
<li><a href="#acf">acf</a></li>
<li><a href="#acos">acos</a></li>
<li><a href="#aggregatec">aggregatec</a></li>
<li><a href="#aggregater">aggregater</a></li>
<li><a href="#any">any</a></li>

<li><a href="#arglist">arglist</a></li>
<li><a href="#asin">asin</a></li>
<li><a href="#atan">atan</a></li>
<li><a href="#atan2">atan2</a></li>

<li class="newline"><b>B</b>
<li><a href="#bessel">bessel</a></li>
<li><a href="#betafunc">betafunc</a></li>
<li><a href="#binand">binand</a></li>
<li><a href="#bincomp">bincomp</a></li>
<li><a href="#binomial">binomial</a></li>

<li><a href="#binor">binor</a></li>
<li><a href="#binpop">binpop</a></li>
<li><a href="#binvec">binvec</a></li>
<li><a href="#binxor">binxor</a></li>

<li class="newline"><b>C</b>
<li><a href="#cabs">cabs</a></li>
<li><a href="#cdiv">cdiv</a></li>
<li><a href="#ceil">ceil</a></li>
<li><a href="#cerf">cerf</a></li>
<li><a href="#cexp">cexp</a></li>

<li><a href="#chdir">chdir</a></li>
<li><a href="#choleski">choleski</a></li>
<li><a href="#classname">classname</a></li>
<li><a href="#clog">clog</a></li>
<li><a href="#clone">clone</a></li>

<li><a href="#cmul">cmul</a></li>
<li><a href="#columns">columns</a></li>
<li><a href="#constant">constant</a></li>
<li><a href="#correlation">correlation</a></li>
<li><a href="#cos">cos</a></li>

<li><a href="#cosh">cosh</a></li>
<li><a href="#countc">countc</a></li>
<li><a href="#countr">countr</a></li>
<li><a href="#csqrt">csqrt</a></li>
<li><a href="#cumprod">cumprod</a></li>

<li><a href="#cumsum">cumsum</a></li>
<li><a href="#cumulate">cumulate</a></li>

<li class="newline"><b>D</b>
<li><a href="#date">date</a></li>
<li><a href="#dawson">dawson</a></li>
<li><a href="#decldl">decldl</a></li>
<li><a href="#decldlband">decldlband</a></li>
<li><a href="#declu">declu</a></li>

<li><a href="#decqr">decqr</a></li>
<li><a href="#decqrmul">decqrmul</a></li>
<li><a href="#decqrupdate">decqrupdate</a></li>
<li><a href="#decsvd">decsvd</a></li>
<li><a href="#decschur">decschur</a></li>

<li><a href="#decschurgen">decschurgen</a></li>
<li><a href="#deletec">deletec</a></li>
<li><a href="#deleteifc">deleteifc</a></li>
<li><a href="#deleteifr">deleteifr</a></li>
<li><a href="#deleter">deleter</a></li>

<li><a href="#denschi">denschi</a></li>
<li><a href="#densf">densf</a></li>
<li><a href="#densn">densn</a></li>
<li><a href="#denst">denst</a></li>
<li><a href="#determinant">determinant</a></li>

<li><a href="#dfft">dfft</a></li>
<li><a href="#diag">diag</a></li>
<li><a href="#diagcat">diagcat</a></li>
<li><a href="#diagonal">diagonal</a></li>
<li><a href="#diagonalize">diagonalize</a></li>

<li><a href="#diff">diff</a></li>
<li><a href="#diff0">diff0</a></li>
<li><a href="#discretize">discretize</a></li>
<li><a href="#double">double</a></li>
<li><a href="#dropc">dropc</a></li>

<li><a href="#dropr">dropr</a></li>
<li><a href="#dawson">dawson</a></li>
<li><a href="#dayofcalendar">dayofcalendar</a></li>
<li><a href="#dayofeaster">dayofeaster</a></li>
<li><a href="#dayofmonth">dayofmonth</a></li>

<li><a href="#dayofweek">dayofweek</a></li>

<li class="newline"><b>E</b>
<li><a href="#eigen">eigen</a></li>
<li><a href="#eigensym">eigensym</a></li>
<li><a href="#eigensymgen">eigensymgen</a></li>
<li><a href="#eprint">eprint</a></li>
<li><a href="#erf">erf</a></li>

<li><a href="#exclusion">exclusion</a></li>
<li><a href="#exit">exit</a></li>
<li><a href="#exp">exp</a></li>
<li><a href="#expint">expint</a></li>

<li class="newline"><b>F</b>
<li><a href="#fabs">fabs</a></li>
<li><a href="#factorial">factorial</a></li>
<li><a href="#fclose">fclose</a></li>
<li><a href="#feof">feof</a></li>
<li><a href="#fflush">fflush</a></li>

<li><a href="#fft">fft</a></li>
<li><a href="#fft1d">fft1d</a></li>
<li><a href="#find">find</a></li>
<li><a href="#findsample">findsample</a></li>
<li><a href="#floor">floor</a></li>

<li><a href="#fmod">fmod</a></li>
<li><a href="#fopen">fopen</a></li>
<li><a href="#format">format</a></li>
<li><a href="#fprint">fprint</a></li>
<li><a href="#fprintln">fprintln</a></li>

<li><a href="#fread">fread</a></li>
<li><a href="#fscan">fscan</a></li>
<li><a href="#fseek">fseek</a></li>
<li><a href="#fsize">fsize</a></li>
<li><a href="#ftime">ftime</a></li>

<li><a href="#fuzziness">fuzziness</a></li>
<li><a href="#fremove">fremove</a></li>
<li><a href="#fwrite">fwrite</a></li>

<li class="newline"><b>G</b>
<li><a href="#gammafact">gammafact</a></li>
<li><a href="#gammafunc">gammafunc</a></li>
<li><a href="#getcwd">getcwd</a></li>
<li><a href="#getenv">getenv</a></li>
<li><a href="#getfiles">getfiles</a></li>

<li><a href="#getfolders">getfolders</a></li>

<li class="newline"><b>H</b>
<li><a href="#hyper_2F1">hyper_2F1</a></li>

<li class="newline"><b>I</b>
<li><a href="#idiv">idiv</a></li>
<li><a href="#imod">imod</a></li>
<li><a href="#insertc">insertc</a></li>
<li><a href="#insertr">insertr</a></li>
<li><a href="#int">int</a></li>

<li><a href="#intersection">intersection</a></li>
<li><a href="#invert">invert</a></li>
<li><a href="#inverteps">inverteps</a></li>
<li><a href="#invertgen">invertgen</a></li>
<li><a href="#invertsym">invertsym</a></li>

<li><a href="#isarray">isarray</a></li>
<li><a href="#isclass">isclass</a></li>
<li><a href="#isdotfeq">isdotfeq</a></li>
<li><a href="#isdotinf">isdotinf</a></li>
<li><a href="#isdotmissing">isdotmissing</a></li>

<li><a href="#isdotnan">isdotnan</a></li>
<li><a href="#isdouble">isdouble</a></li>
<li><a href="#iseq">iseq</a></li>
<li><a href="#isfeq">isfeq</a></li>
<li><a href="#isfile">isfile</a></li>

<li><a href="#isfunction">isfunction</a></li>
<li><a href="#isint">isint</a></li>
<li><a href="#ismatrix">ismatrix</a></li>
<li><a href="#ismember">ismember</a></li>
<li><a href="#ismissing">ismissing</a></li>

<li><a href="#isnan">isnan</a></li>
<li><a href="#isstring">isstring</a></li>

<li class="newline"><b>L</b>
<li><a href="#lag">lag</a></li>
<li><a href="#lag0">lag0</a></li>
<li><a href="#limits">limits</a></li>
<li><a href="#loadmat">loadmat</a></li>
<li><a href="#loadsheet">loadsheet</a></li>

<li><a href="#log">log</a></li>
<li><a href="#log10">log10</a></li>
<li><a href="#logdet">logdet</a></li>
<li><a href="#loggamma">loggamma</a></li>
<li><a href="#lower">lower</a></li>

<li class="newline"><b>M</b>
<li><a href="#matrix">matrix</a></li>
<li><a href="#max">max</a></li>
<li><a href="#maxc">maxc</a></li>
<li><a href="#maxr">maxc</a></li>
<li><a href="#maxcindex">maxcindex</a></li>

<li><a href="#meanc">meanc</a></li>
<li><a href="#meanr">meanr</a></li>
<li><a href="#min">min</a></li>
<li><a href="#minc">minc</a></li>
<li><a href="#mincindex">mincindex</a></li>

<li><a href="#minr">minc</a></li>
<li><a href="#moments">moments</a></li>

<li class="newline"><b>N</b>
<li><a href="#nans">nans</a></li>
<li><a href="#norm">norm</a></li>
<li><a href="#nullspace">nullspace</a></li>

<li class="newline"><b>O</b>
<li><a href="#ols2c">ols2c</a></li>
<li><a href="#ols2r">ols2r</a></li>
<li><a href="#olsc">olsc</a></li>
<li><a href="#olsr">olsr</a></li>
<li><a href="#ones">ones</a></li>

<li><a href="#outer">outer</a></li>
<li><a href="#oxfilename">oxfilename</a></li>
<li><a href="#oxprintlevel">oxprintlevel</a></li>
<li><a href="#oxrunerror">oxrunerror</a></li>
<li><a href="#oxversion">oxversion</a></li>

<li><a href="#oxwarning">oxwarning</a></li>

<li class="newline"><b>P</b>
<li><a href="#periodogram">periodogram</a></li>
<li><a href="#polydiv">polydiv</a></li>
<li><a href="#polyeval">polyeval</a></li>
<li><a href="#polygamma">polygamma</a></li>
<li><a href="#polymake">polymake</a></li>

<li><a href="#polymul">polymul</a></li>
<li><a href="#polyroots">polyroots</a></li>
<li><a href="#pow">pow</a></li>
<li><a href="#print">print</a></li>
<li><a href="#println">println</a></li>

<li><a href="#probchi">probchi</a></li>
<li><a href="#probf">probf</a></li>
<li><a href="#probn">probn</a></li>
<li><a href="#probt">probt</a></li>
<li><a href="#prodc">prodc</a></li>

<li><a href="#prodr">prodr</a></li>

<li class="newline"><b>Q</b>
<li><a href="#quanchi">quanchi</a></li>
<li><a href="#quanf">quanf</a></li>
<li><a href="#quann">quann</a></li>
<li><a href="#quant">quant</a></li>
<li><a href="#quantilec">quantilec</a></li>

<li><a href="#quantiler">quantiler</a></li>

<li class="newline"><b>R</b>
<li><a href="#range">range</a></li>
<li><a href="#rank">rank</a></li>
<li><a href="#ranloopseed">ranloopseed</a></li>
<li><a href="#rann">rann</a></li>
<li><a href="#ranseed">ranseed</a></li>

<li><a href="#ranu">ranu</a></li>
<li><a href="#reflect">reflect</a></li>
<li><a href="#replace">replace</a></li>
<li><a href="#reshape">reshape</a></li>
<li><a href="#reversec">reversec</a></li>

<li><a href="#reverser">reverser</a></li>
<li><a href="#round">round</a></li>
<li><a href="#rows">rows</a></li>

<li class="newline"><b>S</b>
<li><a href="#savemat">savemat</a></li>
<li><a href="#scan">scan</a></li>
<li><a href="#selectc">selectc</a></li>
<li><a href="#selectifc">selectifc</a></li>
<li><a href="#selectifr">selectifr</a></li>

<li><a href="#selectr">selectr</a></li>
<li><a href="#selectrc">selectrc</a></li>
<li><a href="#setbounds">setbounds</a></li>
<li><a href="#seliiagonal">seliiagonal</a></li>
<li><a href="#setlower">setlower</a></li>

<li><a href="#setupper">setupper</a></li>
<li><a href="#shape">shape</a></li>
<li><a href="#sin">sin</a></li>
<li><a href="#sinh">sinh</a></li>
<li><a href="#sizec">sizec</a></li>

<li><a href="#sizeof">sizeof</a></li>
<li><a href="#sizer">sizer</a></li>
<li><a href="#sizerc">sizerc</a></li>
<li><a href="#solveldl">solveldl</a></li>
<li><a href="#solveldlband">solveldlband</a></li>

<li><a href="#solvelu">solvelu</a></li>
<li><a href="#solvetoeplitz">solvetoeplitz</a></li>
<li><a href="#sortbyc">sortbyc</a></li>
<li><a href="#sortbyr">sortbyr</a></li>
<li><a href="#sortc">sortc</a></li>

<li><a href="#sortcindex">sortcindex</a></li>
<li><a href="#sortr">sortr</a></li>
<li><a href="#spline">spline</a></li>
<li><a href="#sprint">sprint</a></li>
<li><a href="#sprintbuffer">sprintbuffer</a></li>

<li><a href="#sqr">sqr</a></li>
<li><a href="#sqrt">sqrt</a></li>
<li><a href="#sscan">sscan</a></li>
<li><a href="#standardize">standardize</a></li>
<li><a href="#strfind">strfind</a></li>

<li><a href="#strfindr">strfindr</a></li>
<li><a href="#strifind">strifind</a></li>
<li><a href="#strifindr">strifindr</a></li>
<li><a href="#string">string</a></li>
<li><a href="#strlwr">strlwr</a></li>

<li><a href="#strtrim">strtrim</a></li>
<li><a href="#strupr">strupr</a></li>
<li><a href="#submat">submat</a></li>
<li><a href="#sumc">sumc</a></li>
<li><a href="#sumr">sumr</a></li>

<li><a href="#sumsqrc">sumsqrc</a></li>
<li><a href="#sumsqrr">sumsqrr</a></li>
<li><a href="#systemcall">systemcall</a></li>

<li class="newline"><b>T</b>
<li><a href="#tailchi">tailchi</a></li>
<li><a href="#tailf">tailf</a></li>
<li><a href="#tailn">tailn</a></li>
<li><a href="#tailt">tailt</a></li>
<li><a href="#tan">tan</a></li>

<li><a href="#tanh">tanh</a></li>
<li><a href="#thinc">thinc</a></li>
<li><a href="#thinr">thinr</a></li>
<li><a href="#time">time</a></li>
<li><a href="#timer">timer</a></li>

<li><a href="#timeofday">timeofday</a></li>
<li><a href="#timespan">timespan</a></li>
<li><a href="#timestr">timestr</a></li>
<li><a href="#timing">timing</a></li>
<li><a href="#today">today</a></li>

<li><a href="#toeplitz">toeplitz</a></li>
<li><a href="#trace">trace</a></li>
<li><a href="#trunc">trunc</a></li>
<li><a href="#truncf">truncf</a></li>

<li class="newline"><b>U</b>
<li><a href="#union">union</a></li>
<li><a href="#unique">unique</a></li>
<li><a href="#unit">unit</a></li>
<li><a href="#unvech">unvech</a></li>
<li><a href="#upper">upper</a></li>

<li class="newline"><b>V</b>
<li><a href="#va_arglist">va_arglist</a></li>
<li><a href="#varc">varc</a></li>
<li><a href="#variance">variance</a></li>
<li><a href="#varr">varr</a></li>
<li><a href="#vec">vec</a></li>

<li><a href="#vech">vech</a></li>
<li><a href="#vecindex">vecindex</a></li>
<li><a href="#vecr">vecr</a></li>
<li><a href="#vecrindex">vecrindex</a></li>

<li class="newline"><b>Z</b>
<li><a href="#zeros">zeros</a></li>
</ul>
</div>
<div class="clear"></div>


<h2>Tables:</h2>

<dl>
<dt><a href="#TabStd1">Formatting types for scanning</a>
<dt><a href="#TabStd2">Formatting flags for doubles and integers</a>
<dt><a href="#TabStd3">Formatting types for printing</a>
</dl>


<a name="acf"></a><h2>acf</h2>

<pre>acf(const ma, const ilag);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>

<dd>in: arithmetic type, <i>T</i> <tt>x</tt> <i>n</i> matrix

<dt><tt>ilag</tt>

<dd>in: int, the highest lag

</dl>

<dt><i>Return value</i>

<dd>Returns a (<tt>ilag</tt>+1) by <i>n</i> matrix with the autocorrelation
function of the columns of <tt>ma</tt> up to lag <tt>ilag</tt>. Returns
0 if <tt>ilag</tt> &lt;= 0. If any variance is &lt;= 1e-20, then the corresponding
autocorrelations are set to 0.

<dt><i>See also</i>

<dd><tt><a href="oxdraw.html#DrawCorrelogram">DrawCorrelogram</a></tt>, <tt><a href="#pacf">pacf</a></tt>

<dt><a href="oxstdexamples.html#acf"><i>Example</i></a>
</dl>


<a name="acos"></a><h2>acos</h2>

<pre>acos(const ma);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>

<dd>in: arithmetic type
</dl>

<dt><i>Return value</i>

<dd>Returns the arccosine of <tt>ma</tt>, of double or matrix type.

<dt><i>See also</i>

<dd><tt><a href="#asin">asin</a></tt>, <tt><a href="#atan">atan</a></tt>, <tt><a href="#cos">cos</a></tt>, <tt><a href="#cosh">cosh</a></tt>, <tt><a href="#sin">sin</a></tt>,
<tt><a href="#sinh">sinh</a></tt>, <tt><a href="#tan">tan</a></tt>, <tt><a href="#tanh">tanh</a></tt>

<dt><a href="oxstdexamples.html#acos"><i>Example</i></a>
</dl>



<a name="aggregatec"></a><a name="aggregater"></a>
<h2>aggregatec,aggregater 
</h2>

<pre>aggregatec(const ma, const istep);
aggregater(const ma, const istep);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>

<dd>in: <i>m</i> <tt>x</tt> <i>n</i> matrix <i>A</i>

<dt><tt>istep</tt>

<dd>in: int, size of groups, <i>s</i>

</dl>

<dt><i>Return value</i>

<dd>The <tt>aggregatec</tt> function returns a ceil(<i>m</i>/<i>s</i>) by <tt>n</tt>
where each group of <i>s</i> observations in every column is replaced by the
sum.

The <tt>aggregater</tt>	function returns a <tt>m</tt> by ceil(<i>n</i>/<i>s</i>)
where each group of <i>s</i> observations in every row is replaced by the
sum.

<dt><i>See also</i>

<dd><tt><a href="#thinc">thinc</a></tt>, <tt><a href="#thinr">thinr</a></tt>


<dt><a href="oxstdexamples.html#aggregatec"><i>Example</i></a>
</dl>




<a name="any"></a><h2>any</h2>

<pre>any(const ma);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>

<dd>in: arithmetic type
</dl>

<dt><i>Return value</i>

<dd>Returns TRUE if any element of <tt>ma</tt> is TRUE, of integer type.


<dt><i>See also</i>

<dd><a href="oxsyntax.html#ox_syntax_RefEqExpr">equality expressions</a>

<dt><a href="oxstdexamples.html#any"><i>Example</i></a>
</dl>


<a name="arglist"></a><h2>arglist</h2>

<pre>arglist();
</pre>

<dl><dd>
<dt><i>Return value</i>

<dd>
Returns an array of strings holding the command line arguments
passed to the Ox program. The first entry is the name of the program
that was specified on the command line.

<dt><a href="oxstdexamples.html#arglist"><i>Example</i></a>

<dt><i>See also</i>

<dd><a href="#va_arglist"><tt>va_arglist</tt></a>
 (for variable number of function arguments)
</dl>



<a name="array"></a><h2>array</h2>

<pre>array(const ma);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>

<dd>in: any type
</dl>

<dt><i>Return value</i>

<dd>Casts the argument to an array, unless it already is an array.

<dt><a href="oxstdexamples.html#array"><i>Example</i></a>
</dl>



<a name="asin"></a><h2>asin</h2>

<pre>asin(const ma);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>

<dd>in: arithmetic type
</dl>

<dt><i>Return value</i>

<dd>Returns the arcsine of <tt>ma</tt>, of double or matrix type.

<dt><i>See also</i>

<dd><tt><a href="#acos">acos</a></tt>, <tt><a href="#atan">atan</a></tt>, <tt><a href="#cos">cos</a></tt>, <tt><a href="#cosh">cosh</a></tt>, <tt><a href="#sin">sin</a></tt>,
<tt><a href="#sinh">sinh</a></tt>, <tt><a href="#tan">tan</a></tt>, <tt><a href="#tanh">tanh</a></tt>
</dl>


<a name="atan"></a><a name="atan2"></a>
<h2>atan,atan2</h2>

<pre>atan(const ma);
atan2(const my, const mx);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>

<dd>in: arithmetic type
</dl>

<dt><i>Return value</i>

<dd><tt>atan</tt> returns the arctangent of <tt>ma</tt>, of double or matrix type,
between -pi/2 and pi/2.

<p>
<tt>atan2</tt> returns the arctangent of <tt>my ./ mx</tt>,
between -pi and pi.


<dt><i>See also</i>

<dd><tt><a href="#acos">acos</a></tt>, <tt><a href="#asin">asin</a></tt>, <tt><a href="#cos">cos</a></tt>, <tt><a href="#cosh">cosh</a></tt>, <tt><a href="#sin">sin</a></tt>,
<tt><a href="#sinh">sinh</a></tt>, <tt><a href="#tan">tan</a></tt>, <tt><a href="#tanh">tanh</a></tt>
</dl>


<a name="bessel"></a><h2>bessel</h2>

<pre>bessel(const mx, const type, const n01);
bessel(const mx, const type, const nu);
</pre>

<dl><dd>
<dl>
<dt><tt>mx</tt>
<dd>in: <i>x</i>, arithmetic type

<dt><tt>type</tt>
<dd>in: character, type of Bessel function: <tt>'J'</tt>,
<tt>'Y'</tt>, <tt>'I'</tt>, <tt>'K'</tt>, or
string: <tt>"IE"</tt>, <tt>"KE"</tt>, for scaled Bessel functions

<dt><tt>n01</tt>
<dd>in: 0 or 1: order of Bessel function

<dt><tt>nu</tt>
<dd>in: double, fractional order of Bessel function
</dl>

<dt><i>Return value</i>

<dd>
Returns an <i>m</i> <tt>x</tt> <i>n</i> matrix, when <tt>mx</tt> is an <i>m</i>
<tt>x</tt> <i>n</i> matrix, or a double when <tt>x</tt> is scalar.
The following are available: <i>J</i><sub>0</sub>(<i>x</i>),
<i>Y</i><sub>0</sub>(<i>x</i>), <i>J</i><sub>1</sub>(<i>x</i>), <i>Y</i><sub>1</sub>(<i>x</i>),
and the modified Bessel functions <i>I</i><sub>0</sub>(<i>x</i>),
<i>K</i><sub>0</sub>(<i>x</i>), <i>I</i><sub>1</sub>(<i>x</i>), <i>K</i><sub>1</sub>(<i>x</i>).
If the specified order is not 0 or 1, the fractional Bessel functions
are computed.
The modified Bessel functions are also available in scaled
form: <i>e</i><sup>-<i>x</i></sup><i>I</i><sub><i>n</i></sub>(<i>x</i>)
and <i>e</i><sup><i>x</i></sup><i>K</i><sub><i>n</i></sub>(<i>x</i>).

The accuracy is to about 15 digits.

</dl>



<a name="betafunc"></a><h2>betafunc</h2>

<pre>betafunc(const mx, const ma, const mb);
</pre>

<dl><dd>
<dl>
<dt><tt>mx</tt>

<dd>in: <i>x</i>, arithmetic type

<dt><tt>ma</tt>

<dd>in: <i>a</i>, arithmetic type

<dt><tt>mb</tt>

<dd>in: <i>b</i>, arithmetic type
</dl>

<dt><i>Return value</i>

<dd>Returns the incomplete beta integral <i>B<sub>x</sub></i>(<i>a</i>,<i>b</i>).
Returns 0 if <i>a</i> &lt;= 0, <i>b</i> &lt;= 0 or <i>x</i> &lt;= 0. The
accuracy is to about 10 digits. The return type is derived as follows:


<ul>
<li><i>m</i> <tt>x</tt> <i>n</i> matrix, when <tt>mx</tt> is an <i>m</i>
<tt>x</tt> <i>n</i> matrix, and <tt>ma</tt>,<tt>mb</tt> are scalar;

<li><i>m</i> <tt>x</tt> <i>n</i> matrix, when <tt>mx</tt> is a scalar,
and <tt>ma</tt>,<tt>mb</tt> are <i>m</i> <tt>x</tt> <i>n</i> matrices;


<li><i>m</i> <tt>x</tt> <i>n</i> matrix, when <tt>mx</tt> is an <i>m</i>
<tt>x</tt> <i>n</i> matrix, and <tt>ma</tt>,<tt>mb</tt> are <i>m</i> <tt>x</tt>
<i>n</i> matrices;

<li>double, when <tt>mx</tt> and <tt>ma</tt>,<tt>mb</tt> are scalar.
</ul>

<dt><i>See also</i>

<dd><tt><a href="#gammafunc">gammafunc</a></tt>, <tt><a href="#probf">probf</a></tt>, <tt><a href="#probf">probf</a></tt>, <tt><a href="#tailf">tailf</a></tt>

</dl>



<a name="binand"></a> 
<a name="bincomp"></a>
<a name="binor"></a>  
<a name="binpop"></a> 
<a name="binvec"></a> 
<a name="binxor"></a> 
<h2>
binand,
bincomp,
binor,
binpop,
binvec,
binxor
</h2>

<pre>binand(const ia, const ib, ...);
bincomp(const ia);
binor(const ia, const ib, ...);
binpop(const ia, ...);
binvec(const ia);
binxor(const ia, const ib, ...);
</pre>

<dl><dd>
<dl>
<dt><tt>ia</tt>

<dd>in: int or matrix of integers

<dt><tt>ib</tt>

<dd>in: int or matrix of integers

<dt><tt>...</tt>

<dd>in: optional additional arguments, if present, all arguments must be integers
</dl>

<dt><i>Return value</i>

<dd><tt>binand</tt> returns the result from <i>and</i>-ing all arguments
(the <tt>&amp;</tt> operator in C,C++ ).
<p><tt>bincomp</tt> returns the binary (bit-wise) complement of the argument
(the <tt>~</tt> operator in C/C++).
<p><tt>binor</tt> returns the result
from <i>or</i>-ing all arguments (the <tt>|</tt> operator in C,C++ ).
<p><tt>binpop</tt> returns the number of non-zero bits (popcount, Hamming weight)
in the argument. If there is more than one argument, these are <i>xor</i>ed
together first (the Hamming distance).
<p><tt>binvec</tt> returns the <i>n</i><tt>x</tt>32 vector of zeros and ones,
with each row the bitwise representation of the integer(s) in the argument.
The least significant bit comes first, so 6 is returned as 0,1,1 followed by 29 zeros.
<p><tt>binxor</tt> returns the result
from <i>xor</i>-ing all arguments (the <tt>^</tt> operator in C,C++ ).

<dt><a href="oxstdexamples.html#binand"><i>Example</i></a>
</dl>


<a name="binomial"></a><h2>binomial</h2>

<pre>binomial(const n, const k);
</pre>

<dl><dd>
<dl>
<dt><tt>n, k</tt>

<dd>in: arithmetic type
</dl>

<dt><i>Return value</i>

<dd>Returns the binomial function at the rounded value of each
element, of double or matrix type.
For negative integers, the function returns .NaN.
<p>
The binomial coefficient is: <i>n</i>!/((<i>n</i>-<i>k</i>)!<i>k</i>!).
When max(<i>n</i>-<i>k</i>,<i>k</i>) &gt;= 50 the computation uses the loggamma function:
<tt>binomial</tt>(n,k)=exp(<tt>loggamma</tt>(n+1)-<tt>loggamma</tt>(n-k+1)-<tt>loggamma</tt>(k+1)).

<dt><i>See also</i>

<dd><tt><a href="#factorial">factorial</a></tt>,
<tt><a href="#gammafact">gammafact</a></tt>,
<tt><a href="#loggamma">loggamma</a></tt>
</dl>


<a name="cabs"></a>
<a name="cdiv"></a>
<a name="cerf"></a>
<a name="cexp"></a>
<a name="clog"></a>
<a name="cmul"></a>
<a name="csqrt"></a>
<h2>
cabs,
cdiv,
cerf,
cexp,
clog,
cmul,
csqrt
</h2>

<pre>cabs(const ma);
cdiv(const ma, const mb);
cerf(const ma);
cexp(const ma);
clog(const ma);
cmul(const ma, const mb);
csqrt(const ma);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>, <tt>mb</tt>

<dd>in: 2 <tt>x</tt> <i>n</i> matrix (first row is real part, second row
imaginary part), or 1 <tt>x</tt> <i>n</i> matrix (real part only)
</dl>

<dt><i>Return value</i>

<dd><tt>cabs</tt> returns a 1 <tt>x</tt> <i>n</i> matrix with the absolute
value of the vector of complex numbers.

<p><tt>cdiv</tt> returns a 2 <tt>x</tt> <i>n</i> matrix with the result
of the division of the two vectors of complex numbers. If both <tt>ma</tt>
and <tt>mb</tt> have no imaginary part, the return value will be 1 <tt>x</tt>
<i>n</i>.

<p><tt>cmul</tt> returns a 2 <tt>x</tt> <i>n</i> matrix with the result
of the multiplication of the two vectors of complex numbers. If both <tt>ma</tt>
and <tt>mb</tt> have no imaginary part, the return value will be 1 <tt>x</tt>
<i>n</i>.

<p><tt>csqrt</tt> returns a 2 <tt>x</tt> <i>n</i> matrix with the square
root of the vector of complex numbers.

<p><tt>cerf</tt> returns a 2 <tt>x</tt> <i>n</i> matrix with the complex
error function of the vector of complex numbers.

<p><tt>cexp</tt> returns a 2 <tt>x</tt> <i>n</i> matrix with the exponential
of the vector of complex numbers.

<p><tt>clog</tt> returns a 2 <tt>x</tt> <i>n</i> matrix with the logarithm
of the vector of complex numbers. This is the principal branch, i.e. the imaginary
part is between -pi and pi.

<dt><a href="oxstdexamples.html#cabs"><i>Example</i></a>
</dl>


<a name="ceil"></a><h2>ceil</h2>

<pre>ceil(const ma);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>

<dd>in: arithmetic type
</dl>

<dt><i>Return value</i>

<dd>Returns the ceiling of each element of <tt>ma</tt>, of double or matrix
type. The ceiling is the smallest integer larger than or equal to the argument


<dt><i>See also</i>

<dd><tt><a href="#floor">floor</a></tt>, <tt><a href="#round">round</a></tt>, <tt><a href="#trunc">trunc</a></tt>

<dt><a href="oxstdexamples.html#ceil"><i>Example</i></a>
</dl>


<a name="chdir"></a><h2>chdir</h2>

<pre>chdir(const s);
</pre>

<dl><dd>
<dl>
<dt><tt>s</tt>

<dd>in: new directory
</dl>

<dt><i>Return value</i>

<dd>Returns 1 if the directory was changed successfully, 1 otherwise.
<p>
<i>Windows specific</i>: if the
string starts with a drive letter followed by a semicolon,
the current drive is also changed. For example,
use <tt>chdir("c:")</tt> to change to the C drive.

<dt><i>See also</i>

<dd><tt><a href="#getcwd">getcwd</a></tt>, <tt><a href="#getfiles">getfiles</a></tt>,
<tt><a href="#systemcall">systemcall</a></tt>

<dt><a href="oxstdexamples.html#getfiles"><i>Example</i></a>
</dl>


<a name="choleski"></a><h2>choleski</h2>

<pre>choleski(const ma);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>

<dd>in: symmetric, positive definite <i>m</i> <tt>x</tt> <i>m</i> matrix
<i>A</i>
</dl>

<dt><i>Return value</i>

<dd>Returns the Choleski decomposition <i>P</i> of a symmetric positive definite
matrix <i>A</i>: <i>A</i>=<i>PP</i>'; <i>P</i> is lower triangular (has
zero's above the diagonal). Returns 0 if the decomposition failed.

<dt><i>See also</i>

<dd><tt><a href="#decldl">decldl</a></tt>, <tt><a href="#invertsym">invertsym</a></tt>,
<tt><a href="#solvelu">solvelu</a></tt>

<dt><a href="oxstdexamples.html#choleski"><i>Example</i></a>
</dl>

<a name="classname"></a><h2>classname</h2>

<pre>classname(const obj);
</pre>

<dl><dd>
<dl>
<dt><tt>obj</tt>

<dd>in: object of a class
</dl>

<dt><i>Return value</i>

<dd>Returns a string with the class name of the object (or 0 if the argument
is not an object).

<dt><i>See also</i>

<dd><tt><a href="#isclass">isclass</a></tt>
</dl>


<a name="clone"></a><h2>clone</h2>

<pre>clone(const obj);
clone(const obj, const iDeep=1);
</pre>

<dl><dd>
<dl>
<dt><tt>obj</tt>

<dd>in: object of a class
<dt><tt>iDeep</tt>

<dd>in: int, 1 (deep copy, the default), 0: shallow copy
</dl>

<dt><i>Return value</i>

<dd>Returns a clone of the object.

<p>
The clone is an exact copy that must be removed with a call to <tt>delete</tt>.

When writing <tt>a = new Database(); b = a;</tt> both a and b refer to the same
object, and only one can be deleted.

Writing <tt>a = new Database(); b = clone(a);</tt> both a and b refer
different objects, which happen to hold the same values.
Both a and b should be deleted when done.

The default is to make a deep copy: all members that are objects are
also cloned (and members of members, etc.). A shallow copy only
clones the members that are objects, but not members of members.

</dl>


<a name="columns"></a><h2>columns</h2>

<pre>columns(const ma);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>

<dd>in: any type
</dl>

<dt><i>Return value</i>

<dd>Returns an integer value with the number of columns in the argument
<tt>ma</tt>:

<ul>
<li><i>m</i> <tt>x</tt> <i>n</i> matrix: <i>n</i>;

<li>string: number of characters in the string;

<li>array: number of elements in the array;

<li>file: number of columns in the file; (only if opened with <tt>f</tt> format,
see <tt><a href="#fopen">fopen</a></tt>);

<li>other: 0.
</ul>

<dt><i>See also</i>

<dd><tt><a href="#rows">rows</a></tt>, <tt><a href="#sizeof">sizeof</a></tt>

<dt><a href="oxstdexamples.html#columns"><i>Example</i></a>
</dl>


<a name="constant"></a><h2>constant</h2>

<pre>constant(const dval, const r, const c);
constant(const dval, const ma);
</pre>

<dl><dd>
<dl>
<dt><tt>dval</tt>

<dd>in: double

<dt><tt>r</tt>

<dd>in: int

<dt><tt>c</tt>

<dd>in: int
<dt><tt>ma</tt>

<dd>in: matrix
</dl>

<dt><i>Return value</i>

<dd><tt>constant(dval,r,c)</tt> returns an <tt>r</tt> by <tt>c</tt> matrix filled with <tt>dval</tt>.

<dd><tt>constant(dval,ma)</tt> returns a matrix of the same dimension as <tt>ma</tt>, filled with <tt>dval</tt>.


<dt><i>See also</i>

<dd><tt><a href="#ones">ones</a></tt>, <tt><a href="#unit">unit</a></tt>, <tt><a href="#zeros">zeros</a></tt>

<dt><a href="oxstdexamples.html#constant"><i>Example</i></a>
</dl>


<a name="correlation"></a><h2>correlation</h2>

<pre>correlation(const ma);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>

<dd>in: <i>T</i> <tt>x</tt> <i>n</i> matrix <i>A</i>
</dl>

<dt><i>Return value</i>

<dd>Returns a <i>n</i> <tt>x</tt> <i>n</i> matrix holding the correlation
matrix of <tt>ma</tt>. If any variance is &lt;= 1e-20, then the corresponding
row and column of the correlation matrix are set to 0.

<dt><i>See also</i>

<dd><tt><a href="#acf">acf</a></tt>, <tt><a href="#meanc">meanc</a></tt>, <tt><a href="#meanr">meanr</a></tt>, <tt><a href="#standardize">standardize</a></tt>,
<tt><a href="#varc">varc</a></tt>, <tt><a href="#varr">varr</a></tt>, <tt><a href="#variance">variance</a></tt>

<dt><a href="oxstdexamples.html#correlation"><i>Example</i></a>
</dl>



<a name="cos"></a>
<a name="cosh"></a>
<h2>cos,cosh</h2>

<pre>cos(const ma);
cosh(const ma);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>

<dd>in: arithmetic type
</dl>

<dt><i>Return value</i>

<dd><tt>cos</tt> returns the cosine of <tt>ma</tt>, of double or matrix
type. <tt>cosh</tt> returns the cosine hyperbolicus of <tt>ma</tt>, of
double or matrix type.

<dt><i>See also</i>

<dd><tt><a href="#acos">acos</a></tt>, <tt><a href="#asin">asin</a></tt>, <tt><a href="#atan">atan</a></tt>, <tt><a href="#cosh">cosh</a></tt>, <tt><a href="#sin">sin</a></tt>,
<tt><a href="#sinh">sinh</a></tt>, <tt><a href="#tan">tan</a></tt>, <tt><a href="#tanh">tanh</a></tt>
</dl>


<a name="countc"></a><h2>countc</h2>

<pre>countc(const ma, const va);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>

<dd>in: <i>m</i> <tt>x</tt> <i>n</i> matrix

<dt><tt>va</tt>

<dd>in: 1 <tt>x</tt> <i>q</i> or <i>q</i> <tt>x</tt> 1 matrix
</dl>

<dt><i>Return value</i>

<dd>Returns a matrix <tt>r</tt> which counts of the number of elements
in each column of <tt>ma</tt> which is between the corresponding values
in <tt>va</tt>:

<dl>
<dt><tt>r[0][0]</tt> = # elements in column 0 of <tt>ma</tt> &lt;= <tt>va[0]</tt>


<dt><tt>r[1][0]</tt> = # elements in column 0 of <tt>ma</tt> &gt; <tt>va[0]</tt>
and &lt;= <tt>va[1]</tt>

<dt><tt>r[2][0]</tt> = # elements in column 0 of <tt>ma</tt> &gt; <tt>va[1]</tt>
and &lt;= <tt>va[2]</tt>

<dt><tt>r[q][0]</tt> = # elements in column 0 of <tt>ma</tt> &gt; <tt>va[q-1]</tt>


<dt><tt>...</tt>

<dt><tt>r[0][1]</tt> = # elements in column 1 of <tt>ma</tt> &lt;= <tt>va[0]</tt>


<dt><tt>r[1][1]</tt> = # elements in column 1 of <tt>ma</tt> &gt; <tt>va[0]</tt>
and &lt;= <tt>va[1]</tt>

<dt><tt>r[2][1]</tt> = # elements in column 1 of <tt>ma</tt> &gt; <tt>va[1]</tt>
and &lt;= <tt>va[2]</tt>

<dt><tt>r[q][1]</tt> = # elements in column 1 of <tt>ma</tt> &gt; <tt>va[q-1]</tt>


<dt><tt>...</tt>
</dl>

<p>If <tt>ma</tt> is <i>m</i> <tt>x</tt> <i>n</i>, and <tt>va</tt> is 1
<tt>x</tt> <i>q</i> (or <i>q</i> <tt>x</tt> 1) the returned matrix is (<i>q</i>+1) <tt>x</tt> <i>n</i>
(any remaining columns of <tt>va</tt> are ignored).
If the values in <tt>va</tt> are not ordered, the return value
is filled with missing values.

<dt><i>See also</i>

<dd><tt><a href="#countr">countr</a></tt>

<dt><a href="oxstdexamples.html#countc"><i>Example</i></a>
</dl>


<a name="countr"></a><h2>countr</h2>

<pre>countr(const ma, const va);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>

<dd>in: <i>m</i> <tt>x</tt> <i>n</i> matrix

<dt><tt>va</tt>

<dd>in: 1 <tt>x</tt> <i>q</i> or <i>q</i> <tt>x</tt> 1 matrix
</dl>

<dt><i>Return value</i>

<dd>Returns a matrix <tt>r</tt> which counts of the number of elements
in each row of <tt>ma</tt> which is between the corresponding values in
<tt>va</tt>:

<dl>
<dt><tt>r[0][0]</tt> = # elements in row 0 of <tt>ma</tt> &lt;= <tt>va[0]</tt>


<dt><tt>r[0][1]</tt> = # elements in row 0 of <tt>ma</tt> &gt; <tt>va[0]</tt>
and &lt;= <tt>va[1]</tt>

<dt><tt>r[0][2]</tt> = # elements in row 0 of <tt>ma</tt> &gt; <tt>va[1]</tt>
and &lt;= <tt>va[2]</tt>

<dt><tt>r[0][q]</tt> = # elements in row 0 of <tt>ma</tt> &gt; <tt>va[q-1]</tt>


<dt><tt>...</tt>

<dt><tt>r[1][0]</tt> = # elements in row 1 of <tt>ma</tt> &lt;= <tt>va[0]</tt>


<dt><tt>r[1][1]</tt> = # elements in row 1 of <tt>ma</tt> &gt; <tt>va[0]</tt>
and &lt;= <tt>va[1]</tt>

<dt><tt>r[1][2]</tt> = # elements in row 1 of <tt>ma</tt> &gt; <tt>va[1]</tt>
and &lt;= <tt>va[2]</tt>

<dt><tt>r[1][q]</tt> = # elements in row 1 of <tt>ma</tt> &gt; <tt>va[q-1]</tt>


<dt><tt>...</tt>
</dl>

<p>If <tt>ma</tt> is <i>m</i> <tt>x</tt> <i>n</i>, and <tt>va</tt> is 1
<tt>x</tt> <i>q</i> (or <i>q</i> <tt>x</tt> 1) the returned matrix is <i>m</i> <tt>x</tt> (<i>q</i>+1)
(any remaining columns of <tt>va</tt> are ignored).
If the values in <tt>va</tt> are not ordered, the return value
is filled with missing values.

<dt><i>See also</i>

<dd><tt><a href="#countc">countc</a></tt>

<dt><a href="oxstdexamples.html#countc"><i>Example</i></a>
</dl>



<a name="cumprod"></a><h2>cumprod</h2>

<pre>
cumprod(const mfac);
cumprod(const mfac, const cp);
cumprod(const mfac, const cp, const mz);
</pre>

<dl><dd>
<dl>
<dt><tt>mfac</tt>
<dd>in: <i>T</i> <tt>x</tt> <i>n</i> or 1 <tt>x</tt> <i>n</i> matrix of
multiplication factors <i>S</i>


<dt><tt>cp</tt>
<dd>in: int, autoregressive order <i>p</i> (optional argument; default is 1)

<dt><tt>mz</tt>
<dd>in: <i>T</i> <tt>x</tt> <i>n</i>  or 1 <tt>x</tt> <i>n</i> matrix of
known components <i>Z</i> (optional argument; default is 0)
</dl>

<dt><i>Return value</i>

<dd>
Returns a <i>T</i> <tt>x</tt> <i>n</i> matrix with the cumulated
autoregressive product.
The first <i>p</i> rows of the return value will be identical to the sum of those
in <tt>mz</tt> and <tt>mfac</tt>; the recursion will be applied from the <i>p</i>th term
onward.
If either <tt>mz</tt> or <tt>mfac</tt> is 1> <tt>x</tt> <i>n</i>, the same values are
used for every <i>t</i>.
<p>
<tt>cumprod</tt> computes:
<dl>
<dd><i>a</i><sub><i>t</i></sub> = <i>z</i><sub><i>t</i></sub> + <i>s</i><sub><i>t</i></sub>  for <i>t</i> = 0,...,<i>p</i>-1,
<dd><i>a</i><sub><i>t</i></sub> = <i>z</i><sub><i>t</i></sub> + <i>s</i><sub><i>t</i></sub> (<i>a</i><sub><i>t</i>-1</sub> <tt>x</tt> ... <tt>x</tt> <i>a</i><sub><i>t-p</i></sub>)
for <i>t</i> = <i>p</i>,...,<i>T</i>-1.

<dt><a href="oxstdexamples.html#cumprod"><i>Example</i></a>
</dl>


<dt><i>See also</i>

<dd>
<tt><a href="oxpackages.html#armagen">armagen</a></tt>,
<tt><a href="#cumsum">cumsum</a></tt>
<tt><a href="#cumulate">cumulate</a></tt>
</dl>


<a name="cumsum"></a><h2>cumsum</h2>

<pre>
cumsum(const mx, const vp);
cumsum(const mx, const vp, const mstart);
</pre>

<dl><dd>
<dl>
<dt><tt>mx</tt>
<dd>in: <i>T</i> <tt>x</tt> <i>n</i> matrix of known components <i>X</i>

<dt><tt>vp</tt>
<dd>in: 1 <tt>x</tt> <i>p</i> or <i>n</i> <tt>x</tt> <i>p</i>
or <i>T</i> <tt>x</tt> <i>p</i> matrix with AR coefficients
\phi<sub>1</sub>, \phi<sub>2</sub>, ..., \phi<i><sub>p</sub></i>

<dt><tt>mstart</tt>
<dd>in: <i>s</i> <tt>x</tt> <i>n</i> matrix of
starting values <i>S</i>, <i>s</i> &gt;= <i>p</i>;
(optional argument; default is <tt>mx</tt>)

</dl>

<dt><i>Return value</i>

<dd>
Returns a <i>T</i> <tt>x</tt> <i>n</i> matrix with the cumulated
autoregressive sum.
The first <i>p</i> rows of the return value will be identical to those
of <tt>mstart</tt>; the recursion will be applied from the <i>p</i>th term
onward.
<p>
If <tt>vp</tt> is 1 <tt>x</tt> <i>p</i>, the same coefficients are applied
to each column.
<p>
If <tt>vp</tt> is <i>n</i> <tt>x</tt> <i>p</i>, each row will have coefficients
specific to each column of the recursive series.

<p>
Finally, if <tt>vp</tt> is <i>T</i> <tt>x</tt> <i>p</i>,
the same coefficients are applied
to each column, but the coefficients are specific to each row
(time-varying coefficients).

<p>
<tt>cumsum</tt> computes:
<dl>
<dd><i>a</i><sub><i>t</i></sub> = <i>s</i><sub><i>t</i></sub>  for <i>t</i> = 0,...,<i>p</i>-1,
<dd><i>a</i><sub><i>t</i></sub> = <i>x</i><sub><i>t</i></sub> + \phi<sub>1</sub> <i>a</i><sub><i>t</i>-1</sub> ... + \phi<sub><i>p</i></sub> <i>a</i><sub><i>t-p</i></sub> for <i>t</i> = <i>p</i>,...,<i>T</i>-1.
</dl>
When \phi is <i>T</i> by <i>p</i> (and <i>p</i> is not equal to the
number of columns in <i>X</i>), the AR coefficients are time-varying:
<dl>
<dd><i>a</i><sub><i>t</i></sub> = <i>s</i><sub><i>t</i></sub>  for <i>t</i> = 0,...,<i>p</i>-1,
<dd><i>a</i><sub><i>t</i></sub> = <i>x</i><sub><i>t</i></sub> + \phi<sub><i>t</i>,1</sub> <i>a</i><sub><i>t</i>-1</sub> ... + \phi<sub><i>t,p</i></sub> <i>a</i><sub><i>t-p</i></sub> for <i>t</i> = <i>p</i>,...,<i>T</i>-1.
</dl>

<dt><i>See also</i>

<dd><tt><a href="oxpackages.html#armagen">armagen</a></tt>,
<tt><a href="#cumprod">cumprod</a></tt>
<tt><a href="#cumulate">cumulate</a></tt>

<dt><a href="oxstdexamples.html#cumsum"><i>Example</i></a>
</dl>


<a name="cumulate"></a><h2>cumulate</h2>

<pre>cumulate(const ma);
cumulate(const ma, const m1, ...);
cumulate(const ma, const am);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>

<dd>in: <i>T</i> <tt>x</tt> <i>n</i> matrix <i>A</i>

<dt><tt>m1</tt>

<dd>in: <i>n</i> <tt>x</tt> <i>n</i> matrix, coefficients of first lags
(optional argument)

<dt><tt>...</tt>

<dd>in: <i>n</i> <tt>x</tt> <i>n</i> matrix, coefficients of lags 2, ...

<dt><tt>am</tt>

<dd>in: array of length <i>k</i> with <i>n</i> <tt>x</tt> <i>n</i> coefficient matrices
</dl>

<dt><i>Return value</i>

<dd>Returns a <i>T</i> <tt>x</tt> <i>n</i> matrix. The simplest version
returns a matrix which holds the cumulated (integrated) columns of <tt>ma</tt>.
The second form cumulates (integrates) the (vector) autoregressive process
with current values <tt>ma</tt> using the specified coefficient matrices.
The function has a variable number of arguments, and the number of arguments
determines the autoregressive order (minimum 2 arguments, which is an AR(1)
process). Note that <tt>cumulate(m)</tt> corresponds to <tt>cumulate(m,
unit( columns(m) ))</tt>.

<dt><i>See also</i>

<dd><tt><a href="oxpackages.html#arma0">arma0</a></tt>,
<tt><a href="#cumsum">cumsum</a></tt>, <tt><a href="#lag0">lag0</a></tt>

<dt><a href="oxstdexamples.html#cumulate"><i>Example</i></a>
</dl>


<a name="date"></a><h2>date</h2>

<pre>date();
</pre>

<dl><dd>
<dt><i>Return value</i>

<dd>A string holding the current date.

<dt><i>See also</i>

<dd><tt><a href="#time">time</a></tt>

<dt><a href="oxstdexamples.html#date"><i>Example</i></a>
</dl>


<a name="dawson"></a><h2>dawson</h2>

<pre>dawson(const ma);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>

<dd>in: arithmetic type
</dl>

<dt><i>Return value</i>

<dd>Returns the Dawson integral of each element of <tt>ma</tt>, of double or
matrix type.
<dt><i>See also</i>

<dd><tt><a href="#erf">erf</a></tt>
</dl>


<a name="dayofcalendar"></a>
<a name="dayofeaster"></a>
<a name="dayofmonth"></a>
<a name="dayofweek"></a>
<h2>dayofcalendar, dayofeaster, dayofmonth, dayofweek</h2>

<pre>
dayofcalendar();
dayofcalendar(const index);
dayofcalendar(const year, const month, const day);
dayofeaster(const year);
dayofmonth(const year, const month, const dayofweek, const nth);
dayofweek(const index);
dayofweek(const year, const month, const day);
</pre>

<dl><dd>
<dl>
<dt><tt>index</tt>

<dd>in: arithmetic type, calendar index of a certain date, as returned
by <tt>dayofcalendar(year, month, day)</tt>
<dt><tt>year</tt>

<dd>in: arithmetic type, year
<dt><tt>month</tt>

<dd>in: arithmetic type, January=1, etc.
<dt><tt>day</tt>

<dd>in: arithmetic type, day (1,...,31)
<dt><tt>dayofweek</tt>

<dd>in: arithmetic type, day of week  (Sunday = 1, Monday = 2, ...)
<dt><tt>nth</tt>

<dd>in: arithmetic type, &gt;0: n-th from start of month, &lt;0: n-th from end of month
</dl>

<dt><i>Return value</i>

<dd>
The <tt>dayofcalendar</tt> function without any arguments returns the calendar index (Julian day number) of today.
<p>
The <tt>dayofcalendar</tt> function with three arguments returns the calendar index of the specified
date (this is the Julian day number, see below).
If all arguments are an integer, the return value will be an integer.
<p>
The <tt>dayofcalendar</tt> function with one argument takes a calendar index (or vector of indices),
as returned by <tt>dayofcalendar(year, month, day)</tt> as argument,
returning a <i>n</i><tt>x</tt>3 matrix with the triplet
year, month, day in each row (<i>n</i> is the number of elements in the input).
<p>
The <tt>dayofeaster</tt> function returns the calendar index of Easter.
<p>
The <tt>dayofmonth</tt> function returns the calendar index of the <i>n</i>-th
day of the week in the specified month (<i>n</i>-th from last for a negative
value). For example <tt>dayofmonth(2005, 5, 2, -1)</tt> returns the
index of the last Monday in May 2005.
<p>
The <tt>dayofweek</tt> function with three arguments returns the day of the week
(Sunday = 1, Monday = 2, ...).
If all arguments are an integer, the return value will be an integer.
<p>
The <tt>dayofweek</tt> function with one argument takes a calendar index (r vector of)
as argument, returning the day of the week
(Sunday = 1, Monday = 2, ...).

<dt><i>Description</i>

<dd>
The calendar 
index is the Julian day number, and the <tt>dayof...</tt>
functions convert from or to the index. For example, Julian day
2453402 corresponds to 2005-01-31. An optional fractional part specifies
the fraction of the day: 2453402.75 corresponds to 2005-01-01T18:00. If the
day number is zero, it is interpreted as a time only, so 0.75
is just 18:00 (6 PM).
<p>
Use <tt>dayofcalendar(year, month, day) - dayofcalendar(year, 1, 1) + 1</tt>
to compute the day in the year. Similarly, the function can be used to
compute the number of days between two dates.
<p>
The <tt>"%C"</tt> print format is available to print a calendar index.

<dt><i>See also</i>

<dd><tt><a href="#print">print</a></tt>, <tt><a href="#timeofday">timeofday</a></tt>, <tt><a href="#timing">timing</a></tt>

<dt><a href="oxstdexamples.html#dayofcalendar"><i>Example</i></a>
</dl>


<a name="decldl"></a><h2>decldl</h2>

<pre>decldl(const ma, const aml, const amd);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>

<dd>in: symmetric, positive definite <i>m</i> <tt>x</tt> <i>m</i> matrix
<i>A</i>

<dt><tt>aml</tt>

<dd>in: address of variable

<dd>out: <i>m</i> <tt>x</tt> <i>m</i> lower diagonal matrix <i>L</i>, <i>LDL</i>'=<i>A</i>


<dt><tt>amd</tt>

<dd>in: address of variable

<dd>out: 1 <tt>x</tt> <i>m</i> matrix with reciprocals of <i>D</i>
</dl>

<dt><i>Return value</i>

<dd>Returns the result of the Choleski decomposition:

<ul>
<li>1: no error;

<li>0: the Choleski decomposition failed: the matrix is negative definite
or the matrix is (numerically) singular.
</ul>

<dt><i>See also</i>

<dd><tt><a href="#choleski">choleski</a></tt>, <tt><a href="#decldlband">decldlband</a></tt>, <tt><a href="#solveldl">solveldl</a></tt>

<dt><a href="oxstdexamples.html#decldl"><i>Example</i></a>
</dl>


<a name="decldlband"></a><h2>decldlband</h2>

<pre>decldlband(const ma, const aml, const amd);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>

<dd>in: <i>p</i> <tt>x</tt> <i>m</i> vector specifying the <i>A<sup>b</sup></i>
matrix

<dt><tt>aml</tt>

<dd>in: address of variable

<dd>out: holds <i>p</i> <tt>x</tt> <i>m</i> lower diagonal matrix <i>L</i>


<dt><tt>amd</tt>

<dd>in: address of variable

<dd>out: 1 <tt>x</tt> <i>m</i> matrix with reciprocals of <i>D</i>
</dl>

<dt><i>Return value</i>

<dd>Returns the result of the Choleski decomposition:

<ul>
<li>1: no error;

<li>0: the Choleski decomposition failed: the matrix is negative definite
or the matrix is (numerically) singular.
</ul>

<p>For example, if the original matrix has bandwidth p=2, it is stored
in <tt>ma</tt> as:
<pre>
     0      0 [0][2] ... [m-3][m-1]
     0 [0][1] [1][2] ... [m-2][m-1]
[0][0] [1][1] [2][2] ... [m-1][m-1]
</pre>


<dt><i>See also</i>

<dd><tt><a href="#diagonal">diagonal</a></tt>
<tt><a href="#solveldlband">solveldlband</a></tt>, <tt><a href="#solvetoeplitz">solvetoeplitz</a></tt>

<dt><a href="oxstdexamples.html#decldlband"><i>Example</i></a>
</dl>


<a name="declu"></a><h2>declu</h2>

<pre>declu(const ma, const aml, const amu, const amp);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>

<dd>in: square <i>m</i> <tt>x</tt> <i>m</i> matrix <i>A</i>

<dt><tt>aml</tt>

<dd>in: address of variable

<dd>out: <i>m</i> <tt>x</tt> <i>m</i> lower diagonal matrix <i>L</i>,
has ones on the diagonal

<dt><tt>amu</tt>

<dd>in: address of variable

<dd>out: <i>m</i> <tt>x</tt> <i>m</i> upper diagonal matrix <i>U</i>,
<i>LU</i>=<i>PA</i>

<dt><tt>amp</tt>

<dd>in: address of variable

<dd>out: 2 <tt>x</tt> <i>m</i> matrix, the first row holds the permutation
matrix <i>P</i>', <i>A</i>=(<i>LU</i>)[<i>P</i>'][], the second row holds
the interchange permutations
</dl>

<dt><i>Return value</i>

<dd>Returns the result of the LU decomposition:

<ul>
<li>1: no error;

<li>2: the decomposition could be unreliable;

<li>0: the LU decomposition failed: the matrix is (numerically) singular.

</ul>

<dt><i>See also</i>

<dd><tt><a href="#determinant">determinant</a></tt>, <tt><a href="#invert">invert</a></tt>, <tt><a href="#solvelu">solvelu</a></tt>

<dt><a href="oxstdexamples.html#declu"><i>Example</i></a>
</dl>




<a name="decqr"></a><h2>decqr</h2>

<pre>
decqr(const ma, const amht, const amr, const amp);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>

<dd>in: <i>m</i> <tt>x</tt> <i>n</i> matrix <i>A</i>

<dt><tt>amht</tt>

<dd>in: address of variable

<dd>out: <i>n</i> <tt>x</tt> <i>m</i> lower diagonal matrix <i>H'</i>,
which holds householder vectors

<dt><tt>amr</tt>

<dd>in: address of variable

<dd>out: <i>n</i> <tt>x</tt> <i>n</i> upper diagonal matrix
<i>R<sub>1</sub></i>

<dt><tt>amp</tt>

<dd>in: address of variable
(use 0 as argument to avoid pivoting; note that pivoting
is recommended)

<dd>out: 2 <tt>x</tt> <i>n</i> matrix, the first row holds the permutation
matrix <i>P</i>', the second row holds the interchange permutations
</dl>


<dt><i>Return value</i>

<dd>
Computes the QR decomposition with pivoting, <i>AP</i>=<i>QR</i>, returning:

<ul>
<li>0: out of memory,

<li>1: success,

<li>2: ratio of diagonal elements of <i>A</i>'<i>A</i> is large, rescaling
is advised (ratio of smallest to largest <= <i>eps</i><sub><i>inv</i></sub>),

<li>-1: (<i>A</i>'<i>A</i>) is (numerically) singular:
|<i>R</i><sub><i>ii</i></sub>| <= <i>eps</i><sub><i>inv</i></sub>
max<sub><i>j</i></sub> sqrt[(<i>A</i>'<i>A</i>)<sub><i>jj</i></sub>],

<li>-2: combines 2 and -1.
</ul>
The inversion epsilon, <i>eps</i><sub><i>inv</i></sub>, is set by the
<tt><a href="#inverteps">inverteps</a></tt> function.

<dt><i>See also</i>

<dd><tt><a href="#decqrmul">decqrmul</a></tt>,
<tt><a href="#decqrupdate">decqrupdate</a></tt>,
<tt><a href="#inverteps">inverteps</a></tt>,
<tt><a href="#olsc">olsc</a></tt>, <tt><a href="#solvelu">solvelu</a></tt>

<dt><a href="oxstdexamples.html#decqr"><i>Example</i></a>
</dl>




<a name="decqrmul"></a><h2>decqrmul</h2>

<pre>
decqrmul(const mht, const my);
decqrmul(const mht);
</pre>

<dl><dd>
<dl>
<dt><tt>mht</tt>

<dd>in: <i>n</i> <tt>x</tt> <i>m</i> lower diagonal matrix <i>H'</i>,
which holds householder vectors from previous QR decomposition

<dt><tt>my</tt>

<dd>in: <i>m</i> <tt>x</tt> <i>p</i> matrix <i>Y</i>

</dl>


<dt><i>Return value</i>

<dd>
Returns <i>Q'Y</i>, where Q derives from a previous QR decomposition.
To compute <i>QY</i>, use <tt>reversec</tt> to reverse the elements in
each column of <tt>mht</tt>.<br>
The version with one argument
returns the <i>m</i> <tt>x</tt> <i>m</i> matrix <i>Q'</i>.

<dt><i>See also</i>

<dd><tt><a href="#decqr">decqr</a></tt>, <tt><a href="#olsc">olsc</a></tt>, <tt><a href="#solvelu">solvelu</a></tt>

<dt><a href="oxstdexamples.html#decqrmul"><i>Example</i></a>
</dl>



<a name="decqrupdate"></a><h2>decqrupdate</h2>

<pre>
decqrupdate(const amq, const amr, const i1, const i2);
decqrupdate(const amq, const amr, const i1);
</pre>

<dl><dd>
<dl>
<dt><tt>amq</tt>

<dd>in: address of <i>m</i> <tt>x</tt> <i>n</i> matrix <i>Q</i>
<dd>out: updated matrix <i>Q</i>

<dt><tt>my</tt>

<dd>in: address of <i>m</i> <tt>x</tt> <i>n</i> matrix <i>R</i>
<dd>out: updated matrix <i>R</i>

</dl>


<dt><i>No return value</i>

<dt><i>Description</i>
<dd>
Updates the QR decomposition using Givens rotations.
<p>
The version with only the <tt>i1</tt> argument zeroes the
subdiagonal elements from subdiagonal <tt>i1</tt> to the
diagonal (i.e. subdiagonal 0).
It is assumed that subdiagonals below <tt>i1</tt> are already zero.
<p>
The version with both the <tt>i1</tt> and <tt>i2</tt> arguments
zeroes the subdiagonal from column <tt>i1</tt> to column <tt>i2</tt>.
It is assumed that columns before <tt>i1</tt> are already zero
below the diagonal.
<p>
Both<br> 
<tt>decqrupdate(&amp;q, &amp;a, 0, columns(r));</tt> and<br>
<tt>decqrupdate(&amp;q, &amp;a, rows(r));</tt><br>
compute a complete QR decomposition (like <tt>decqr</tt>, although
<tt>decqr</tt> does not compute <i>Q</i> explicitly). However, the
<tt>decqrupdate</tt> function is primarily intended to update a
QR factorization.

<dd>

<dt><i>See also</i>

<dd><tt><a href="#decqr">decqr</a></tt>, <tt><a href="#decqrmul">decqrmul</a></tt>

<dt><a href="oxstdexamples.html#decqrupdate"><i>Example</i></a>
</dl>




<a name="decschur"></a>
<a name="decschurgen"></a>
<h2>decschur,decschurgen</h2>

<pre>decschur(const ma, const amval, const ams, ...);
decschur(const ma, const amval, const ams, const amv,
    const dselmin, const dselmax);
decschurgen(const ma, const mb, const amalpha, const ambeta,
    const ams, const amt, ...);
decschurgen(const ma, const mb, const amalpha, const ambeta,
    const ams, const amt, const amvl, const amvr,
	const dselmin, const dselmax);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>

<dd>in: <i>m</i> <tt>x</tt> <i>m</i> matrix <i>A</i>

<dt><tt>amval</tt>

<dd>in: address of variable

<dd>out: complex eigenvalues: 2 <tt>x</tt> <i>m</i>	matrix with eigenvalues
of <i>A</i>, first row is real part, second row imaginary part.
Only real eigenvalues: 1 <tt>x</tt> <i>m</i> matrix.
The eigenvalues are not ordered, unless <tt>dselmin</tt> and <tt>dselmax</tt> are specified.

<dt><tt>ams</tt>

<dd>in: address of variable

<dd>out: upper quasi-triangular Schur form <i>S</i>, such that <i>A</i>=<i>VSV</i>'

<dt><tt>amv</tt>

<dd>in: (optional) address of variable

<dd>out: orthogonal matrix <i>V</i> with Schur vectors, such that <i>A</i>=<i>VSV</i>'

<dt><tt>dselmin</tt>

<dd>in: (optional) double, minimum absolute eigenvalue to move forward

<dt><tt>dselmax</tt>

<dd>in: (optional) double, maximum absolute eigenvalue to move forward

<dt><tt>ma</tt>

<dd>in: <i>m</i> <tt>x</tt> <i>m</i> matrix <i>A</i>

<dt><tt>mb</tt>

<dd>in: <i>m</i> <tt>x</tt> <i>m</i> matrix <i>B</i> for generalized Schur decomposition

<dt><tt>amalpha</tt>

<dd>in: address of variable

<dd>out: complex eigenvalues: 2 <tt>x</tt> <i>m</i>	matrix with alpha
of <i>A</i>, first row is real part, second row imaginary part.
Only real alphas: 1 <tt>x</tt> <i>m</i> matrix.<br>
The generalized eigenvalues are (alphar[<i>j</i>]+<i>i</i>*alphai[<i>j</i>])/beta[<i>j</i>], <i>j</i>=0,...,<i>m</i>-1
The generalized eigenvalues are not ordered, unless <tt>dselmin</tt> and <tt>dselmax</tt> are specified.

<dt><tt>ambeta</tt>

<dd>in: address of variable

<dd>out: 1 <tt>x</tt> <i>m</i> matrix with beta

<dt><tt>ams</tt>

<dd>in: address of variable

<dd>out: upper quasi-triangular Schur form <i>S</i>, such that <i>A</i>=<i>V<sub>l</sub>*S*V<sub>r</sub></i>'

<dt><tt>amt</tt>

<dd>in: address of variable

<dd>out: upper triangular Schur form <i>T</i>, such that <i>B</i>=<i>V<sub>l</sub>*T*V<sub>r</sub></i>'

<dt><tt>amvl</tt>

<dd>in: (optional) address of variable

<dd>out: orthogonal matrix <i>V<sub>l</sub></i> with left Schur vectors

<dt><tt>amvr</tt>

<dd>in: (optional) address of variable

<dd>out: orthogonal matrix <i>V<sub>r</sub></i> with right Schur vectors

<dt><tt>dselmin</tt>

<dd>in: (optional) double, minimum absolute generalized eigenvalue to move forward

<dt><tt>dselmax</tt>

<dd>in: (optional) double, maximum absolute generalized eigenvalue to move forward

</dl>

<dt><i>Return value</i>

<dd>Returns the result of the Schur decomposition:

<ul>
<li>0: no error;

<li>1: maximum no of iterations reached;

<li>-1: ill conditioning prevented ordering;

<li>-2: rounding errors in ordering affected complex eigenvalues.
</ul>

<dt><i>Description</i>

<dd>
The <tt>decschur</tt> function computes the Schur decomposition of a real
matrix <i>A</i>=<i>VSV</i>',
where <i>V</i> is orthogonal, and <i>S</i> upper quasi-triangular, with
2 <tt>x</tt> 2
blocks on the diagonal corresponding to complex eigenvalues.

The <tt>decschurgen</tt> function computes the generalized Schur
decomposition of two real matrices <i>A,B</i>:
    <i>A</i>=<i>V<sub>l</sub>SV<sub>r</sub></i>', <i>B</i>=<i>V<sub>l</sub>TV<sub>r</sub></i>',
where <i>V</i> is orthogonal, and <i>S</i> upper quasi-triangular, with
2 <tt>x</tt> 2
blocks on the diagonal corresponding to complex eigenvalues.
<i>T</i> is an upper-triangular matrix. The generalized eigenvalues
are alpha[i]/beta[i], where alpha may be complex and
beta is real.

The Schur decomposition can be ordered if the <tt>dselmin</tt>
and <tt>dselmax</tt> arguments are specified. Any (generalized)
eigenvalues that are &ge; <tt>dselmin</tt> and &le; <tt>dselmax</tt>
in absolute value, are selected for reordering, and moved to the top left. Note the reordering
may affect complex eigenvalue when the matrices are ill-conditioned.

Sources: these routines are based on LAPACK 3.0.

<dt><a href="oxstdexamples.html#decschur"><i>Example</i></a>
</dl>



<a name="decsvd"></a><h2>decsvd</h2>

<pre>decsvd(const ma);
decsvd(const ma, const amu, const amw);
decsvd(const ma, const amu, const amw, const amv);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>

<dd>in: <i>m</i> <tt>x</tt> <i>n</i> matrix <i>A</i>


<dt><tt>amu</tt>

<dd>in: address of variable

<dd>out: <i>m</i> <tt>x</tt> <i>n</i> matrix <i>U</i>, <i>U</i>'<i>U</i>
= <i>I<sub>n</sub></i>

<dt><tt>amw</tt>

<dd>in: address of variable

<dd>out: 1 <tt>x</tt> <i>n</i> matrix with diagonal of <i>W</i>

<dt><tt>amv</tt>

<dd>in: (optional argument) address of variable

<dd>out: if not 0 on input: <i>n</i> <tt>x</tt> <i>n</i> matrix <i>V</i>,
<i>UWV</i>'=<i>A</i>, <i>V</i>'<i>V</i> = <i>I<sub>n</sub></i>
</dl>

<dt><i>Return value</i>

<dd>The version with one argument: returns a
1 <tt>x</tt> min(<i>m</i>,<i>n</i>) matrix with
the singular values, or 0 if the decomposition failed.

<dd>The version with two or more arguments returns an integer indicating
the result of the singular value decomposition:

<ul>
<li>0: no error;

<li>k: if the <i>k</i>-th singular value (with index <i>k</i>-1) failed after 50 iterations.
</ul>

<p>Note that the singular values are in decreasing order, with the columns
of <i>U</i>,<i>V</i> sorted accordingly.

<dt><i>See also</i>
<a href="oxsyntax.html#ox_syntax_RefMultExpr">multiplicative expressions</a>

<dt><a href="oxstdexamples.html#decsvd"><i>Example</i></a>
</dl>



<a name="deletec"></a>
<a name="deleter"></a>
<a name="deleteifc"></a>
<a name="deleteifr"></a>
<h2>deletec, deleter, deleteifc, deleteifr</h2>

<pre>deletec(const ma);
deletec(const ma, const mval);
deleter(const ma);
deleter(const ma, const mval);
deleteifc(const ma, const mifc);
deleteifr(const ma, const mifr);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>   <dd> in: <i>m</i> <tt>x</tt> <i>n</i> matrix to delete from
<dt><tt>mval</tt> <dd> in: <i>p</i> <tt>x</tt> <i>q</i> matrix with values to use for deletion
<dt><tt>mifc</tt> <dd> in: <i>p</i> <tt>x</tt> <i>n</i> boolean matrix specifying columns to delete
<dt><tt>mifr</tt> <dd> in: <i>m</i> <tt>x</tt> <i>q</i> boolean matrix specifying rows to delete
</dl>

<dt><i>Return value</i>
<dd>The <tt>deletec</tt> function with one argument returns an <i>m</i> <tt>x</tt> <i>s</i>
matrix, deleting columns from <tt>ma</tt> which have a missing value (NaN: not a number).

<dd>The <tt>deleter</tt> function with one argument returns an <i>s</i> <tt>x</tt> <i>n</i>
matrix, deleting rows from <tt>ma</tt> which have a missing value (NaN).

<dd>The remaining forms do not have special treatment of missing values.

<dd>The <tt>deletec</tt> function with two arguments returns an <i>m</i> <tt>x</tt> <i>s</i> matrix,
deleting the columns from <tt>ma</tt> which have at least one element equal to
an element in the matrix <tt>mval</tt>.

<dd>The <tt>deleter</tt> function with two arguments returns an <i>s</i> <tt>x</tt> <i>n</i> matrix,
deleting the rows from <tt>ma</tt> which have at least one element equal to
an element in the matrix <tt>mval</tt>.

<dd>The deleteif functions can be used to delete rows or columns
based on a logical expression: all rows (columns) wich have a
zero in the corresponding row (column) are kept, the remainder
is dropped.

<dd>The <tt>deleteifc</tt> function returns an <i>m</i> <tt>x</tt> <i>s</i> matrix,
deleting only those columns from <tt>ma</tt> which have at least one non-zero
element in the corresponding column of <tt>mifc</tt>.

<dd>The <tt>deleteifr</tt> function returns an <i>s</i> <tt>x</tt> <i>n</i> matrix,
deleting only those rows from <tt>ma</tt> which have at least one non-zero
element in the corresponding row of <tt>mifr</tt>.

<dd>All functions return an empty matrix if the result is empty.

<dt><i>See also</i>
<dd>
<tt><a href="#dropc">dropc</a></tt>,
<tt><a href="#dropr">dropr</a></tt>,
<tt><a href="#selectc">selectc</a></tt>,
<tt><a href="#selectr">selectr</a></tt>,
<tt><a href="#selectrc">selectrc</a></tt>,
<tt><a href="#selectifc">selectifc</a></tt>,
<tt><a href="#selectifr">selectifr</a></tt>,
<tt><a href="#isdotnan">isdotnan</a></tt>,
<tt><a href="#vecindex">vecindex</a></tt>

<dt><a href="oxstdexamples.html#deleteifc"><i>Example</i></a>
</dl>




<a name="denschi"></a>
<a name="densf"></a>
<a name="densn"></a>
<a name="denst"></a>
<h2>denschi,densf,densn,denst</h2>

<pre>
denschi(const ma, const df);
densf(const ma, const df1, const df2);
densn(const ma);
denst(const ma, const df);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>
<dd>in: arithmetic type

<dt><tt>df</tt>
<dd>in: arithmetic type, degrees of freedom

<dt><tt>df1</tt>
<dd>in: arithmetic type, degrees of freedom in the numerator

<dt><tt>df2</tt>
<dd>in: arithmetic type, degrees of freedom in the denominator
</dl>

<dt><i>Return value</i>

<dd>Returns the requested density at <tt>ma</tt> (the returned densities
are between positive):

<ul>
<li><tt>denschi</tt>: chi<sup>2</sup>(df) density,

<li><tt>densf</tt>: F(df1, df2) density,

<li><tt>densn</tt>: standard normal density,

<li><tt>denst</tt>: student-t(df) density.

</ul>

The return type is derived as follows:

<ul>
<li><i>m</i> <tt>x</tt> <i>n</i> matrix, when <tt>ma</tt> is an <i>m</i>
<tt>x</tt> <i>n</i> matrix, and the rest is scalar;


<li><i>m</i> <tt>x</tt> <i>n</i> matrix, when <tt>ma</tt> is a scalar,
and the rest are <i>m</i> <tt>x</tt> <i>n</i> matrices;

<li><i>m</i> <tt>x</tt> <i>n</i> matrix, when <tt>ma</tt> is an <i>m</i>
<tt>x</tt> <i>n</i> matrix, and the rest are <i>m</i> <tt>x</tt> <i>n</i>
matrices;

<li>double, when <tt>ma</tt> is scalar, and the rest is also scalar.
</ul>

<dt><i>See also</i>

<dd><tt><a href="#probchi">prob...</a></tt>, <tt><a href="#quanchi">quan...</a></tt>, <tt><a href="#tailchi">tail...</a></tt>,
<a href="oxpackages.html#ProbPack">Probability package</a>
</dl>


<a name="determinant"></a><h2>determinant</h2>

<pre>determinant(const ma);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>

<dd>in: <i>m</i> <tt>x</tt> <i>m</i> matrix
</dl>

<dt><i>Return value</i>

<dd>Returns the determinant of <tt>ma</tt>. Return type is double.

<dt><i>See also</i>

<dd><tt><a href="#declu">declu</a></tt>, <tt><a href="#invert">invert</a></tt>, <tt><a href="#logdet">logdet</a></tt>

<dt><a href="oxstdexamples.html#determinant"><i>Example</i></a>
</dl>




<a name="dfft"></a><h2>dfft</h2>

<pre>
dfft(const ma);
dfft(const ma, const inverse);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>
<dd>in: 2 <tt>x</tt> <i>n</i> matrix (first row is real part,
second row imaginary part),
or 1 <tt>x</tt> <i>n</i> matrix (real part only, imaginary part is zero)

<dt><tt>inverse</tt>
<dd>in: (optional argument), int: 1 (do an inverse discrete FT) or 2 (do an inverse real DFT)
</dl>

<dt><i>Return value</i>

<dd>
If only one argument is used, the return value is a
2 <tt>x</tt> <i>n</i> matrix which holds the discrete Fourier transform.

<p>
If <tt>inverse</tt> equals 1, the return value is a
2 <tt>x</tt> <i>n</i> matrix which holds the inverse discrete Fourier transform.

<p>
If <tt>inverse</tt> equals 2, the return value is a
1 <tt>x</tt> <i>n</i> matrix which holds the real inverse discrete Fourier transform.


<dt><i>See also</i>

<dd><tt><a href="#fft1d">fft1d</a></tt>

<dt><a href="oxstdexamples.html#dfft"><i>Example</i></a>
</dl>



<a name="diag"></a><h2>diag</h2>

<pre>diag(const ma);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>

<dd>in: double, or <i>m</i> <tt>x</tt> 1 or 1 <tt>x</tt> <i>m</i> matrix

</dl>

<dt><i>Return value</i>

<dd>Returns a <i>m</i> <tt>x</tt> <i>m</i> matrix with <tt>ma</tt> on
the diagonal.

<dt><i>See also</i>

<dd><tt><a href="#diagonal">diagonal</a></tt>, <tt><a href="#diagonalize">diagonalize</a></tt>, <tt><a href="#toeplitz">toeplitz</a></tt>

<dt><a href="oxstdexamples.html#diag"><i>Example</i></a>
</dl>


<a name="diagcat"></a><h2>diagcat</h2>

<pre>diagcat(const ma, const mb);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>

<dd>in: <i>m</i> <tt>x</tt> <i>n</i> matrix

<dt><tt>mb</tt>

<dd>in: <i>p</i> <tt>x</tt> <i>q</i> matrix
</dl>

<dt><i>Return value</i>

<dd>Returns an <i>m+p</i> <tt>x</tt> <i>n+q</i> matrix with <tt>mb</tt>
concatenated to <tt>ma</tt> along the diagonal; the off-diagonal blocks are set to zero.

<dt><a href="oxstdexamples.html#diagcat"><i>Example</i></a>
</dl>


<a name="diagonal"></a><h2>diagonal</h2>

<pre>diagonal(const ma);
diagonal(const ma, const upr);
diagonal(const ma, const upr, const lwr);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>

<dd>in: arithmetic type

<dt><tt>upr</tt>

<dd>in: (optional argument), int: upper bandwidth (&gt;= 0, default 0)

<dt><tt>lwr</tt>

<dd>in: (optional argument), int: lower bandwidth (&lt;= 0, default 0)
</dl>

<dt><i>Return value</i>

<dd>
The version with one argument returns a matrix with the diagonal from the specified matrix in the first
row. <i>Note that the diagonal is returned as a row vector, not a column</i>.
If <tt>ma</tt> is <i>m</i> <tt>x</tt> <i>n</i>, the returned matrix is
1 by min(<i>m</i>,<i>n</i>) (exception: 0 <tt>x</tt> 0 when <i>m</i>=0); if <tt>ma</tt> is scalar,
the returned matrix is 1 <tt>x</tt> 1.
<p>
The general version returns the banded form, extracting <tt>upr</tt> upper diagonals
and <tt>lwr</tt> lower diagonals.
For example, if <tt>upr</tt>=2 and <tt>lwr</tt>=-1 and the returned matrix is:
<pre>
     0      0 [0][2] ... 
     0 [0][1] [1][2] ... 
[0][0] [1][1] [2][2] ... 	(diagonal)
[1][0] [2][1] [3][2] ... 
</pre>

<dt><i>See also</i>

<dd><tt><a href="#decldlband">decldlband</a></tt>, 
<tt><a href="#diag">diag</a></tt>, <tt><a href="#diagonalize">diagonalize</a></tt>, <tt><a href="#setdiagonal">setdiagonal</a></tt>

<dt><a href="oxstdexamples.html#diagonal"><i>Example</i></a>
</dl>


<a name="diagonalize"></a><h2>diagonalize</h2>

<pre>diagonalize(const ma);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>

<dd>in: arithmetic type
</dl>

<dt><i>Return value</i>

<dd>Returns a matrix with the diagonal of <tt>ma</tt> on its diagonal,
and zeros in off-diagonal elements. If <tt>ma</tt> is <i>m</i> <tt>x</tt>
<i>n</i>, the returned matrix is <i>m</i> <tt>x</tt> <i>n</i>; if <tt>ma</tt>
is scalar, the returned matrix is 1 <tt>x</tt> 1.

<dt><i>See also</i>

<dd><tt><a href="#diag">diag</a></tt>, <tt><a href="#diagonal">diagonal</a></tt>, <tt><a href="#setdiagonal">setdiagonal</a></tt>

<dt><a href="oxstdexamples.html#diagonalize"><i>Example</i></a>
</dl>



<a name="diff"></a>
<a name="diff0"></a>
<h2>diff,diff0</h2>

<pre>
diff(const ma);
diff(const ma, const ilag);
diff(const ma, const ilag, const dmisval);
diff0(const ma);
diff0(const ma, const ilag);
diff0(const ma, const ilag, const dmisval);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>

<dd>in: <i>T</i> <tt>x</tt> <i>n</i> matrix <i>A</i>

<dt><tt>ilag</tt>

<dd>in: int, lag length of difference (1 for first difference; this is the default)

<dt><tt>dmisval</tt>

<dd>in: (optional argument) double, value to set missing observations to
(default is 0 for <tt>diff0</tt>, <tt>.NaN</tt> for <tt>diff</tt>)
</dl>

<dt><i>Return value</i>

<dd>The <tt>diff</tt> function returns a <i>T</i> <tt>x</tt> <i>n</i> matrix with the <tt>ilag</tt>th
difference of the specified matrix, whereby missing values are replaced
by <tt>.NaN</tt>. The <tt>diff0</tt> function is the same, but using zero for the missing value.
The result has the same dimensions as <tt>ma</tt>.

<dt><i>See also</i>

<dd><tt><a href="#lag">lag</a></tt>, <tt><a href="#lag0">lag0</a></tt>
<tt><a href="oxpackages.html#diffpow">diffpow</a></tt>,

<dt><a href="oxstdexamples.html#diff0"><i>Example</i></a>
</dl>


<a name="discretize"></a><h2>discretize</h2>

<pre>discretize(const vx, const dmin, const dmax, const icount,
    const ioption);
</pre>

<dl><dd>
<dl>
<dt><tt>vx</tt>

<dd>in: <i>1</i> <tt>x</tt> <i>T</i> data vector
<dt><tt>dmin</tt>

<dd>in: double, first point <i>a</i>
<dt><tt>dmax</tt>

<dd>in: double, last point <i>b</i>
<dt><tt>icount</tt>

<dd>in: int, number of points <i>M</i>

<dt><tt>ioption</tt>

<dd>in: int, 0: raw discretization; 1: weighted discretization
</dl>

<dt><i>Return value</i>

<dd>
Returns a <i>1</i> <tt>x</tt> <i>M</i> matrix with the discretized data.

<dt><i>See also</i>

<dd><tt><a href="#countc">countc</a></tt>

<dt><a href="oxstdexamples.html#discretize"><i>Example</i></a>
</dl>


<a name="double"></a><h2>double</h2>

<pre>double(const ma);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>

<dd>in: arithmetic type
</dl>

<dt><i>Return value</i>

<dd>Casts the argument to a double:

<ul>
<li>integer argument: converted to a double;

<li>double argument: unchanged;

<li>matrix argument: element 0,0;

<li>string argument: packs up to 8 characters into a double, see
<a href="oxsyntax.html#ox_syntax_RefCast">explicit type conversion</a>;

<li>other argument types: error.
</ul>

<dt><i>See also</i>

<dd><tt><a href="#int">int</a></tt>, <tt><a href="#matrix">matrix</a></tt>, <tt><a href="#string">string</a></tt>
<a href="oxsyntax.html#ox_syntax_RefCast">explicit type conversion</a>
</dl>



<a name="dropc"></a>
<a name="dropr"></a>
<h2>dropc,dropr</h2>

<pre>
dropc(const ma, const midxc);
dropr(const ma, const midxr);
dropr(const aa, const midxr);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>   <dd> in: <i>m</i> <tt>x</tt> <i>n</i> matrix to delete from
<dt><tt>aa</tt>   <dd> in: <i>m</i> array to delete from
<dt><tt>midxc</tt> <dd> in: <i>p</i> <tt>x</tt> <i>q</i> matrix specifying the index of columns to delete
<dt><tt>midxr</tt> <dd> in: <i>p</i> <tt>x</tt> <i>q</i>  matrix specifying the index of rows to delete
</dl>

<dt><i>Return value</i>
<dd>The <tt>dropc</tt> function with returns a copy of the input matrix
with the specified columns deleted.

<dd>The <tt>dropr</tt> function with returns a copy of the input matrix
with the specified rows deleted; <tt>dropr</tt> also works for arrays.

<dd>All functions return an empty matrix if all rows or columns
are deleted (or empty array for arrays).

<dt><i>See also</i>
<dd>
<tt><a href="#deleteifc">deleteifc</a></tt>,
<tt><a href="#deleteifr">deleteifr</a></tt>,
<tt><a href="#insertc">insertc</a></tt>,
<tt><a href="#insertr">insertr</a></tt>,
<tt><a href="#vecindex">vecindex</a></tt>

<dt><a href="oxstdexamples.html#dropc"><i>Example</i></a>
</dl>




<a name="eigen"></a>
<a name="eigensym"></a>
<h2>eigen,eigensym</h2>

<pre>eigen(const ma, const amval);
eigen(const ma, const amval, const amvec);
eigensym(const ms, const amsval);
eigensym(const ms, const amsval, const amsvec);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>

<dd>in: <i>m</i> <tt>x</tt> <i>m</i> matrix <i>A</i>

<dt><tt>amval</tt>

<dd>in: address of variable

<dd>out: complex eigenvalues: 2 <tt>x</tt> <i>m</i>	matrix with eigenvalues
of <i>A</i>, first row is real part, second row imaginary part.
Only real eigenvalues: 1 <tt>x</tt> <i>m</i> matrix.
<i>The eigenvalues are not sorted</i>.

<dt><tt>amvec</tt>

<dd>in: address of variable

<dd>out: complex eigenvectors: 2<i>m</i> <tt>x</tt> <i>m</i> matrix with
eigenvectors of <i>A</i> in columns (real values are in first <i>m</i> rows).
Only real eigenvalues: <i>m</i> <tt>x</tt> <i>m</i> matrix with
eigenvectors in columns.

<dt><tt>ms</tt>

<dd>in: symmetric <i>m</i> <tt>x</tt> <i>m</i> matrix <i>A<sup>s</sup></i>


<dt><tt>amsval</tt>

<dd>in: address of variable

<dd>out: 1 <tt>x</tt> <i>m</i> matrix with eigenvalues of <i>A<sup>s</sup></i>, sorted in decreasing order


<dt><tt>amsvec</tt>

<dd>in: address of variable

<dd>out: <i>m</i> <tt>x</tt> <i>m</i> matrix with eigenvectors of <i>A<sup>s</sup></i>
in columns
</dl>

<dt><i>Return value</i>

<dd>Solves the eigenproblem <i>Ax</i> = \lambda <i>x</i>, returning
the result of the eigenvalue decomposition:

<ul>
<li>0: no error;

<li>1: maximum no of iterations (50) reached.
</ul>

<dt><a href="oxstdexamples.html#eigen"><i>Example</i></a>
</dl>




<a name="eigensymgen"></a><h2>eigensymgen</h2>

<pre>eigensymgen(const ma, const mb, const amval, const amvec);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>

<dd>in: <i>m</i> <tt>x</tt> <i>m</i> symmetric matrix <i>A</i>

<dt><tt>mb</tt>

<dd>in: <i>m</i> <tt>x</tt> <i>m</i> symmetric positive definite matrix <i>B</i>

<dt><tt>amval</tt>

<dd>in: address of variable

<dd>out: 1 <tt>x</tt> <i>m</i> matrix with (generalized) eigenvalues of <i>A</i>, sorted in decreasing order


<dt><tt>amvec</tt>

<dd>in: address of variable

<dd>out: <i>n</i> <tt>x</tt> <i>m</i> matrix with (generalized) eigenvectors of <i>A</i>
in columns
</dl>

<dt><i>Return value</i>

<dd>Solves the general eigenproblem <i>Ax</i> = \lambda <i>Bx</i>. returning
the result of the eigenvalue decomposition:

<ul>
<li>0: no error;

<li>1: maximum no of iterations (50) reached.

<li>-1: Choleski decomposition failed.
</ul>

<dt><i>See also</i>

<dd><tt><a href="#decldl">decldl</a></tt>, <tt><a href="#eigensym">eigensym</a></tt>

<dt><a href="oxstdexamples.html#eigensymgen"><i>Example</i></a>
</dl>



<a name="eprint"></a><h2>eprint</h2>

<pre>eprint(const a, ...);
</pre>

<dl><dd>
<dl>
<dt><tt>a</tt>

<dd>in: any type

<dt><tt>...</tt>

<dd>in: any type
</dl>

<dt><i>Return value</i>

<dd>Returns the number of arguments supplied to the function. Prints to
stderr. See <tt><a href="#print">print</a></tt> for a further description.

<dt><i>See also</i>

<dd><tt><a href="#fprint">fprint</a></tt>, <tt><a href="#print">print</a></tt>, <tt><a href="#sprint">sprint</a></tt>

<dt><a href="oxstdexamples.html#eprint"><i>Example</i></a>
</dl>

<a name="erf"></a><h2>erf</h2>

<pre>erf(const ma);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>

<dd>in: arithmetic type
</dl>

<dt><i>Return value</i>

<dd>Returns the error function of each element of <tt>ma</tt>, of double or
matrix type.

<dt><i>See also</i>

<dd><tt><a href="#cexp">cexp</a></tt>
</dl>


<a name="exclusion"></a><h2>exclusion</h2>

<pre>exclusion(const ma, const mb);
exclusion(const ma, const mb, const amidx);
</pre>

<dl><dd>
<dl>
<dt><tt>ma, mb</tt>

<dd>in: matrix
<dt><tt>amidx</tt>

<dd>in: address of variable
<dd>out: 2 <tt>x</tt> c	matrix, first row is index of exclusion
in <tt>ma</tt>, second row is index in <tt>mb</tt>.
</dl>

<dt><i>Return value</i>

<dd>Returns the sorted unique elements of <tt>ma</tt>
which are not in <tt>mb</tt> as a row vector.
Returns an empty matrix if the result is empty.
Missing values are skipped.

<dt><i>See also</i>

<dd><tt><a href="#intersection">intersection</a></tt>,
<tt><a href="#unique">unique</a></tt>,
<tt><a href="#union">union</a></tt>

<dt><a href="oxstdexamples.html#exclusion"><i>Example</i></a>
</dl>


<a name="exit"></a><h2>exit</h2>

<pre>exit(const iexit);
</pre>

<dl><dd>
<dl>
<dt><tt>iexit</tt>

<dd>in: integer, exit code
</dl>

<dt><i>No return value</i>. 

<dt>Exits the Ox run-time environment. The specified exit code is ignored.
</dl>


<a name="exp"></a><h2>exp</h2>

<pre>exp(const ma);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>

<dd>in: arithmetic type
</dl>

<dt><i>Return value</i>

<dd>Returns the exponent of each element of <tt>ma</tt>, of double or
matrix type.

<dt><i>See also</i>

<dd><tt><a href="#log">log</a></tt>

<dt><a href="oxstdexamples.html#exp"><i>Example</i></a>
</dl>


<a name="expint"></a><h2>expint</h2>

<pre>expint(const ma);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>

<dd>in: arithmetic type
</dl>

<dt><i>Return value</i>

<dd>Returns the exponent integral Ei of each element of <tt>ma</tt>, of double or
matrix type. Note that <i>E<sub>1</sub></i>(<i>x</i>)=-Ei(<i>-x</i>).
</dl>


<a name="fabs"></a><h2>fabs</h2>

<pre>fabs(const ma);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>

<dd>in: int, double, matrix
</dl>

<dt><i>Return value</i>

<dd>Returns the absolute value of each element of <tt>ma</tt>, of the
same type as <tt>ma</tt>.

<dt><a href="oxstdexamples.html#fabs"><i>Example</i></a>
</dl>


<a name="factorial"></a><h2>factorial</h2>

<pre>factorial(const ma);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>

<dd>in: arithmetic type
</dl>

<dt><i>Return value</i>

<dd>Returns the factorial function at the rounded value
of each element of <tt>ma</tt>, of double or matrix type. Returns +.NaN
for any argument which is negative.
Note that n!=n*(n-1)...2*1, and n! equals gammafact(n+1).
<p>
Often a ratio of factorials functions is needed. Note that
the factorial can overflow rapidly. However, often there is
an offsetting factor in the denominator/numerator, and it is advised to
use the <tt>loggamma</tt> or <tt>binomial</tt> function instead
in that case. 

<dt><i>See also</i>

<dd><tt><a href="#binomial">binomial</a></tt>,
<tt><a href="#gammafact">gammafact</a></tt>,
<tt><a href="#loggamma">loggamma</a></tt>
</dl>


<a name="fclose"></a><h2>fclose</h2>

<pre>fclose(const file);
</pre>

<dl><dd>
<dl>
<dt><tt>file</tt>

<dd>in: an open file which is to be closed<br>
(use <tt>fclose("l")</tt> to close the log file).
</dl>

<dt><i>Return value</i>

<dd>Returns 0.


<dt><i>See also</i>

<dd><tt><a href="#fopen">fopen</a></tt>

<dt><a href="oxstdexamples.html#fprint"><i>Example</i></a>
</dl>



<a name="feof"></a>
<a name="fflush"></a>
<h2>feof,fflush</h2>

<pre>feof(const file);
fflush(const file);
</pre>

<dl><dd>
<dl>
<dt><tt>file</tt>

<dd>in: an open file
</dl>

<dt><i>Return value</i>

<dd><tt>feof</tt> checks for end of file; returns 0 if not at end of file,
a non-zero value otherwise.	<tt>fflush</tt> flushes the file buffer.
</dl>



<a name="fft"></a>
<a name="fft1d"></a>
<h2>fft,fft1d</h2>

<pre>
fft(const ma);
fft(const ma, const inverse);
fft1d(const ma);
fft1d(const ma, const inverse);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>
<dd>in: 2 <tt>x</tt> <i>n</i> matrix (first row is real part,
second row imaginary part),
or 1 <tt>x</tt> <i>n</i> matrix (real part only, imaginary part is zero)

<dt><tt>inverse</tt>
<dd>in: (optional argument), int: 1 (do an inverse FFT) or 2 (do an inverse real FFT)
</dl>

<dt><i>Return value</i>

<dd>
If only one argument is used, the return value is a
2 <tt>x</tt> <i>s</i> matrix which holds the Fourier transform.

<p>
If <tt>inverse</tt> equals 1, the return value is a
2 <tt>x</tt> <i>s</i> matrix which holds the inverse Fourier transform.

<p>
If <tt>inverse</tt> equals 2, the return value is a
1 <tt>x</tt> <i>s</i> matrix which holds the real inverse Fourier transform.

<p>
For <tt>fft1d</tt>, <i>s</i>=<i>n</i>, so it returns the same number of columns
as the input.

But <tt>fft</tt> pads with zeros until a power of two is reached:
<i>s</i> is the smallest power of 2 which is &gt;= <i>n</i>.

<dt><i>Description</i>
<dd>
Performs an (inverse) fast Fourier transform. The code is based
on <a href="http://www.ffte.jp">FFTE 2.0</a> by Daisuke Takahashi.
FFTE provides Discrete Fourier Transforms of sequences of
length (2^p)*(3^q)*(5^r), which has been extended to work for all
sample size. 

If the input has no complex part, in the absence
of the <i>inverse</i> argument, a real FFT is performed.

<dt><a href="oxstdexamples.html#fft"><i>Example</i></a>
</dl>


<a name="find"></a><h2>find</h2>

<pre>find(const where, const what);
find(const where, const what, const mode);
</pre>

<dl><dd>
<dl>
<dt><tt>where</tt> 
<dd>in: object to search in
<dt><tt>what</tt> 
<dd>in: what to search for
<dt><tt>mode</tt> 
<dd>in: (optional argument), string controlling search method: "i", "ir", "r" or nothing
</dl>


<dt><i>Return value</i>

<dd>
<table border="2" cellpadding="4" cellspacing="2">
<tr><td><tt>where</tt></td><td><tt>what</tt></td><td>return type</td></tr>
<tr><td><i>m</i>-vector</td><td><i>c</i>-vector</td><td><i>c</i> <tt>x</tt> 1 matrix with indices of occurrence (or -1 if not found)</td></tr>
<tr><td>array of strings</td><td>array of <i>c</i> string</td><td><i>c</i> <tt>x</tt> 1 matrix with indices of occurrence (or -1 if not found)</td></tr>
<tr><td>array of strings</td><td>string</td><td>int: index of occurrence of string <tt>what</tt>, or -1 if not found</td></tr>
<tr><td>string</td><td>string</td><td>int: index of occurrence of substring <tt>what</tt>, or -1 if not found</td></tr>
<tr><td>string</td><td><i>r</i> <tt>x</tt> <i>c</i> matrix with character values</td><td><i>rc</i> <tt>x</tt> 1 matrix with indices of occurrence (-1 if not found)</td></tr>
<tr><td>string</td><td>character</td><td>int: index of occurrence of character <tt>what</tt>, or -1 if not found</td></tr>
</table>

<dt><i>Description</i>
<dd>
When strings are involved, this function is identical to the <tt><a href="#strfind">strfind</a></tt> family, except that the
return value is a column vector.
The default is case-sensitive forward search; use mode "i" to ignore case, "r" to search in reverse order,
"ir" to do both.
<p>
When the two arguments are a vector (either column or row), <tt>find</tt> returns the
location of the <tt>what</tt> elements in <tt>where</tt>
(the numbers have to match exactly, or both be a missing value). The return value is a row vector with
the same number of elements as <tt>what</tt>. Only the first instance will be located if there are
multiple occurences in <tt>where</tt>; use
<tt><a href="#vecindex">vecindex</a></tt> to find all occurences of a certain value.

<dt><i>See also</i>

<dd><tt><a href="#strfind">strfind</a></tt>, <tt><a href="#replace">replace</a></tt>, <tt><a href="#vecindex">vecindex</a></tt>

<dt><a href="oxstdexamples.html#find"><i>Example</i></a>
</dl>



<a name="findsample"></a><h2>findsample</h2>

<pre>
findsample(const mdata, const vvarsel, const vlagsel,
    const it1, const it2, const imode, const ait1, const ait2);
</pre>

<dl><dd>
<dl>
<dt><tt>mdata</tt>
<dd>in: T <tt>x</tt> <i>n</i>  data matrix

<dt><tt>vvarsel</tt>
<dd>in: <i>p</i>-dimensional selection vector with indices in <tt>mdata</tt>
              or empty matrix to use whole <tt>mdata</tt> as selection

<dt><tt>vlagsel</tt>
<dd>in: <i>p</i>-dimensional selection vector lag lengths for selection
              or empty matrix to use no lags

<dt><tt>it1</tt>
<dd>in: int: first observation index to consider (&gt;= 0)
<dt><tt>it2</tt>
<dd>in: int: last observation index to consider (can use -1 for T-1)
<dt><tt>mode</tt>
<dd>in: int: sample selection mode<br>
              <tt>SAM_ALLVALID </tt> : all observations must be valid<br>
              <tt>SAM_ENDSVALID</tt> : only the first and last observation must be wholly valid
              (there may be missing observations in between)<br>
              <tt>SAM_ANYVALID </tt>: the first and last observation must have some valid data
<dt><tt>ait1</tt>
<dd>in: address of variable 
<dd>out: the first observation index
<dt><tt>ait2</tt>
<dd>in: address of variable 
<dd>out: the last observation index
</dl>

<dt><i>Return value</i>
The number of observation in the selected sample.

<dd>

<dt><a href="oxstdexamples.html#findsample"><i>Example</i></a>
</dl>



<a name="floor"></a><h2>floor</h2>

<pre>floor(const ma);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>

<dd>in: arithmetic type
</dl>

<dt><i>Return value</i>

<dd>Returns the floor of each element of <tt>ma</tt>, of double or matrix
type. The floor is the largest integer less than or equal to the argument.


<dt><i>See also</i>

<dd><tt><a href="#ceil">ceil</a></tt>, <tt><a href="#round">round</a></tt>, <tt><a href="#trunc">trunc</a></tt>

<dt><a href="oxstdexamples.html#ceil"><i>Example</i></a>
</dl>


<a name="fmod"></a><h2>fmod</h2>

<pre>fmod(const ma, const mb);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>

<dd>in: arithmetic type

<dt><tt>mb</tt>

<dd>in: arithmetic type
</dl>

<dt><i>Return value</i>

<dd>Returns the floating point remainder of <tt>ma</tt> / <tt>mb</tt>.
The sign of the result is that of <tt>ma</tt>. The return type is double
if both <tt>ma</tt> and <tt>mb</tt> are int or double. If <tt>ma</tt> is
a matrix, the return type is a matrix of the same size, holding the floating
point remainders <tt>ma</tt>[i][j] / <tt>mb</tt>[i][j], etc.

The return type is derived as follows:

<ul>
<li><i>m</i> <tt>x</tt> <i>n</i> matrix, when <tt>ma</tt> is an <i>m</i>
<tt>x</tt> <i>n</i> matrix, and <tt>mb</tt> is scalar;

<li><i>m</i> <tt>x</tt> <i>n</i> matrix, when <tt>ma</tt> is a scalar,
and <tt>mb</tt> is an <i>m</i> <tt>x</tt> <i>n</i> matrix;

<li><i>m</i> <tt>x</tt> <i>n</i> matrix, when <tt>ma</tt> is an <i>m</i>
<tt>x</tt> <i>n</i> matrix, and <tt>mb</tt> is an <i>m</i> <tt>x</tt> <i>n</i>
matrix;

<li>double, when <tt>ma</tt> and <tt>mb</tt> are scalar.
</ul>

<dt><i>See also</i>

<dd><tt><a href="#imod">imod</a></tt>

<dt><a href="oxstdexamples.html#fmod"><i>Example</i></a>
</dl>


<a name="fopen"></a><h2>fopen</h2>

<pre>fopen(const filename);
fopen(const filename, const smode);
</pre>

<dl><dd>
<dl>
<dt><tt>filename</tt>

<dd>in: name of file to open

<dt><tt>smode</tt>

<dd>in: text with open mode
</dl>

<dt><i>Return value</i>

<dd>Returns the opened file if successful, otherwise the value 0.
Use <tt><a href="#isfile">isfile</a></tt> to test if <tt>fopen</tt> was successful.

<dt><i>Description</i>

<dd>Opens a file. The first form, without the <tt>smode</tt> argument
opens a file for <i>reading</i> (equivalent to using <tt>"r"</tt>).
The <tt>smode</tt> argument can be:

<ul>
<li><tt>"w" </tt>open for writing (the default when omitting this argument);

<li><tt>"a" </tt>open for appending;

<li><tt>"r" </tt>open for reading;

<li><tt>"r+" </tt>open for reading and writing (update);

<li><tt>"l" </tt>open a log file for writing (use <tt>"la" </tt> to append).
</ul>

<p>
In addition, the following letters can be used in the <tt>smode</tt>
argument:
<dl>
<dt>b
<dd>
Opens the file in binary mode (Windows only).
Binary leaves a \r\n as \r\n,
whereas non-binary translates \n to \r\n on input (and vice versa on output).
On Windows systems, it is customary to open text files without
the b, and binary files (when using fread and fwrite) with the b.

<dt>F
<dd>
Use for a v96 <tt>.fmt</tt> file, which stores a matrix. Reading and writing can
then be done by blocks of rows. When writing, the file must be explicitly
closed with <tt><a href="#fclose">fclose</a></tt>.
<p>Also used for a v96 <tt>.dat</tt> file, which stores variable names and
binary data. When writing, the first <tt>fwrite</tt> should be
an array of strings, which also determines the number of variables.
When reading, use <tt>fread(file, &amp;as, 's')</tt> to read the variable
names; this sets the file pointer to the first row.

<dt>f
<dd>
Same as <tt>'F'</tt>, but only for extended v89 <tt>.fmt</tt> files.

<dt>e
<dd>
Forces the file reading and writing (using fread and fwrite) to be
in little-endian mode. This allows Ox on
Unix (not Linux on Intel) to handle files which use the MS-DOS byte
ordering (which is little-endian).

<dt>E
<dd>
Forces the file reading and writing (using fread and fwrite) to be
in big-endian mode. This allows Ox on
Windows/MS-DOS to handle files which use the Unix (not Linux on Intel)  byte
ordering (which is big-endian).

<dt>v
<dd>
Print a message if opening the file failed.

<dt>V
<dd>
Print a message if opening the file failed, then generate a run-time error.

</dl>
<p>
When using "r+", it is necessary to use <tt>fseek</tt> or <tt>fflush</tt>
when switching from reading to writing.
<p>
To send the output from all <tt>print</tt> and <tt>println</tt>
statements to a file (in addition to the screen), use
<tt>fopen(</tt><i>filename</i><tt>, "l")</tt>.
<p>
Finally, it is possible to read from a zip file, by specifying the archive name,
followed by two slashes, followed by the name in the archive. For example
<xmp>    file = fopen("mydata/data.zip//data/data.in7");
</xmp>
Opens the file <tt>data/data.in7</tt> in the zip archive <tt>mydata/data.zip</tt>. Ox will
search for <tt>data.zip</tt> in the standard way.
It is not possible to write to a zip file.


<dt><i>See also</i>

<dd><tt><a href="#fclose">fclose</a></tt>, <tt><a href="#fflush">fflush</a></tt>, <tt><a href="#fprint">fprint</a></tt>, <tt><a href="#fread">fread</a></tt>,
<tt><a href="#fscan">fscan</a></tt>, <tt><a href="#fseek">fseek</a></tt>, <tt><a href="#fwrite">fwrite</a></tt>, <tt><a href="#isfile">isfile</a></tt>

<dt><a href="oxstdexamples.html#fprint"><i>Example</i></a>
</dl>


<a name="format"></a><h2>format</h2>

<pre>format(const sfmt);
</pre>

<dl><dd>
<dl>
<dt><tt>sfmt</tt>

<dd>in: string: new default format for double or int

<dd>int: new line length for matrix printing
</dl>

<dt><i>No return value</i>.

<dt><i>Description</i>

<dd>Use this function to specify the default format for double and int
types. The function automatically recognizes whether the format string
is for int or double (otherwise it is ignored). The specified double format
will also be used for printing matrices. See under the <tt><a href="#print">print</a></tt> function
for a complete description of the formatting strings. Use an integer argument
to set the line length for matrix printing (default is 80, the maximum
is 1024). The default format strings are:

<ul>
<li>int: <tt>"%d"</tt>

<li>double: <tt>"%g"</tt>

<li>matrix: each element <tt>"%#13.5g"</tt>, 6 elements on a
line (depending on the line length). This format will always leave at least
one space between numbers.
</ul>

<dt><i>See also</i>

<dd><tt><a href="#fprint">fprint</a></tt>, <tt><a href="#print">print</a></tt>, <tt><a href="#sprint">sprint</a></tt>
</dl>



<a name="fprint"></a>
<a name="fprintln"></a>
<h2>fprint,fprintln</h2>

<pre>fprint(const file, const a, ...);
fprintln(const file, const a, ...);
</pre>

<dl><dd>
<dl>
<dt><tt>file</tt>

<dd>in: file which is open for writing

<dt><tt>a</tt>

<dd>in: any type

<dt><tt>...</tt>

<dd>in: any type
</dl>

<dt><i>Return value</i>

<dd>Returns the number of arguments supplied to the function. Prints to
the specified file, see <tt><a href="#print">print</a></tt> for a further description.
<tt>fprintln</tt> is as <tt>fprint</tt> but ensures the next output
will be on a new line.

<dt><a href="oxstdexamples.html#fprint"><i>Example</i></a>
</dl>


<a name="fread"></a><h2>fread</h2>

<pre>fread(const file, const am);
fread(const file, const am, const type);
fread(const file, const am, const type, const r);
fread(const file, const am, const type, const r,const c);
</pre>

<dl><dd>
<dl>
<dt><tt>file</tt>

<dd>in: file which is open for writing

<dt><tt>am</tt>

<dd>in: address, address for storing read item

<dt><tt>type</tt>

<dd>in: (optional argument), type of object to read, see below

<dt><tt>r</tt>

<dd>in: (optional argument), number of rows to read; default is 1 if argument
is omitted

<dt><tt>c</tt>

<dd>in: (optional argument), number of columns to read; default is 1 if
argument is omitted, unless file is opened with f, in which case the number
of columns is read from the file
</dl>

<dt><i>Return value</i>

<dd>
Returns an integer:
<dl>
<dt>-1 nothing read, because end-of-file was reached;
<dt>0 nothing read, unknown error;
<dt>&gt;0 object read, return value is size which was actually read:
<dd>
<ul>
<li>type: 'i', 'd', reads: integer, returns: 1;

<li>type: 'e', 'f', reads: double, returns: 1 (<i>r</i> and <i>c</i> omitted,
or both equal to 1);

<li>type: 'e', 'f', reads: matrix, returns: <i>r</i> <tt>x</tt> <i>c</i>;


<li>type: 'e', 'f', reads: matrix, returns: <i>r</i> (number of complete rows read;
file opened with f in format);

<li>type: 'c', reads: integer, returns: 1 (<i>r</i>=1: just one byte read);


<li>type: 'c', reads: string, returns: <i>r</i> (<i>r</i>&gt;1: <i>r</i>
bytes read).

<li>type: 's', reads: string, returns string length; unlike 'c' this ignores
the <tt>r</tt> argument and reads up to (and including) the first null character or the end
of file.

<li>type: '4', reads: float, returns: 1 (<i>r</i> and <i>c</i> omitted,
or both equal to 1);

<li>type: '4', reads: matrix of floats, returns: <i>r</i> <tt>x</tt> <i>c</i>;

</ul>
</dl>
<p>
When reading a matrix, for example as <tt>fread(file,&amp;x,'f',r,c)</tt>,
the size of <tt>x</tt> will always be <tt>r</tt> by <tt>c</tt>. If less than
<tt>rc</tt> elements could be read, the matrix is padded with zeros.
If no elements could be read at all, because the end of the
file was reached, the return value is -1.
<p>
The <tt>'4'</tt> format reads 4-byte real values (`float'), these
are not written by Ox, but may be needed to read externally
created files.
<p>
The <tt>'s'</tt> type reads a string up to (and including) the first null
character or the end of file.

<dt><i>Description</i>

<dd>Reads binary data from the specified file. The byte ordering is the
platform specific ordering, unless the f format was used (also see <tt><a href="#fopen">fopen</a></tt>
and <tt><a href="#fwrite">fwrite</a></tt>).

<dt><i>See also</i>

<dd><tt><a href="#fclose">fclose</a></tt>, <tt><a href="#fopen">fopen</a></tt>,
<tt><a href="#fscan">fscan</a></tt>, <tt><a href="#fseek">fseek</a></tt>,
<tt><a href="#fwrite">fwrite</a></tt>

<dt><a href="oxstdexamples.html#fread"><i>Example</i></a>
</dl>


<a name="fremove"></a><h2>fremove</h2>

<pre>fremove(const filename);
</pre>

<dl><dd>
<dl>
<dt><tt>filename</tt>

<dd>in: name of file to remove
</dl>

<dt><i>Return value</i>

<dd>Returns 1 if the file was removed successfully, 0 otherwise.
</dl>


<a name="fscan"></a><h2>fscan</h2>

<pre>fscan(const file, const a, ...);
</pre>

<dl><dd>
<dl>
<dt><tt>file</tt>

<dd>in: file which is open for writing

<dt><tt>a</tt>

<dd>in: any type

<dt><tt>...</tt>

<dd>in: any type
</dl>

<dt><i>Return value</i>

<dd>Returns the number of arguments successfully scanned and assigned,
or -1 when the end of the file was encountered and nothing was read.

<dt><i>Description</i>

<dd>Reads text from a file. The arguments are a list of scanning strings
and the addresses of variables. A scanning string consists of text, optionally
with a format specifier which starts with a % symbol. The string is truncated
after the format. Any text which precedes the format, is skipped in the
file. A space character will skip any white space in the file. If the scanning
string holds a format (and assignment is not suppressed in the format),
the string must be followed by the address of a variable. The format specification
is similar to that for the scanf function of the C language:

<p>%[<tt>*</tt> or <tt>#</tt>][<i>width</i>]<i>type</i>

<p>The <i>width</i> argument specifies the width of the input field. A
<tt>*</tt> suppresses assignment. A <tt>#</tt> can only be used with <tt>m</tt>
and <tt>M</tt>. 
<hr>

<h3><a name="TabStd1"></a>Table std.1: Formatting types for scanning</h3>
<pre>double type:
e,f,g       field is scanned as a double value,
le,lf,lg    field is scanned as a double value,
C           field is scanned as a calendar double value

integer type:
d           signed decimal notation,
i           signed decimal notation,
o           unsigned octal notation,
x           unsigned hexadecimal notation,
u           unsigned decimal notation,
c           (no width) scan a single character (i.e. one byte),

string type:
s           scan a string up to the next white space,
z           scan a whole line,
c           (width &gt; 1) scan a number of characters,

matrix type:
m,M         scan a matrix row by row,

token type:
t           scan a token, returning the value,
T           scan a token, returning a triplet.

any type:
v		    scan an Ox constant.
</pre>
<hr>
<p>
Notes:
<ul>
<li>The <tt>"%m"</tt> and <tt>"%M"</tt> formats can be used to
read a matrix from a file. They first read
the number of rows and columns,
and then the matrix row by row; this corresponds
to the format used by <tt><a href="#loadmat">loadmat</a></tt>.

No dimensions are read by <tt>"%#m"</tt> and <tt>"%#M"</tt>,
in that case the scanning string has to be followed by two
integers indicating the number of rows and columns to be read.
For <tt>fscan</tt> the two integers can be -1. In that case
all numbers are read and returned as a column vector.

<li>The <tt>"%z"</tt> format reads a whole line up to <tt>\n</tt>,
the <tt>\n</tt> (and <tt>\r</tt>) are removed from the return value.
The line can be up to 2048 characters long (or whatever buffer size
is set with <tt><a href="#sprintbuffer">sprintbuffer</a></tt>). If the line in the file is too long,
the remainder is skipped.

When scanning a string,
the maximum string length which can be read is 2048.
The <tt><a href="#sprintbuffer">sprintbuffer</a></tt> function can be used to enlarge
the buffer size.

<li>The <tt>"%t"</tt> and <tt>"%T"</tt> formats can be used to
read a token, using a simplified syntax that is similar to Ox code.
Five types of tokens are distinguished:
<dl>
<dt><tt>SCAN_EOF		</tt>
<dd>End of the file or text.
<dt><tt>SCAN_IDENTIFIER	</tt>
<dd>An identifier.
<dt><tt>SCAN_LITERAL	</tt>
<dd>A literal integer, double or string.
<dt><tt>SCAN_SYMBOL		</tt>
<dd>A symbol.
<dt><tt>SCAN_SPACE		</tt>
<dd>White space.
</dl>
The <tt>"%t"</tt> version returns the value that was read, while
<tt>"%T"</tt> returns an array with three elements: the value,
the actual text that was read and the token type (<tt>SCAN_</tt>...).
<p>
Note that a negative number is read as two tokens: a minus symbol and the
value. Space is returned as a token. To skip leading spaces use
<tt>" %t"</tt> and <tt>" %T"</tt>. Note that <tt>fscan</tt> may reach the
end (i.e. return -1) before it gets to process the token, so the return value
of <tt>fscan</tt> should be taken into account.

<p>
The token format can be useful when a simple parser is required, or
to read strings that are not delimited by white space.
An example using <tt><a href="#sscan">sscan</a></tt> is given below.

<li>The <tt>"%C"</tt> format is used to scan a date/time field written
in ISO format: <i>yyyy-mm-dd</i>, <i>hh:mm::ss.hh</i>, or <i>yyyy-mm-ddThh:mm::ss.hh</i>.
Examples are <tt>1999-03-31</tt>, <tt>13:10</tt> (a 24-hour clock is used, seconds
and hundreds are optional) and <tt>1999-3-31T13:10</tt>.

Years with week number are also recognised, e.g. <tt>1976-W3</tt> returns
the calendar index for the Monday of week 3 in 1976.
(Week 1 is the first week that contains the first Thursday; or equivalently,
the week that contains 4 January.)

<li> The <tt>"%v"</tt> format reads a variable that has been
written in the format of an Ox constant. 
It is especially useful to read a variable
that consist of a derived types, such as an array or a
class object, but also for a matrix. When scanning a class object,
the variable must already have the type of that class (using <tt>new</tt>),
because the scan functions cannot create the object themselves.
An example is given in <tt>ox/samples/inout/percent_v.ox</tt>
and under the <tt><a href="#print">print</a></tt> function.
</ul>

<dt><i>See also</i>

<dd><tt><a href="#fprint">fprint</a></tt>, <tt><a href="#fread">fread</a></tt>,
<tt><a href="#print">print</a></tt>, <tt><a href="#scan">scan</a></tt>, <tt><a href="#sscan">sscan</a></tt>

<dt><a href="oxstdexamples.html#fscan"><i>Example</i></a>
</dl>


<a name="fseek"></a><h2>fseek</h2>

<pre>fseek(const file);
fseek(const file, const type);
fseek(const file, const type, const r);
</pre>

<dl><dd>
<dl>
<dt><tt>file</tt>

<dd>in: file which is open for writing

<dt><tt>type</tt>

<dd>in: (optional argument), type of object use in seeking, see below

<dt><tt>r</tt>

<dd>in: (optional argument), number of rows to move; default is 1 if argument
is omitted
</dl>

<dt><i>Return value</i>

<dd>The first form, with only the <tt>file</tt> argument, tells the current
position in the file as an offset from that start of the file (as the standard
C function <tt>ftell</tt>). The return vale is an integer,
except in 64-bit Ox when the file is larger than 2GB: in that case it is a double.

<p>
The second and third form return 0 if the seek
was successful, else a non-zero number,

<dt><i>Description</i>

<dd>Repositions the file pointer to a new position specified
from the start of a file. The <tt>type</tt> argument is interpreted
as follows:

<ul>
<li>type: 'i', 'd', seeks: integer, byte equivalent: 4<i>r</i>;

<li>type: 'e', 'f', seeks: double, byte equivalent: 8<i>r</i>;

<li>type: 'e', 'f', seeks: matrix rows, byte equivalent: 16+8<i>rc</i>
(file opened with f in format);

<li>type: 'c', seeks: character, byte equivalent: <i>r</i>.
</ul>

<p>So when a file is opened as <tt>"rbf"</tt>, <tt>fseek(file,
'f', r)</tt> moves the file pointer to row <tt>r</tt> in the <tt>.fmt</tt>
file.
<p>
To position the file pointer at the end specify -1 for the third
argument. This can be used to determine the length of a file.

<dt><i>See also</i>

<dd><tt><a href="#fclose">fclose</a></tt>, <tt><a href="#fopen">fopen</a></tt>

<dt><a href="oxstdexamples.html#fseek"><i>Example</i></a>
</dl>



<a name="fsize"></a>
<a name="ftime"></a>
<h2>fsize,ftime</h2>

<pre>fsize(const file);
ftime(const file);
</pre>

<dl><dd>
<dl>
<dt><tt>file</tt>

<dd>in: an open file
</dl>

<dt><i>Return value</i>

<dd><tt>fsize</tt> returns the size of the file in bytes (an integer, or a double if the file
is larger than 2GB).
<p>
<tt>ftime</tt> returns the modification date and time of the file (a double).

</dl>



<a name="fwrite"></a><h2>fwrite</h2>

<pre>fwrite(const file, const a);
</pre>

<dl><dd>
<dl>
<dt><tt>file</tt>

<dd>in: file which is open for writing

<dt><tt>a</tt>

<dd>in: int, double, matrix or string
</dl>

<dt><i>Return value</i>

<dd>Returns 0 if failed to write, or the number of items written to the
file:

<ul>
<li>integer: 1;

<li>double: 1;

<li><i>m</i> <tt>x</tt> <i>n</i> matrix: number of elements
written (normally <i>m</i> <tt>x</tt> <i>n</i>);

<li><i>m</i> <tt>x</tt> <i>n</i> matrix: opened with f
format: no of rows written (normally <i>m</i>);

<li>string: number of characters written.
</ul>

<dt><i>Description</i>

<dd>Writes binary data to the specified file. The byte ordering is the
platform specific ordering, unless the f format was used (also see <tt><a href="#fopen">fopen</a></tt>),
in which case writing is to a <tt>.fmt</tt> file in little endian mode (also see
<tt><a href="#savemat">savemat</a></tt>). When data is written to a <tt>.fmt</tt> file, the number of columns
must match that already in the file (use <tt>columns(file)</tt> to ask
for the number of columns in the file).

<dt><i>See also</i>

<dd><tt><a href="#fclose">fclose</a></tt>, <tt><a href="#fopen">fopen</a></tt>, <tt><a href="#fread">fread</a></tt>, <tt><a href="#fseek">fseek</a></tt>

<dt><a href="oxstdexamples.html#fwrite"><i>Example</i></a>
</dl>


<a name="fuzziness"></a><h2>fuzziness</h2>

<pre>fuzziness(const deps);
</pre>

<dl><dd>
<dl>
<dt><tt>deps</tt>

<dd>in: double, 0 or new fuzziness value
</dl>

<dt><i>Return value</i>

<dd>Sets and returns the new fuzziness parameter if <tt>deps</tt> &gt;0.
If <tt>deps</tt> &lt;= 0, no new fuzziness value is set, but the current
one is returned. The default fuzziness is 1e-13.

<dt><i>See also</i>

<dd><tt><a href="#isfeq">isfeq</a></tt>
</dl>


<a name="gammafact"></a><h2>gammafact</h2>

<pre>gammafact(const ma);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>

<dd>in: arithmetic type
</dl>

<dt><i>Return value</i>

<dd>Returns the complete gamma function at the value
of each element of <tt>ma</tt>, of double or matrix type. Returns +.Inf
for any argument which is zero or a negative integer.
Note that gammafact(n+1) equals n!.

<dt><i>See also</i>

<dd><tt><a href="#factorial">factorial</a></tt>,
<tt><a href="#gammafunc">gammafunc</a></tt>,
<tt><a href="#loggamma">loggamma</a></tt>,
<tt><a href="#polygamma">polygamma</a></tt>
</dl>




<a name="gammafunc"></a><h2>gammafunc</h2>

<pre>gammafunc(const dx, const dr);
</pre>

<dl><dd>
<dl>
<dt><tt>mx</tt>

<dd>in: <i>x</i>, arithmetic type

<dt><tt>mr</tt>

<dd>in: <i>r</i>, arithmetic type
</dl>

<dt><i>Return value</i>

<dd>Returns the incomplete gamma function <i>G<sub>x</sub></i>(<i>r</i>).
Returns 0 if <i>r</i> &lt;= 0 or <i>x</i> &lt;= 0. The accuracy is to about
10 digits.

The return type is derived as follows:

<ul>
<li><i>m</i> <tt>x</tt> <i>n</i> matrix, when <tt>mx</tt> is an <i>m</i>
<tt>x</tt> <i>n</i> matrix, and <tt>mr</tt> is scalar;

<li><i>m</i> <tt>x</tt> <i>n</i> matrix, when <tt>mx</tt> is a scalar,
and <tt>mr</tt> is an <i>m</i> <tt>x</tt> <i>n</i> matrix;

<li><i>m</i> <tt>x</tt> <i>n</i> matrix, when <tt>mx</tt> is an <i>m</i>
<tt>x</tt> <i>n</i> matrix, and <tt>mr</tt> is an <i>m</i> <tt>x</tt> <i>n</i>
matrix;

<li>double, when <tt>mx</tt> and <tt>mx</tt> are scalar.
</ul>

<dt><a href="oxstdexamples.html#gammafunc"><i>Example</i></a>
</dl>


<a name="getcwd"></a><h2>getcwd</h2>

<pre>getcwd();
</pre>

<dl><dd>
<dt><i>Return value</i>

<dd>Returns the current directory.
<p>
<i>Windows specific</i>: returns the current directory
on the current drive. Use <i>chdir</i> to change the current drive.

<dt><i>See also</i>

<dd><tt><a href="#chdir">chdir</a></tt>, <tt><a href="#getfiles">getfiles</a></tt>,
<tt><a href="#systemcall">systemcall</a></tt>

<dt><a href="oxstdexamples.html#getfiles"><i>Example</i></a>
</dl>


<a name="getenv"></a><h2>getenv</h2>

<pre>getenv(const senv);
</pre>

<dl><dd>
<dl>
<dt><tt>senv</tt>

<dd>in: string
</dl>

<dt><i>Return value</i>

<dd>Returns a string with the value of the environment variable, or an empty
string if the environment variable is undefined.

<dt><i>See also</i>

<dd><tt><a href="#systemcall">systemcall</a></tt>
</dl>


<a name="getfiles"></a>
<a name="getfolders"></a>
<h2>getfiles,getfolders</h2>

<pre>getfiles(const sfilemask);
getfolders(const sfilemask);
</pre>

<dl><dd>
<dl>
<dt><tt>sfilemask</tt>

<dd>in: string, mask for files, may have a path or wild cards
</dl>

<dt><i>Return value</i>

<dd><tt>getfiles</tt> returns an array of strings with file names matching the specified mask.
<br>
<tt>getfolders</tt> returns an array of strings with folder names matching the specified mask.

<dt><i>See also</i>

<dd><tt><a href="#chdir">chdir</a></tt>, <tt><a href="#getcwd">getcwd</a></tt>

<dt><a href="oxstdexamples.html#getfiles"><i>Example</i></a>
</dl>



<a name="hyper_2F1"></a><h2>hyper_2F1</h2>

<pre>hyper_2F1(const a, const b, const c, const z);
</pre>

<dl><dd>
<dl>
<dt><tt>a</tt>, <tt>b</tt>, <tt>c</tt>

<dd>in: arithmetic type, parameters of <sub>2</sub><i>F</i><sub>1</sub>

<dt><tt>z</tt>

<dd>in: arithmetic type, argument of <sub>2</sub><i>F</i><sub>1</sub>
</dl>

<dt><i>Return value</i>

<dd>Returns the value of the Gauss Hypergeometric
function <sub>2</sub><i>F</i><sub>1</sub> with real parameters <i>a</i>, <i>b</i>, <i>c</i> and real argument <i>z</i>.
</dl>



<a name="idiv"></a>
<a name="imod"></a>
<h2>idiv,imod</h2>

<pre>idiv(const ia, const ib);
imod(const ia, const ib);
</pre>

<dl><dd>
<dl>
<dt><tt>ia</tt>

<dd>in: arithmetic type

<dt><tt>ib</tt>

<dd>in: arithmetic type
</dl>

<dt><i>Return value</i>

<dd>The <tt>imod</tt> function returns the integer remainder of <tt>int(ia)</tt>
/ <tt>int(ib)</tt>. The sign of the result is that of <tt>ia</tt>.
The <tt>idiv</tt> function returns the result of the
integer division <tt>int(ia)</tt> / <tt>int(ib)</tt>.

The return type is a matrix of integer values if either
arguments is a matrix, else it is a scalar int.

<dt><i>See also</i>

<dd><tt><a href="#fmod">fmod</a></tt>

<dt><a href="oxstdexamples.html#idiv"><i>Example</i></a>
</dl>



<a name="insertc"></a>
<a name="insertr"></a>
<h2>insertc,insertr</h2>

<pre>
insertc(const ma, const c, const cadd);
insertr(const ma, const r, const radd);
insertr(const aa, const r, const radd);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>   <dd> in: <i>m</i> <tt>x</tt> <i>n</i> matrix to insert into
<dt><tt>aa</tt>   <dd> in: <i>m</i> array to insert into
<dt><tt>c</tt> <dd> in: scalar, column index of insertion
<dt><tt>cadd</tt> <dd> in:  scalar, number of columns of zeros to add
<dt><tt>r</tt> <dd> in: scalar, row index of insertion
<dt><tt>radd</tt> <dd> in:  scalar, number of rows of zeros to add
</dl>

<dt><i>Return value</i>
<dd>The <tt>insertc</tt> function with returns a copy of the input matrix
with the specified columns of zeros inserted.

<dd>The <tt>insertr</tt> function with returns a copy of the input matrix
with the specified rows of zeros inserted; <tt>insertr</tt> also works for arrays.

<dt><i>See also</i>
<dd>
<tt><a href="#dropc">dropc</a></tt>,
<tt><a href="#dropr">dropr</a></tt>

<dt><a href="oxstdexamples.html#dropc"><i>Example</i></a>
</dl>



<a name="int"></a><h2>int</h2>

<pre>int(const ma);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>

<dd>in: arithmetic type
</dl>

<dt><i>Return value</i>

<dd>Casts the argument to an integer:

<ul>
<li>integer: unchanged;

<li>double: rounded towards zero;

<li>matrix: element 0,0 rounded towards zero;

<li>string: element 0;

<li>other types: error.
</ul>

<dt><i>See also</i>

<dd><tt><a href="#ceil">ceil</a></tt>, <tt><a href="#double">double</a></tt> , <tt><a href="#matrix">matrix</a></tt> , <tt><a href="#trunc">trunc</a></tt>,
<a href="oxsyntax.html#ox_syntax_RefCast">explicit type conversion</a>

<dt><a href="oxstdexamples.html#ceil"><i>Example</i></a>
</dl>



<a name="intersection"></a><h2>intersection</h2>

<pre>intersection(const ma, const mb);
intersection(const ma, const mb, const amidx);
</pre>

<dl><dd>
<dl>
<dt><tt>ma, mb</tt>

<dd>in: matrix
<dt><tt>amidx</tt>

<dd>in: address of variable
<dd>out: 2 <tt>x</tt> c	matrix, first row is the index of the common elements
in <tt>vecr(ma)</tt>, the second row is the index in <tt>vecr(mb)</tt>.	The order of the
indices correspond to the order of the return value.
</dl>

<dt><i>Return value</i>

<dd>Returns the sorted unique elements of <tt>ma</tt>
which are also in <tt>mb</tt> as a 1 <tt>x</tt> <i>c</i> vector,
where <i>c</i> is the number of elements <tt>ma</tt> and <tt>mb</tt>
have in common.
Returns an empty matrix if the result is empty.
Missing values are skipped.

<dt><i>See also</i>

<dd><tt><a href="#exclusion">exclusion</a></tt>,
<tt><a href="#union">union</a></tt>,
<tt><a href="#unique">unique</a></tt>

<dt><a href="oxstdexamples.html#exclusion"><i>Example</i></a>
</dl>



<a name="invert"></a><h2>invert</h2>

<pre>invert(const ma);
invert(const ma, const alogdet, const asign);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>

<dd>in: <i>m</i> <tt>x</tt> <i>m</i> real matrix <i>A</i>

<dt><tt>alogdet</tt>

<dd>in: (optional argument) address of variable

<dd>out: double, the <i>logarithm</i> of the absolute value of the determinant
of <i>A</i>

<dt><tt>asign</tt>

<dd>in: (optional argument) address of variable

<dd>&gt;out: int , the sign of the determinant of <i>A</i>; 0: singular;
-1,-2: negative determinant; +1,+2: positive determinant; -2,+2: result
is unreliable
</dl>

<dt><i>Return value</i>

<dd>Returns the inverse of <i>A</i>, or the value 0 if the decomposition
failed.

<dt><i>See also</i>

<dd><tt><a href="#decldl">decldl</a></tt>,
<tt><a href="#invertgen">invertgen</a></tt>, <tt><a href="#invertsym">invertsym</a></tt>
<tt><a href="#logdet">logdet</a></tt>

<dt><a href="oxstdexamples.html#invert"><i>Example</i></a>
</dl>



<a name="inverteps"></a><h2>inverteps</h2>

<pre>inverteps(const dEps);
</pre>

<dl><dd>
<dl>
<dt><tt>dEps</tt>

<dd>in: sets the inversion epsilon <i>eps<sub>inv</sub></i> to <tt>dEps</tt>
if <tt>dEps</tt> &gt; 0, to the default if <tt>dEps</tt> &lt; 0; leaves
the value unchanged if <tt>dEps</tt> == 0
</dl>

<dt><i>Return value</i>

<dd>Returns the inversion epsilon (the new value if <tt>dEps != 0</tt>).

</dl>



<a name="invertgen"></a><h2>invertgen</h2>

<pre>invertgen(const ma);
invertgen(const ma, const mode);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>

<dd>in: <i>m</i> <tt>x</tt> <i>n</i> real matrix <i>A</i>

<dt><tt>mode</tt>

<dd>in: inversion mode (optional argument, default is 0)
</dl>

<dt><i>Return value</i>

<dd>Returns the (generalized) inverse of <i>A</i>, or the value 0
if the decomposition failed:
<pre>
mode     description                                     A 
0        generalized inverse using SVD               
1        generalized symmetric p.s.d inverse using SVD   m=n
2,20     first try invert then mode 0                    m=n
3,30     first try invertsym then mode 1                 m=n
4,40     use olsc (QR dec.) for inverse of A'A           m>=n
>=10     print warning if matrix is singular
</pre>

<dt><i>Description</i>

<dd>
<ul>
<li> 0. When <tt>mode</tt> equals 0, or the mode argument is omitted,
<tt>invertgen</tt> defaults to the generalized inverse
when only one argument is used.

<li> 1. When <tt>mode</tt> equals 1, the matrix must be symmetric positive semi-definite.
<i>Do not use this mode for negative definite matrices.</i>

<li> 2. Mode 2 first tries the normal inversion routine (<tt>invert</tt>), and then,
if the matrix is singular, uses the generalized inverse.
This mode is the same as using <tt>1 / x</tt>.

<li> 3. Mode 3 first tries the normal inversion routine (<tt>invertsym</tt>), and then,
if the matrix is singular, uses the generalized inverse (as mode 1).
<i>Do not use this mode for negative definite matrices.</i>

<li> 4. Mode 4 uses the QR decomposition, and the inverse is the same
as obtained from using <tt>olsc</tt>. This is a different type of
generalized inverse, so that, when the matrix is singular
a different value is obtained then from the other modes.
</ul>

If the matrix is full rank, the generalized inverse equals the
normal inverse (for modes 1,3 this also requires symmetry and positive definiteness).

When the mode argument is multiplied by ten, a warning is printed
if the matrix is singular (or negative definite for mode 30),
but the return value is not affected.


<dt><i>See also</i>

<dd>
<tt><a href="#invert">invert</a></tt>, <tt><a href="#invertsym">invertsym</a></tt>

<dt><a href="oxstdexamples.html#invertgen"><i>Example</i></a>
</dl>




<a name="invertsym"></a><h2>invertsym</h2>

<pre>invertsym(const ma);
invertsym(const ma, const alogdet);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>

<dd>in: symmetric, positive definite <i>m</i> <tt>x</tt> <i>m</i> matrix
<i>A</i>

<dt><tt>alogdet</tt>

<dd>in: (optional argument) address of variable

<dd>out: double, the <i>logarithm</i> of the determinant of <i>A</i>.

</dl>

<dt><i>Return value</i>

<dd>Returns the inverse of <i>A</i>, or the value 0 if the decomposition
failed.

<dt><i>See also</i>

<dd><tt><a href="#declu">declu</a></tt>,
<tt><a href="#invert">invert</a></tt>, <tt><a href="#invertgen">invertgen</a></tt>

<dt><a href="oxstdexamples.html#invert"><i>Example</i></a>
</dl>





<a name="isarray"></a> 
<a name="isclass"></a> 
<a name="isdouble"></a>
<a name="isfile"></a>  
<a name="isfunction"></a>
<a name="isint"></a>   
<a name="ismatrix"></a>
<a name="ismember"></a>
<a name="isstring"></a>
<h2>isarray, isclass, isdouble, isfile, isfunction, isint, ismatrix, ismember, isstring</h2>

<pre>
isarray(const a);
isclass(const a);
isclass(const a, const sclass);
isdouble(const a);
isfile(const a);
isfunction(const a);
isint(const a);
ismatrix(const a);
ismember(const a, const smember);
isstring(const a);
</pre>

<dl><dd>
<dl>
<dt><tt>a</tt>

<dd>in: any type
<dt><tt>sclass</tt>

<dd>in: string, class name
<dt><tt>smember</tt>

<dd>in: string, member name
</dl>

<dt><i>Return value</i>

<dd>Returns TRUE (i.e. the value 1) if the argument is of the correct
type, FALSE (0) otherwise.

<p>
<tt>isclass(a, "class")</tt> returns TRUE if <tt>a</tt> is an object
of type <tt>"class"</tt>, or derived from <tt>"class"</tt>.

<p>
<tt>ismember</tt> returns 1 if <tt>a</tt> is an object
of a class and has a function member <tt>"smember"</tt>; 2 if <tt>"smember"</tt>
is a data member and 0 otherwise.

<dt><i>See also</i>

<dd><tt><a href="#classname">classname</a></tt>
</dl>



<a name="isdotfeq"></a>
<a name="iseq"></a>
<a name="isfeq"></a>
<h2>isdotfeq,iseq,isfeq</h2>

<pre>isdotfeq(const ma, const mb);
iseq(const ma, const mb);
isfeq(const ma, const mb);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>

<dd>in: arithmetic type

<dt><tt>mb</tt>

<dd>in: arithmetic type
</dl>

<dt><i>Return value</i>

<dd><tt>isfeq</tt> always returns an integer: it returns 1 if the argument
<tt>ma</tt> is fuzzy equal to <tt>mb</tt>, 0 otherwise.
When strings are compared, the comparison is case insensitive.

<p><tt>iseq</tt> is as <tt>isfeq</tt>, but using fuzziness of zero.
When strings are compared, the comparison is case sensitive.

<p><tt>isdotfeq</tt>
returns a matrix if either argument is a matrix; the matrix consists of
0's and 1's: 1 if the comparison holds, 0 otherwise. If both arguments
are scalar, <tt>isdotfeq</tt> is equal to <tt>isfeq</tt>. In both cases
the current fuzziness value is used.

<dt><i>See also</i>

<dd><tt><a href="#fuzziness">fuzziness</a></tt>

<dt><a href="oxstdexamples.html#isdotfeq"><i>Example</i></a>
</dl>



<a name="isdotinf"></a><h2>isdotinf</h2>

<pre>isdotinf(const ma);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt> <dd> in:   arithmetic type
</dl>

<dt><i>Return value</i>
<dd><tt>isdotinf</tt> returns a matrix of the same dimensions if the input is a matrix;
the returned matrix consists of 0's and 1's: 1 if the element is +/- infinity,
0 otherwise. If the arguments is a double, <tt>isdotnan</tt> returns 1 if the double
is +/- infinity.

<dt><i>See also</i>
<dd>
<tt><a href="#isdotmissing">isdotmissing</a>, <a href="#isdotnan">isdotnan</a></tt>
</dl>



<a name="isdotmissing"></a>
<a name="isdotnan"></a>
<a name="ismissing"></a>
<a name="isnan"></a>
<h2>isdotmissing, isdotnan, ismissing, isnan</h2>

<pre>isdotmissing(const ma);
isdotnan(const ma);
ismissing(const ma);
isnan(const ma);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt> <dd> in:   arithmetic type
</dl>

<dt><i>Return value</i>
<dd><tt>isnan</tt> always returns an integer: it returns 1 if <i>any</i> element in
<tt>ma</tt> is a NaN (not a number), 0 otherwise.
NaN can be used to indicate a missing value.

<dd><tt>isdotnan</tt> returns a matrix of the same dimensions if the input is a matrix;
the returned matrix consists of 0's and 1's: 1 if the element is NaN, 0 otherwise.
If the arguments is a double, <tt>isdotnan</tt> returns 1 if the double is NaN.

<dd><tt>ismissing</tt> and <tt>isdotmissing</tt> are similar to
<tt>isnan</tt> and <tt>isdotnan</tt> respectively. However, in addition to
NaN, they also treat +/- infinity and undefined (<tt>.Null</tt>) as a missing value.


<dt><i>See also</i>
<dd>
<tt><a href="#deletec">deletec</a></tt>,
<tt><a href="#deleter">deleter</a></tt>,
<tt><a href="#selectc">selectc</a></tt>,
<tt><a href="#selectr">selectr</a></tt>

<dt><a href="oxstdexamples.html#isdotmissing"><i>Example</i></a>
</dl>




<a name="lag"></a>
<a name="lag0"></a>
<h2>lag,lag0</h2>

<pre>
lag(const ma);
lag(const ma, const ilag);
lag(const ma, const ilag, double dmisval);
lag0(const ma);
lag0(const ma, const ilag);
lag0(const ma, const ilag, double dmisval);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>

<dd>in: <i>T</i> <tt>x</tt> <i>n</i> matrix

<dt><tt>ilag</tt>

<dd>in: int, lag length, or matrix with lag lengths	(default is 1)

<dt><tt>dmisval</tt>

<dd>in: (optional argument) double, value to set missing observations to
(default is 0 for <tt>lag0</tt>, <tt>.NaN</tt> for <tt>lag</tt>)
</dl>

<dt><i>Return value</i>

<dd>The <tt>lag</tt> fuction returns the lags of the specified matrix, whereby missing values are
replaced by <tt>.NaN</tt>. The result has the same dimensions as <tt>ma</tt>.
The <tt>lag0</tt> function is the same, but using zero for the missing value.
<br>
If <tt>ilag</tt> is a matrix the return value corresponds to:
<tt>lag0(.,ilag[0])~lag0(.,ilag[1])~...</tt>


<dt><i>See also</i>

<dd><tt><a href="#diff0">diff0</a></tt>

<dt><a href="oxstdexamples.html#lag0"><i>Example</i></a>
</dl>


<a name="limits"></a><h2>limits</h2>

<pre>limits(const ma);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>

<dd>in: <i>m</i> <tt>x</tt> <i>n</i> matrix
</dl>

<dt><i>Return value</i>

<dd>Returns a 4 <tt>x</tt> <i>n</i> matrix:

<ul>
<li>1st row: minimum of each column of <tt>ma</tt>;

<li>2nd row: maximum of each column of <tt>ma</tt>;

<li>3rd row: row index of minimum (lowest index if more than one exists);


<li>4th row: row index of maximum (lowest index if more than one exists).

</ul>

<dt><i>See also</i>

<dd><tt><a href="#min">min</a></tt>, <tt><a href="#max">max</a></tt>

<dt><a href="oxstdexamples.html#limits"><i>Example</i></a>
</dl>


<a name="loadmat"></a><h2>loadmat</h2>

<pre>loadmat(const sname);
loadmat(const sname, const iFormat);
loadmat(const sname, const aasVarNames);
loadmat(const sname, const iFormat, const aasVarNames);
</pre>

<dl><dd>
<dl>
<dt><tt>sname</tt>

<dd>in: string containing an existing file name

<dt><tt>iFormat</tt>

<dd>in: (optional argument, <tt>.mat</tt> matrix file only)<br>
1: file has no matrix dimensions; then the matrix is returned as a column
vector, and <tt><a href="#reshape">reshape</a></tt> can be used to create a differently shaped
matrix.
<dd>in: (optional argument, <tt>.xlsx</tt>,<tt>.xls</tt> Excel files only)<br>
1: strings are loaded as values and dates translated to Ox dates,
as in OxMetrics or the database class.<br>
0 (the default): strings are treated as empty cells, unless a dot or starting with #N/A,
and dates are read using the Excel numbering instead of Ox. For a date after
1-March-1900: oxdate = exceldate + 2415019.

<dt><tt>aasVarNames</tt>

<dd>in: (optional argument, not for <tt>.mat</tt> matrix files) address of variable
<dd>out: array of strings, names of data columns
</dl>

<dt><i>Return value</i>

<dd>Returns the matrix which was read, or <tt>0</tt> if the operation
failed.

<dt><i>Description</i>

<dd>The type of file read depends on the extension of the file name:

<ul>
<li><tt>.mat</tt>: matrix file (text file), described below,

<li><tt>.dat</tt>: data file (text file) with load information,

<li><tt>.in7</tt>: PcGive 7 data file (with corresponding <tt>.bn7</tt> file),

<li><tt>.xlsx</tt>: Excel 2007 (or newer) workbook file (Office Open xml),

<li><tt>.xls</tt>: Excel worksheet or workbook file (binary file),

<li><tt>.csv</tt>: comma-separated spread sheet file (text file),

<li><tt>.dta</tt>: Stata data file (version 4--6 or 11),

<li><tt>.dht</tt>: Gauss data file (v89, with corresponding <tt>.dat</tt> file),

<li><tt>.fmt</tt>: Gauss matrix file (v89 and v96);

<li>any other: as <tt>:.mat</tt>: file.
A matrix file holds a matrix, preceded by two integers which specify the
number of rows and columns of the matrix.
</ul>

A matrix file holds a matrix, preceded by two integers which specify
the number of rows and columns of the matrix. It will
normally have the <tt>.mat</tt> extension.
White space and a comma between numbers is skipped. If a symbol is found
which is not a number, then the rest of the line will be skipped
(so, e.g. everything following ; or // is treated as
comments).
The exception to this is an isolated dot, the letters <tt>m</tt> and <tt>M</tt>
or the words <tt>.NaN</tt> and <tt>#N/A</tt>: these are interpreted as a
missing element with value NaN (Not a Number); <tt>.Inf</tt> is interpreted
as infinity.

<dt><i>See also</i>

<dd><tt>Database</tt> class, <tt><a href="#savemat">savemat</a></tt>, <tt><a href="#reshape">reshape</a></tt>

<dt><a href="oxstdexamples.html#loadmat"><i>Example</i></a>
</dl>


<a name="loadsheet"></a><h2>loadsheet</h2>

<pre>loadsheet(const sname);
loadsheet(const sname);
loadsheet(const sname, const iSheet);
loadsheet(const sname, const iSheet, const bConvertDates);
</pre>

<dl><dd>
<dl>
<dt><tt>sname</tt>

<dd>in: string containing an existing file name

<dt><tt>iSheet</tt>

<dd>in:(optional argument), int: sheet number (default is zero)

<dt><tt>bConvertDates</tt>

<dd>in:(optional argument), int: 1: convert dates to Ox; 0: keep dates (default is one) 
</dl>

<dt><i>Return value</i>

<dd>Returns a two-dimensional array with the elements of the spreadsheet. The elements
are <tt>.Null</tt> (blank in the sheet), double or string.
<br>
Returns an empty array if the file cannot be read.


<dt><i>Description</i>

<dd>The type of file read depends on the extension of the file name:

<ul>
<li><tt>.xlsx</tt>: Excel 2007 (or newer) workbook file (Office Open xml),

<li><tt>.csv</tt>: comma-separated spread sheet file (text file),

<li>any other: as <tt>.xlsx</tt> file.
</ul>


<dt><i>See also</i>

<dd><tt>Database</tt> class, <tt><a href="#loadmat">loadmat</a></tt>

<dt><a href="oxstdexamples.html#loadsheet"><i>Example</i></a>
</dl>



<a name="log"></a>
<a name="log10"></a>
<h2>log,log10</h2>

<pre>log(const ma);
log10(const ma);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>

<dd>in: arithmetic type
</dl>

<dt><i>Return value</i>

<dd>The <tt>log</tt> function returns the natural logarithm of each element
of <tt>ma</tt>, of double or matrix type.
<p>
The <tt>log10</tt> function returns
the logarithm (base 10) of each element of <tt>ma</tt>, of double or matrix
type.

<dt><i>See also</i>

<dd><tt><a href="#exp">exp</a></tt>

<dt><a href="oxstdexamples.html#log"><i>Example</i></a>
</dl>


<a name="logdet"></a><h2>logdet</h2>

<pre>logdet(const ma, const asign);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>

<dd>in: <i>m</i> <tt>x</tt> <i>m</i> real matrix <i>A</i>

<dt><tt>asign</tt>

<dd>in: address of variable

<dd>&gt;out: int, the sign of the determinant of <i>A</i>; 0: singular;
-1,-2: negative determinant; +1,+2: positive determinant; -2,+2: result
is unreliable
</dl>

<dt><i>Return value</i>

<dd>Returns a double: the <i>logarithm</i> of the absolute value of the
determinant of <i>A</i> (1.0 if the matrix is singular).

<dt><i>See also</i>

<dd><tt><a href="#determinant">determinant</a></tt>, <tt><a href="#invert">invert</a></tt>
</dl>


<a name="loggamma"></a><h2>loggamma</h2>

<pre>loggamma(const ma);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>

<dd>in: arithmetic type
</dl>

<dt><i>Return value</i>

<dd>Returns the logarithm of the complete gamma function at the value
of each element of <tt>ma</tt>, of double or matrix type. Returns +.Inf
for an argument equal to zero, and .NaN for arguments less than zero.
Note that exp(loggamma(n+1)) equals n!.

<dt><i>See also</i>

<dd><tt><a href="#gammafact">gammafact</a></tt>,
<tt><a href="#gammafunc">gammafunc</a></tt>, <tt><a href="#polygamma">polygamma</a></tt>

<dt><a href="oxstdexamples.html#loggamma"><i>Example</i></a>
</dl>


<a name="lower"></a><h2>lower</h2>

<pre>lower(const ma);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>

<dd>in: <i>m</i> <tt>x</tt> <i>n</i> matrix
</dl>

<dt><i>Return value</i>

<dd>
Returns the lower diagonal (including the diagonal), i.e.
returns a copy of the input matrix with strict upper-diagonal elements set to zero.

<dt><i>See also</i>

<dd><tt><a href="#setdiagonal">setdiagonal</a></tt>, <tt><a href="#setupper">setupper</a></tt>, <tt><a href="#setlower">setlower</a></tt>, <tt><a href="#upper">upper</a></tt>

<dt><a href="oxstdexamples.html#lower"><i>Example</i></a>
</dl>


<a name="matrix"></a><h2>matrix</h2>

<pre>matrix(const ma);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>

<dd>in: arithmetic type
</dl>

<dt><i>Return value</i>

<dd>Casts the argument to a matrix:

<ul>
<li>integer: a 1 <tt>x</tt> 1 matrix,

<li>double: a 1 <tt>x</tt> 1 matrix,

<li>matrix: unchanged,

<li>string: a 1 <tt>x</tt> 1 matrix,

<li>other types: error.
</ul>

<dt><i>See also</i>

<dd><tt><a href="#int">int</a></tt>, <tt><a href="#double">double</a></tt>,
<a href="oxsyntax.html#ox_syntax_RefCast">explicit type conversion</a>
</dl>


<a name="max"></a><h2>max</h2>

<pre>max(const a, ...);
</pre>

<dl><dd>
<dl>
<dt><tt>a</tt>

<dd>in: arithmetic type

<dt><tt>...</tt>

<dd>in: arithmetic type
</dl>

<dt><i>Return value</i>

<dd>Returns the maximum value in all the arguments, ignoring missing values.
The return type is
int if all arguments are of type int; otherwise the return type is double.


<dt><i>See also</i>

<dd><tt><a href="#limits">limits</a></tt>, <tt><a href="#maxc">maxc</a></tt>, <tt><a href="#min">min</a></tt>

<dt><a href="oxstdexamples.html#max"><i>Example</i></a>
</dl>



<a name="maxc"></a>
<a name="maxcindex"></a>
<a name="maxr"></a>
<p><h2>maxc,maxcindex,maxr</h2>

<pre>maxc(const ma);
maxcindex(const ma);
maxr(const ma);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>

<dd>in: <i>m</i> <tt>x</tt> <i>n</i> matrix <i>A</i>
</dl>

<dt><i>Return value</i>

<dd>
The <tt>maxc</tt> function returns a 1 <tt>x</tt> <i>n</i> matrix
holding the maximum of each column of <tt>ma</tt>.

<p>
The <tt>maxcindex</tt> function
returns a 1 <tt>x</tt> <i>n</i> matrix holding the
row index of the maximum of each column <tt>ma</tt>.

<p>
The <tt>maxr</tt> function returns a <i>m</i> <tt>x</tt> 1 matrix
holding the maximum of each row of <tt>ma</tt>.

<p>
Finds the maximum value in each column (row for <tt>maxr</tt>), ignoring missing values.
If no maximum is found (a column has all missing values), then
the maximum is <tt>.NaN</tt>, and the index -1.

<dt><i>See also</i>

<dd><tt><a href="#limits">limits</a></tt>, <tt><a href="#max">max</a></tt>, <tt><a href="#minc">minc</a></tt>, <tt><a href="#mincindex">mincindex</a></tt>

<dt><a href="oxstdexamples.html#maxc"><i>Example</i></a>
</dl>



<h2>
<a name="meanc"></a>meanc,
<a name="meanr"></a>meanr
</h2>

<pre>meanc(const ma);
meanr(const ma);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>

<dd>in: <i>T</i> <tt>x</tt> <i>n</i> matrix <i>A</i>
</dl>

<dt><i>Return value</i>

<dd>The <tt>meanc</tt> function returns a 1 <tt>x</tt> <i>n</i> matrix
holding the means of the columns of <tt>ma</tt>.

<p>
The <tt>meanr</tt> function
returns a <i>T</i> <tt>x</tt> 1 matrix holding the means of the rows of
 <tt>ma</tt>.

<dt><i>See also</i>

<dd><tt><a href="#sumc">sumc</a></tt>, <tt><a href="#sumr">sumr</a></tt>, <tt><a href="#varc">varc</a></tt>, <tt><a href="#variance">variance</a></tt>, <tt><a href="#varr">varr</a></tt>

<dt><a href="oxstdexamples.html#variance"><i>Example</i></a>
</dl>



<h2><a name="min"></a>min</h2>

<pre>min(const a, ...);
</pre>

<dl><dd>
<dl>
<dt><tt>a</tt>

<dd>in: arithmetic type

<dt><tt>...</tt>

<dd>in: arithmetic type
</dl>

<dt><i>Return value</i>

<dd>Returns the minimum value in all the arguments, ignoring missing values.
The return type is
int if all arguments are of type int; otherwise the return type is double.


<dt><i>See also</i>

<dd><tt><a href="#limits">limits</a></tt>, <tt><a href="#max">max</a></tt>,
<tt><a href="#minc">minc</a></tt>

<dt><a href="oxstdexamples.html#max"><i>Example</i></a>
</dl>


<h2>
<a name="minc"></a>minc,
<a name="mincindex"></a>mincindex,
<a name="minr"></a>minr
</h2>

<pre>minc(const ma);
mincindex(const ma);
minr(const ma);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>

<dd>in: <i>m</i> <tt>x</tt> <i>n</i> matrix <i>A</i>
</dl>

<dt><i>Return value</i>

<dd>
The <tt>minc</tt> function returns a 1 <tt>x</tt> <i>n</i> matrix
holding the minimum of each column of <tt>ma</tt>.

<p>
The <tt>mincindex</tt> function
returns a 1 <tt>x</tt> <i>n</i> matrix holding the
row index of the minimum of each column <tt>ma</tt>.

<p>
The <tt>minr</tt> function returns a <i>m</i> <tt>x</tt> 1 matrix
holding the minimum of each row of <tt>ma</tt>.

<p>
Finds the minimum value in each column (row for <tt>maxr</tt>), ignoring missing values.
If no minimum is found (a column has all missing values), then
the minimum is <tt>.NaN</tt>, and the index -1.

<dt><i>See also</i>

<dd><tt><a href="#limits">limits</a></tt>, <tt><a href="#maxc">maxc</a></tt>, <tt><a href="#maxcindex">maxcindex</a></tt>, <tt><a href="#min">min</a></tt>

<dt><a href="oxstdexamples.html#maxc"><i>Example</i></a>
</dl>


<p>

<a name="moments"></a><h2>moments</h2>

<pre>moments(const ma);
moments(const ma, const k);
moments(const ma, const k, const fratio);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>

<dd>in: <i>T</i> <tt>x</tt> <i>n</i> matrix <i>A</i>

<dt><tt>k</tt>

<dd>in: (optional argument) no of moments <i>k</i> (default is <i>k</i>=4)

<dt><tt>fratio</tt>

<dd>in: (optional argument) 0: no ratios (default is moment ratios)
</dl>

<dt><i>Return value</i>

<dd>Returns an (<i>k</i>+1) <tt>x</tt> <i>n</i> matrix holding in each column
for the corresponding column of <tt>ma</tt>:
<table>
<tr><td><i>row</i> </td><td> <i>holds</i> </td><td> <i>description</i></td></tr>
<tr><td>0 </td><td> <i>T</i>*   </td><td> effective sample size</td></tr>
<tr><td>1 </td><td> <i>m</i><sub>1</sub> </td><td> sample mean </td></tr>
<tr><td>2 </td><td> <i>m</i><sub>2</sub><sup>1/2</sup> </td><td> sample standard deviation </td></tr>
<tr><td>3 </td><td> <i>m</i><sub>3</sub>/<i>m</i><sub>2</sub><sup>3/2</sup></td><td> sample skewness </td></tr>
<tr><td>4 </td><td> <i>m</i><sub>4</sub>/<i>m</i><sub>2</sub><sup>2</sup> </td><td> sample kurtosis </td></tr>
<tr><td>.. </td><td>.. </td><td>.. </td></tr>
<tr><td>k </td><td> <i>m</i><sub>k</sub>/<i>m</i><sub>2</sub><sup>k/2</sup> </td><td> sample <i>k</i>th central moment ratio (i.e. in deviation from mean) </td></tr>
</table>

If <tt>fratio</tt> equals 0, the moments are not divided:
<table>
<tr><td><i>row</i> </td><td> <i>holds</i> </td><td> <i>description</i></td></tr>
<tr><td>0 </td><td> <i>T</i>*   </td><td> effective sample size</td></tr>
<tr><td>1 </td><td> <i>m</i><sub>1</sub> </td><td> sample mean </td></tr>
<tr><td>2 </td><td> <i>m</i><sub>2</sub> </td><td> sample variance </td></tr>
<tr><td>.. </td><td>.. </td><td>.. </td></tr>
<tr><td>k </td><td> <i>m</i><sub>k</sub> </td><td> sample <i>k</i>th central moment (i.e. in deviation from mean)</td></tr>
</table>

Computes the central moment ratios or central moments. Skips missing
values.

<dt><i>See also</i>

<dd><tt><a href="#meanc">meanc</a></tt>, <tt><a href="#meanr">meanr</a></tt>,
<tt><a href="#standardize">standardize</a></tt>, <tt><a href="#varc">varc</a></tt>, <tt><a href="#varr">varr</a></tt>

<dt><a href="oxstdexamples.html#moments"><i>Example</i></a>
</dl>


<h2><a name="nans"></a>nans</h2>

<pre>nans(const r, const c);
nans(const ma);
</pre>

<dl><dd>
<dl>
<dt><tt>r</tt>

<dd>in: int

<dt><tt>c</tt>

<dd>in: int

<dt><tt>ma</tt>

<dd>in: matrix
</dl>

<dt><i>Return value</i>

<dd><tt>nans(r,c)</tt> returns an <tt>r</tt> by <tt>c</tt> matrix filled with .NaN.

<dd><tt>nans(ma)</tt> returns a matrix of the same dimension as <tt>ma</tt>, filled with .NaN.

<dt><i>See also</i>

<dd><tt><a href="#constant">constant</a></tt>, <tt><a href="#ones">ones</a></tt>, <tt><a href="#unit">unit</a></tt>, <tt><a href="#zeros">zeros</a></tt>

<dt><a href="oxstdexamples.html#nans"><i>Example</i></a>
</dl>


<h2><a name="norm"></a>norm</h2>

<pre>norm(const ma);
norm(const ma, const itype);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>

<dd>in: arithmetic type

<dt><tt>itype</tt>

<dd>in: int, type of norm (default is 0 for infinity norm)
</dl>

<dt><i>Return value</i>

<dd>Returns the norm of a matrix (a scalar double).
<dt><i>Description</i>
<dd>
The type of norm depends
on the <tt>itype</tt> argument. When <i>A</i> is a matrix:

<ul>
<li>0:   infinity norm, maximum of absolute column sums,
<li>1:   maximum  absolute row sums,
<li>2:   largest singular value,
<li>'F': Frobenius norm: square root of sum of squared elements.
<li>-1:  minimum of absolute column sums,
</ul>

When <i>A</i> is a vector:

<ul>
<li>0:   infinity norm, maximum absolute value,
<li>1:   sum of absolute values,
<li>2:   square root of sum of squares,
<li><i>p</i>:   <i>p</i>-th root of sum of absolute elements raised to the power <i>p</i>.
<li>-1:  minimum absolute value,
</ul>
<tt>norm(x)</tt> corresponds to <tt>norm(x,0)</tt>.


<dt><i>See also</i>

<dd><tt><a href="#decsvd">decsvd</a></tt>,
<tt><a href="#rank">rank</a></tt>

<dt><a href="oxstdexamples.html#norm"><i>Example</i></a>
</dl>


<h2><a name="nullspace"></a>nullspace</h2>

<pre>nullspace(const ma);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>

<dd>in: <i>m</i> <tt>x</tt> <i>n</i> matrix <i>A</i>

</dl>

<dt><i>Return value</i>

<dd>Returns the null space of <tt>ma</tt>, or a conformant empty matrix if
<tt>ma</tt> is square and full rank, or 0 if the SVD fails.

<dt><i>See also</i>

<dd><tt><a href="#decsvd">decsvd</a></tt>, <tt><a href="#inverteps">inverteps</a></tt>

<dt><a href="oxstdexamples.html#nullspace"><i>Example</i></a>
</dl>



<h2>
<a name="ols2c"></a>ols2c,
<a name="ols2r"></a>ols2r,
<a name="olsc"></a>olsc,
<a name="olsr"></a>olsr
</h2>

<pre>ols2c(const my, const mx, const amb);
ols2c(const my, const mx, const amb, const amxtxinv);
ols2c(const my, const mx, const amb, const amxtxinv,
    const amxtx);

olsc(const my, const mx, const amb);
olsc(const my, const mx, const amb, const amxtxinv);
olsc(const my, const mx, const amb, const amxtxinv,
    const amxtx);
</pre>

<dl><dd>
<dl>
<dt><tt>my</tt>

<dd>in: <i>T</i> <tt>x</tt> <i>n</i> matrix <i>Y</i>

<dt><tt>mx</tt>

<dd>in: <i>T</i> <tt>x</tt> <i>k</i> matrix <i>X</i>

<dt><tt>amb</tt>

<dd>in: address of variable

<dd>out: <i>k</i> <tt>x</tt> <i>n</i> matrix of OLS coefficients, <i>B</i>


<dt><tt>amxtxinv</tt>

<dd>in: (optional argument) address of variable

<dd>out: <i>k</i> <tt>x</tt> <i>k</i> matrix (<i>X</i>'<i>X</i>)<sup>-1</sup>,


<dt><tt>amxtx</tt>

<dd>in: (optional argument) address of variable

<dd>out: <i>k</i> <tt>x</tt> <i>k</i> matrix (<i>X</i>'<i>X</i>),
</dl>
</dl>

<pre>ols2r(const my, const mx, const amb);
ols2r(const my, const mx, const amb, const amxtxinv);
ols2r(const my, const mx, const amb, const amxtxinv,
    const amxtx);

olsr(const my, const mx, const amb);
olsr(const my, const mx, const amb, const amxtxinv);
olsr(const my, const mx, const amb, const amxtxinv,
    const amxtx);
</pre>

<dl><dd>
<dl>
<dt><tt>my</tt>

<dd>in: <i>n</i> <tt>x</tt> <i>T</i> matrix <i>Y</i>'

<dt><tt>mx</tt>

<dd>in: <i>k</i> <tt>x</tt> <i>T</i> matrix <i>X</i>', <i>T</i> &gt;= <i>k</i>


<dt><tt>amb</tt>

<dd>in: address of variable

<dd>out: <i>n</i> <tt>x</tt> <i>k</i> OLS coefficient matrix, <i>B</i>'


<dt><tt>amxtxinv</tt>

<dd>in: (optional argument) address of variable

<dd>out: <i>k</i> <tt>x</tt> <i>k</i> matrix (<i>X</i>'<i>X</i>)<sup>-1</sup>,


<dt><tt>amxtx</tt>

<dd>in: (optional argument) address of variable

<dd>out: <i>k</i> <tt>x</tt> <i>k</i> matrix (<i>X</i>'<i>X</i>),
</dl>

<dt><i>Return value</i>

<dd>

<ul>
<li>0: out of memory,

<li>1: success,

<li>2: ratio of diagonal elements of <i>X</i>'<i>X</i> is large, rescaling
is advised (ratio of smallest to largest <= <i>eps</i><sub><i>inv</i></sub>),

<li>-1: (<i>X</i>'<i>X</i>) is (numerically) singular
(decision made in <tt><a href="#decqr">decqr</a></tt> and <tt><a href="#decldl">decldl</a></tt> respectively),

<li>-2: combines 2 and -1.
</ul>
The inversion epsilon, <i>eps</i><sub><i>inv</i></sub>, is set by the
<tt><a href="#inverteps">inverteps</a></tt> function.

<dt><i>Description</i>
<dd>
The <tt>ols2c</tt> and <tt>ols2r</tt> versions use the Choleski
decomposition on the second moment matrix, while the others
use the QR decomposition. The latter is numerically
more stable, and therefore preferred, but takes more memory
and is marginally slower.

<dt><i>See also</i>

<dd><tt><a href="#decldl">decldl</a></tt>,
<tt><a href="#decqr">decqr</a></tt>,
<tt><a href="#inverteps">inverteps</a></tt>

<dt><a href="oxstdexamples.html#ols2c"><i>Example</i></a>
</dl>


<h2><a name="ones"></a>ones</h2>

<pre>ones(const r, const c);
ones(const ma);
</pre>

<dl><dd>
<dl>
<dt><tt>r</tt>

<dd>in: int

<dt><tt>c</tt>

<dd>in: int

<dt><tt>ma</tt>

<dd>in: matrix
</dl>

<dt><i>Return value</i>

<dd><tt>ones(r,c)</tt> returns an <tt>r</tt> by <tt>c</tt> matrix filled with ones.

<dd><tt>ones(ma)</tt> returns a matrix of the same dimension as <tt>ma</tt>, filled with ones.

<dt><i>See also</i>

<dd><tt><a href="#constant">constant</a></tt>, <tt><a href="#nans">nans</a></tt>, <tt><a href="#unit">unit</a></tt>, <tt><a href="#zeros">zeros</a></tt>

<dt><a href="oxstdexamples.html#ones"><i>Example</i></a>
</dl>



<h2><a name="outer"></a>outer</h2>

<pre>outer(const mx, const ms);
outer(const mx, const ms, const mode);
</pre>

<dl><dd>
<dl>
<dt><tt>mx</tt>

<dd>in: <i>m</i> <tt>x</tt> <i>n</i> matrix <i>X</i>

<dt><tt>ms</tt>

<dd>in: <i>n</i> <tt>x</tt> <i>n</i> symmetric matrix <i>S</i> or empty matrix

<dt><tt>mode</tt>

<dd>in: int, operation mode: 'd' or 'o' (optional argument)
</dl>

<dt><i>Return value</i>

<dd>
<tt>outer(mx,ms)</tt> returns <i>XSX'</i>, which is <i>m</i> <tt>x</tt>	<i>m</i>.<br>
<tt>outer(mx,&lt;&gt;)</tt> returns <i>XX'</i>, which is <i>m</i> <tt>x</tt>	<i>m</i>.<br>
<tt>outer(mx,ms,'d')</tt> returns <tt>diagonal</tt>(<i>XSX'</i>), which is 1 <tt>x</tt> <i>m</i>.<br>
<tt>outer(mx,&lt;&gt;,'o')</tt> returns Sum <i>x</i><sub><i>i</i></sub><i>x</i><sub><i>i</i></sub>', which is <i>n</i> <tt>x</tt> <i>n</i>,
where <i>X'</i>=(<i>x</i><sub>1</sub>,...,<i>x</i><sub><i>m</i></sub>).

<dt><i>See also</i>

<dd><tt><a href="#diagonal">diagonal</a></tt>

<dt><a href="oxstdexamples.html#outer"><i>Example</i></a>
</dl>


<h2><a name="oxfilename"></a>oxfilename</h2>

<pre>oxfilename(const itype);
</pre>

<dl><dd>
<dl>
<dt><tt>itype</tt>

<dd>in: int, determines output format
</dl>

<dt><i>Return value</i>

<dd>Returns a string with the name of the Ox source file from which it is called:
<pre>
itype  returns            example: oxl D:\waste\func  example: oxl func
0      full file name     D:\waste\func.ox            func.ox
1      path of file name  D:\waste\                    
2      base name          func                        func
3      file extension     .ox                         .ox
</pre>

In the first two cases the return value depends on how the
the program was started (the path may not have been specified).

</dl>



<h2><a name="oxprintlevel"></a>oxprintlevel</h2>

<pre>oxprintlevel(const ilevel);
</pre>

<dl><dd>
<dl>
<dt><tt>ilevel</tt>

<dd>in: int, print level, see below
</dl>

<dt><i>No return value</i>
<dd>

<dt><i>Description</i>
<dd>
Controls printing:
<ul>
<li><tt>oxprintlevel(1);</tt> &nbsp;&nbsp; default: prints as normal,
<li><tt>oxprintlevel(0);</tt> &nbsp;&nbsp; switches printing off (<tt>print</tt> and <tt>println</tt> have no output),
<li><tt>oxprintlevel(2);</tt> &nbsp;&nbsp; disallows further calls to <tt>oxprintlevel</tt>,
<li><tt>oxprintlevel(-1);</tt>&nbsp; switches printing off, including warnings.
</ul>
<p>
This function can be useful in simulations (e.g.),
where the code being simulated has no other mechanism for switching
printing on and off (<a href="oxclass.html#Modelbase">Modelbase</a>
derived code normally uses <tt>SetPrint</tt>).

<dt><i>See also</i>

<dd><tt><a href="#oxwarning">oxwarning</a></tt>

<dt><a href="oxstdexamples.html#oxprintlevel"><i>Example</i></a>
</dl>


<h2><a name="oxrunerror"></a>oxrunerror</h2>

<pre>oxrunerror(const smsg);
oxrunerror(const smsg, const i01);
</pre>

<dl><dd>
<dl>
<dt><tt>smsg</tt>

<dd>in: string, error message text
<dt><tt>i01</tt>

<dd>in: int, 0 (the default) or 1

</dl>

<dt><i>No return value</i>

<dd>
Prints the specified run-time error message and location, and exits the
program.
<dt><i>Description</i>
<dd>
If <tt>i01</tt>=0, the standard
Ox call trace is printed; if <tt>i01</tt>=1, the top level function call
is skipped (in case the error is raised in an error handler function).
Use 2 to omit the trace.
</dl>


<h2><a name="oxversion"></a>oxversion</h2>

<pre>oxversion();
</pre>

<dl><dd>
<dt><i>Return value</i>

<dd>Returns an integer with the version of Ox multiplied by 100. So for
version 5.00 the return value is 500.
<dd>
</dl>


<h2><a name="oxwarning"></a>oxwarning</h2>

<pre>oxwarning(const smsg);
oxwarning(const flset);
</pre>

<dl><dd>
<dl>
<dt><tt>smsg</tt>

<dd>in: string, user-determined warning message

<dt><tt>flset</tt>

<dd>in: int, new warnings settings

</dl>

<dt><i>Return value</i>

<dd>Returns the previous warnings settings.

<dt><i>Description</i>

<dd>
When given a string as argument, the function will print
a user-determined warning message.
<p>
Otherwise, <tt>oxwarning</tt> controls the reporting of run-time warning messages. The
following types of messages are controlled by this function:

<ul>
<li><tt>WFL_DECFAILED</tt> &nbsp;&nbsp;decomposition failed,
<li><tt>WFL_ITMAX</tt>     &nbsp;&nbsp;maximum no. of iterations reached,
<li><tt>WFL_CONCAT</tt>    &nbsp;&nbsp;concatenation dimensions don't match,
<li><tt>WFL_VECIDXMAT</tt> &nbsp;&nbsp;indexed a matrix as a vector,
<li><tt>WFL_DETERMINANT</tt> &nbsp;&nbsp;determinant-related warning,
<li><tt>WFL_USER</tt>      &nbsp;&nbsp;user-determined warning message.
</ul>

The first occurs when an inversion or decomposition
fails, the second could happen in an eigenvalue based function.
The concatenation message is printed when the dimensions
don't match, and the results has been padded with zeros.
The message related to <tt>WFL_VECIDXMAT</tt> is given when a
matrix which is not a row or column vector is indexed with
just one index. However, the message is not given when using an
empty single index <tt>[]</tt>, which has the same effect as the
<tt>vecr</tt> function.
<p>
You can add the flags together to specify warning settings.
Use <tt>oxwarning(0)</tt> to switch both these messages off,
and <tt>oxwarning(-1)</tt> to switch them all on.

<dt><i>See also</i>

<dd><tt><a href="#oxprintlevel">oxprintlevel</a></tt>

</dl>


<h2><a name="periodogram"></a>periodogram</h2>

<pre>
periodogram(const ma);
periodogram(const ma, const itrunc, const cpoints,
    const imode);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>

<dd>in: arithmetic type, <i>T</i> <tt>x</tt> <i>n</i> matrix

<dt><tt>itrunc</tt>

<dd>in: int, truncation parameter <i>m</i>, if &gt;= <i>T</i> then <i>T</i>-1
is used

<dt><tt>cpoints</tt>

<dd>in: int, no of points <i>N</i> at which to evaluate periodogram


<dt><tt>imode</tt>

<dd>in: 0: (truncated) periodogram (times T),
1: smoothed periodogram	(times T)
using Parzen window, 2: estimated spectral density using Parzen
window (as option 1, but divided by <i>c</i><sub>0</sub>).
</dl>

<dt><i>Return value</i>

<dd>
<ul>
<li><tt>periodogram(ma);</tt><br>

Returns a <i>N</i>+1 by <i>n</i> matrix with <i>T</i> times the periodogram computed
at the Fourier frequencies
0, <i>2\pi</i>/<i>T</i>, ..., <i>2N\pi</i>/<i>T</i>,
where <i>N</i>=int(<i>T</i>/2).

<li><tt>periodogram(ma, itrunc, N, 0);</tt><br>

Returns a <i>N</i> by <i>n</i> matrix with the periodogram
of the columns of <tt>ma</tt> using autocovariances up to lag <tt>itrunc</tt>,
computed at	frequencies: 0, <i>\pi</i>/(<i>N</i>-1), ..., <i>\pi</i>.

<li><tt>periodogram(ma, itrunc, N, 1);</tt><br>

Returns a <i>N</i> by <i>n</i> matrix with the smoothed periodogram
of the columns of <tt>ma</tt> using autocovariances up to lag <tt>itrunc</tt>,
computed at	frequencies: 0, <i>\pi</i>/(<i>N</i>-1), ..., <i>\pi</i>.

<li><tt>periodogram(ma, itrunc, N, 2);</tt><br>

Returns a <i>N</i> by <i>n</i> matrix with the spectral density
of the columns of <tt>ma</tt> using autocorrelations up to lag <tt>itrunc</tt>,
computed at	frequencies: 0, <i>\pi</i>/(<i>N</i>-1), ..., <i>\pi</i>.
</ul>

<dt><i>See also</i>

<dd>
<tt><a href="oxdraw.html#DrawSpectrum">DrawSpectrum</a></tt>.

<dt><a href="oxstdexamples.html#periodogram"><i>Example</i></a>
</dl>


<h2><a name="polydiv"></a>polydiv</h2>

<pre>polydiv(const ma, const mb, const cp);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>

<dd>in: 1 <tt>x</tt> <i>m</i> matrix <i>A</i> = (<i>a</i><sub>0</sub> ...
<i>a<sub>m</sub></i><sub>-1</sub>) specifying the <i>A</i> polynomial (see
below)

<dt><tt>mb</tt>

<dd>in: 1 <tt>x</tt> <i>n</i> matrix <i>B</i> = (<i>b</i><sub>0</sub> ...
<i>b<sub>n</sub></i><sub>-1</sub>) specifying the <i>B</i> polynomial (see
below)

<dt><tt>cp</tt>

<dd>in: int, required length, <i>p</i>, of polynomial resulting from division

</dl>

<dt><i>Return value</i>

<dd>
Returns a 1 <tt>x</tt> <i>p</i> matrix with the coefficients of polynomial
resulting from dividing the <i>A</i> polynomial by the <i>B</i> polynomial.
The integer 0 is returned when <i>b</i><sub>0</sub> is 0, or <i>p</i>=0.


<dt><i>See also</i>

<dd>
<tt><a href="#polyeval">polyeval</a></tt>,
<tt><a href="#polymake">polymake</a></tt>,
<tt><a href="#polymul">polymul</a></tt>,
<tt><a href="#polyroots">polyroots</a></tt>

<dt><a href="oxstdexamples.html#polymul"><i>Example</i></a>
</dl>


<h2><a name="polyeval"></a>polyeval</h2>

<pre>polyeval(const ma, const mx);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>

<dd>in: 1 <tt>x</tt> <i>m</i> matrix <i>A</i> = (<i>a</i><sub>0</sub> ...
<i>a<sub>m</sub></i><sub>-1</sub>) specifying the <i>A</i> polynomial

<dt><tt>mx</tt>

<dd>in: arithmetics type

</dl>

<dt><i>Return value</i>

<dd>
Returns the polynomial evaluated at <tt>mx</tt>.


<dt><i>See also</i>

<dd>
<tt><a href="#polydiv">polydiv</a></tt>,
<tt><a href="#polymake">polymake</a></tt>,
<tt><a href="#polymul">polymul</a></tt>,
<tt><a href="#polyroots">polyroots</a></tt>

<dt><a href="oxstdexamples.html#polyeval"><i>Example</i></a>
</dl>


<h2><a name="polygamma"></a>polygamma</h2>

<pre>polygamma(const ma, const mn);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>

<dd>in: arithmetic type, argument

<dt><tt>mn</tt>

<dd>in: arithmetic type, order of derivative: 0 = first derivative, 1 =
second derivative, etc.
</dl>

<dt><i>Return value</i>

<dd>Returns the derivative of the logarithm of the complete gamma function
at the value of each element of <tt>ma</tt>, of double or matrix type.
The second argument specifies the order of the derivative. Returns zero for derivative
order less than 0 and <tt>-.Inf</tt> when the argument is zero or a negative integer.


The return type is derived as follows:

<ul>
<li><i>m</i> <tt>x</tt> <i>n</i> matrix, when <tt>ma</tt> is an <i>m</i>
<tt>x</tt> <i>n</i> matrix, and the rest is scalar (int);

<li><i>m</i> <tt>x</tt> <i>n</i> matrix, when <tt>ma</tt> is a scalar,
and the rest are <i>m</i> <tt>x</tt> <i>n</i> matrices;

<li><i>m</i> <tt>x</tt> <i>n</i> matrix, when <tt>ma</tt> is an <i>m</i>
<tt>x</tt> <i>n</i> matrix, and the rest are <i>m</i> <tt>x</tt> <i>n</i>
matrices;

<li>double, when <tt>ma</tt> is scalar, and the rest is also scalar (int).

</ul>

<dt><i>See also</i>

<dd><tt><a href="#loggamma">loggamma</a></tt>

<dt><a href="oxstdexamples.html#polygamma"><i>Example</i></a>
</dl>


<h2><a name="polymake"></a>polymake</h2>

<pre>polymake(const roots);
</pre>

<dl><dd>
<dl>
<dt>roots
<dd>in: 2 <tt>x</tt> <i>m</i> matrix with (inverse) roots of the polynomial,
first row is real part, second row imaginary part
(or 1 <tt>x</tt> <i>m</i> matrix if all roots are real).
</dl>

<dt><i>Return value</i>

<dd>
Returns the coefficients of the polynomial (<i>a</i><sub>0</sub> = 1) as a
2 <tt>x</tt> (<i>m</i>+1)
matrix if the roots had a complex part, else 1 <tt>x</tt> (<i>m</i>+1).

<dt><i>See also</i>

<dd><tt><a href="#polyroots">polyroots</a></tt>

<dt><a href="oxstdexamples.html#polyroots"><i>Example</i></a>
</dl>


<h2><a name="polymul"></a>polymul</h2>

<pre>polymul(const ma, const mb);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>

<dd>in: 1 <tt>x</tt> <i>m</i> matrix <i>A</i> = (<i>a</i><sub>0</sub> ...
<i>a<sub>m</sub></i><sub>-1</sub>) specifying the <i>A</i> polynomial (see
below)

<dt><tt>mb</tt>

<dd>in: 1 <tt>x</tt> <i>n</i> matrix <i>B</i> = (<i>b</i><sub>0</sub> ...
<i>b<sub>n</sub></i><sub>-1</sub>) specifying the <i>B</i> polynomial (see
below)
</dl>

<dt><i>Return value</i>

<dd>Returns a 1 <tt>x</tt> (<i>m</i>+<i>n</i>-1) matrix
with the coefficients of the product of the polynomials.


<dt><i>See also</i>
<dd><tt><a href="#polydiv">polydiv</a></tt>,
<tt><a href="#polyeval">polyeval</a></tt>,
<tt><a href="#polymake">polymake</a></tt>,
<tt><a href="#polyroots">polyroots</a></tt> 

<dt><a href="oxstdexamples.html#polymul"><i>Example</i></a>
</dl>


<h2><a name="polyroots"></a>polyroots</h2>

<pre>polyroots(const ma, const amroots);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>

<dd>in: 1 <tt>x</tt> (<i>m</i>+1) matrix <i>A</i> = (<i>a</i><sub>0</sub>
... <i>a<sub>m</sub></i>) specifying the polynomial of order <i>m</i> (see
below)

<dt>amroots

<dd>in: address of variable

<dd>out: 2 <tt>x</tt> <i>m</i> matrix with roots of the polynomial first
row is real part, second row imaginary part (all zeros if the roots are
real). The roots are <i>not</i> sorted.
</dl>

<dt><i>Return value</i>

<dd>Returns the result of the eigenvalue decomposition:

<ul>
<li>0: no error;

<li>1: maximum no of iterations (50) reached.
</ul>

<dt><i>See also</i>

<dd><tt><a href="#eigen">eigen</a></tt>,
<tt><a href="#polydiv">polydiv</a></tt>,
<tt><a href="#polyeval">polyeval</a></tt>,
<tt><a href="#polymake">polymake</a></tt>, <tt><a href="#polymul">polymul</a></tt>

<dt><a href="oxstdexamples.html#polyroots"><i>Example</i></a>
</dl>


<h2>
<a name="pow"></a>pow
</h2>

<pre>pow(const ma, const p);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>

<dd>in: arithmetic type
</dl>

<dt><i>Return value</i>

<dd>Returns <tt>ma .^ p</tt>. This is identical to using the dot-power
operator, with the exception that if both <tt>ma</tt> and <tt>p</tt>
are an integer, the return type is a double.

<dt><i>See also</i>

<dd><tt><a href="#sqr">sqr</a></tt>,
<tt><a href="oxsyntax.html#ox_syntax_power">^ .^</a></tt>

<dt><a href="oxstdexamples.html#sqr"><i>Example</i></a>
</dl>


<h2>
<a name="print"></a>print,
<a name="println"></a>println,
</h2>

<pre>print(const a, ...);
println(const a, ...);
</pre>

<dl><dd>
<dl>
<dt><tt>a</tt>

<dd>in: any type

<dt><tt>...</tt>

<dd>in: any type
</dl>

<dt><i>Return value</i>

<dd>Returns the number of arguments supplied to the function.

<dt><i>Description</i>

<dd>Each argument is printed to stdout using default formatting. A formatting
string can be input in the input stream: a formatting string starts with
a % symbol, and is followed by one or more characters. If a formatting
string is encountered, it is not printed, but applied to the next argument.
<p>
There is an
additional option to add column and row labels for a matrix,
specify a different format for each matrix column, or
only print the lower diagonal:

<ul>
<li><tt>%r</tt> the next argument contains row labels (array of strings),
<li><tt>%c</tt> the next argument contains column labels (array of strings).
<li><tt>%cf</tt> the next argument contains column formats (array of strings)
<li><tt>%lwr</tt> only print the lower diagonal of the matrix
</ul>

<p>The default format strings are:

<ul>
<li>no value: <tt>"null"</tt>,

<li>int: <tt>"%d"</tt>,

<li>double: <tt>"%g"</tt>,

<li>matrix: <tt>"\n"</tt>, then each element <tt>"%#13.5g"</tt>,
6 elements on a line (5 if row is labelled), no labels,

<li>string: <tt>"%s"</tt>,

<li>array: <tt>"&amp;0x%p"</tt>,

<li>function: <tt>"&amp;%d"</tt>,

<li>class: <tt>"&amp;0x%p"</tt>,

<li>library function: <tt>"&amp;0x%p"</tt>. The <tt><a href="#format">format</a></tt>
function may be used to set a different default format; it also lists the
format options.

<li>date/time: <tt>"%C"</tt>,

If there is no fraction the calendar date is printed as
yyyy-mm-dd; if there is only a fraction the time is printed
as hh:mm or hh:mm:ss or hh:mm:ss.hh. If both are present
yyyy-mm-ddThh:mm[:ss[.hh]] is printed (so using the ISO standard for date/time formatting).
Also see <a href="oxstdexamples.html#dayofcalendar"><tt>dayofcalendar</tt></a>.

<li>any type: <tt>"%v"</tt>, prints a variable in the format
of an Ox constant, and can be used for any variable.
It can be especially useful to read and write variables
that consist of derived types, such as an array or a
class object, but also for a matrix. An example is given below
and in <tt>ox/samples/inout/percent_v.ox</tt>.


</ul>

<p>The format specification is similar to that for the printf function
of the C language:

<p>%[<i>flag</i>][<i>width</i>][.<i>precision</i>]<i>type</i>


<h3><a name="TabStd2"></a>Table std.2: Formatting flags for doubles and
integers</h3>
<pre>-        left adjust in output field,
+        always print a sign,
space    prefix space if first character is not a sign
0        pad with leading zeros,
#        alternate output form:
         type is o: first digit will be 0,
         type is xX: prefix with 0x or 0X (unless value is 0),
         type is eEfgG: always print decimal point,
         type is gG: keep trailing zeros.
         type is mM: omit dimensions.
</pre>
<hr>

<p>The <i>width</i> argument specifies the width of the output field. The
<i>precision</i> argument specifies the number of significant digits (type
is <tt>gG</tt>) number of digits after the decimal point (type is <tt>eEf</tt>);
the default is 6 if <i>precision</i> is absent. 
<hr>

<h3><a name="TabStd3"></a>Table std.3: Formatting types for printing</h3>
<pre>double type, also used for matrices:
g,G       %e or %E if the exponent is <-4
          or >= precision; else use %f,
e,e       scientific notation: with exponent,
f         print without exponent,
C         print as a calendar date

specials for matrices:
r         followed by row labels (array of strings),
c         followed by column labels (array of strings),
cf        followed by column formats (array of strings),
    e.g.: print("%c",{"a","b"},"%cf",{"%8.4g","%6.2g"},m);

integer type:
d,i       signed decimal notation,
o         unsigned octal notation,
x,X       unsigned hexadecimal notation,
u         unsigned decimal notation,
c         print as a single character (i.e. one byte),

string type:
s         string format.

matrix type:
m         print matrix row by row using %25.26e.
M         print matrix row by row with the default format.

any type:
v		  any variable in Ox constant format.
</pre>
<hr>

<p>
<tt>println</tt> is as <tt>print</tt> but ensures the next output
will be on a new line.

<p>
To print text starting with a percentage symbol that is also a format specifier,
use either <tt>%s</tt> as the format, or a double percentage, as in
<tt>println("%s", "%GDP", " or: ", "%%GDP")</tt>.

<dt><i>See also</i>

<dd><tt><a href="#eprint">eprint</a></tt>, <tt><a href="#format">format</a></tt>,
<tt><a href="#fprint">fprint</a></tt>, <tt><a href="#fscan">fscan</a></tt>,
<tt><a href="#fwrite">fwrite</a></tt>, <tt><a href="#sprint">sprint</a></tt>

<dt><a href="oxstdexamples.html#print"><i>Example</i></a>
</dl>


<h2>
<a name="probchi"></a>probchi,
<a name="probf"></a>probf,
<a name="probn"></a>probn,
<a name="probt"></a>probt
</h2>

<pre>
probchi(const ma, const df);
probchi(const ma, const df, const nc);
probf(const ma, const df1, const df2);
probf(const ma, const df1, const df2, const nc);
probn(const ma);
probt(const ma, const df);
probt(const ma, const df, const nc);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>
<dd>in: arithmetic type

<dt><tt>df</tt>
<dd>in: arithmetic type, degrees of freedom

<dt><tt>df1</tt>
<dd>in: arithmetic type, degrees of freedom in the numerator

<dt><tt>df2</tt>
<dd>in: arithmetic type, degrees of freedom in the denominator

<dt><tt>nc</tt>
<dd>in: arithmetic type, non-centrality parameter
</dl>

<dt><i>Return value</i>

<dd>Returns the requested probabilities at <tt>ma</tt> (the returned probabilities
are between zero and one):

<ul>
<li><tt>probchi</tt>: probabilities from chi<sup>2</sup>(df) distribution,

<li><tt>probchi</tt>: probabilities from non-central chi<sup>2</sup>(df) distribution,

<li><tt>probf</tt>: probabilities from F(df1, df2) distribution,

<li><tt>probf</tt>: probabilities from non-central F(df1, df2) distribution,

<li><tt>probn</tt>: one-sided probabilities from the standard normal N(0,1),

<li><tt>probt</tt>: one-sided probabilities from student-t(df) distribution,

<li><tt>probt</tt>: one-sided probabilities from non-central student-t(df) distribution.

</ul>
<p>
The normal probabilities are accurate to 14-15 significant digits
for probabilities &gt;10<sup>-20</sup>.
The probabilities are accurate to about 10 digits.

The return type is derived as follows:

<ul>
<li><i>m</i> <tt>x</tt> <i>n</i> matrix, when <tt>ma</tt> is an <i>m</i>
<tt>x</tt> <i>n</i> matrix, and the rest is scalar;


<li><i>m</i> <tt>x</tt> <i>n</i> matrix, when <tt>ma</tt> is a scalar,
and the rest are <i>m</i> <tt>x</tt> <i>n</i> matrices;

<li><i>m</i> <tt>x</tt> <i>n</i> matrix, when <tt>ma</tt> is an <i>m</i>
<tt>x</tt> <i>n</i> matrix, and the rest are <i>m</i> <tt>x</tt> <i>n</i>
matrices;

<li>double, when <tt>ma</tt> is scalar, and the rest is also scalar.
</ul>

<dt><i>See also</i>

<dd>
<tt><a href="#denschi">dens...</a></tt>,
<tt><a href="#quanchi">quan...</a></tt>,
<tt><a href="#tailchi">tail...</a></tt>,
<a href="oxpackages.html#ProbPack">Probability package</a>

<dt><a href="oxstdexamples.html#probchi"><i>Example</i></a>
</dl>


<h2>
<a name="prodc"></a>prodc,
<a name="prodr"></a>prodr
</h2>

<pre>prodc(const ma);
prodr(const ma);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>

<dd>in: <i>T</i> <tt>x</tt> <i>n</i> matrix <i>A</i>
</dl>

<dt><i>Return value</i>

<dd>The <tt>prodc</tt> function returns a 1 <tt>x</tt> <i>n</i> matrix
<tt>r</tt> which holds the product of all column elements of <tt>ma</tt>.

<p>The <tt>prodr</tt> function returns a <i>T</i> <tt>x</tt> 1 matrix which
holds the product of all row elements of <tt>ma</tt>.

<dt><i>See also</i>

<dd><tt><a href="#sumc">sumc</a></tt>, <tt><a href="#sumr">sumr</a></tt>

<dt><a href="oxstdexamples.html#prodc"><i>Example</i></a>
</dl>


<h2>
<a name="quanchi"></a>quanchi,
<a name="quanf"></a>quanf,
<a name="quann"></a>quann,
<a name="quant"></a>quant
</h2>

<pre>
quanchi(const ma, const df);
quanf(const ma, const df1, const df2);
quann(const ma);
quant(const ma, const df);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>
<dd>in: arithmetic type, probabilities: all values must be between 0 and 1

<dt><tt>df</tt>
<dd>in: arithmetic type, degrees of freedom

<dt><tt>df1</tt>
<dd>in: arithmetic type, degrees of freedom in the numerator

<dt><tt>df2</tt>
<dd>in: arithmetic type, degrees of freedom in the denominator

<dt><tt>dr</tt>, <tt>da</tt>
<dd>in: arithmetic type
</dl>

<dt><i>Return value</i>

<dd>Returns the requested quantiles (inverse probability function; percentage
points) at <tt>ma</tt>:

<ul>
<li><tt>quanchi</tt>: quantiles from chi<sup>2</sup>(df) distribution,

<li><tt>quanf</tt>: quantiles from F(df1, df2) distribution,

<li><tt>quann</tt>: standard normal quantiles,

<li><tt>quant</tt>: quantiles from student-t(df) distribution.
</ul>

<p>The quantiles are accurate to about 10 digits.

The return type is derived as follows:

<ul>
<li><i>m</i> <tt>x</tt> <i>n</i> matrix, when <tt>ma</tt> is an <i>m</i>
<tt>x</tt> <i>n</i> matrix, and the rest is scalar;


<li><i>m</i> <tt>x</tt> <i>n</i> matrix, when <tt>ma</tt> is a scalar,
and the rest are <i>m</i> <tt>x</tt> <i>n</i> matrices;

<li><i>m</i> <tt>x</tt> <i>n</i> matrix, when <tt>ma</tt> is an <i>m</i>
<tt>x</tt> <i>n</i> matrix, and the rest are <i>m</i> <tt>x</tt> <i>n</i>
matrices;

<li>double, when <tt>ma</tt> is scalar, and the rest is also scalar.
</ul>

<dt><i>See also</i>

<dd><tt><a href="#denschi">dens...</a></tt>, <tt><a href="#probchi">prob...</a></tt>, <tt><a href="#tailchi">tail...</a></tt>
<a href="oxpackages.html#ProbPack">Probability package</a>

<dt><a href="oxstdexamples.html#quanchi"><i>Example</i></a>
</dl>


<h2>
<a name="quantilec"></a>quantilec,
<a name="quantiler"></a>quantiler
</h2>

<pre>quantilec(const ma);
quantiler(const ma);
quantilec(const ma, const mq);
quantiler(const ma, const mq);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>

<dd>in: <i>T</i> <tt>x</tt> <i>n</i> matrix <i>A</i>

<dt><tt>mq</tt>

<dd>in: (optional argument) 1 <tt>x</tt> <i>q</i> matrix of quantiles
</dl>

<dt><i>Return value</i>

<dd>The <tt>quantilec</tt> function returns a <i>q</i> <tt>x</tt> <i>n</i>
matrix holding the requested quantiles of the columns of <tt>ma</tt>. If
no second argument is used the return value is a 1 <tt>x</tt> <i>n</i>
matrix holding the medians.

<p>The <tt>quantiler</tt> function returns a <i>T</i>
<tt>x</tt> <i>q</i> matrix holding the requested quantiles of the rows
of <tt>ma</tt>. If no second argument is used the return value is a <i>T</i>
<tt>x</tt> 1 matrix holding the medians.

<dt><i>See also</i>

<dd><tt><a href="#meanc">meanc</a></tt>, <tt><a href="#meanr">meanr</a></tt>, <tt><a href="#varc">varc</a></tt>, <tt><a href="#varr">varr</a></tt>

<dt><a href="oxstdexamples.html#quantilec"><i>Example</i></a>
</dl>


<h2><a name="range"></a>range</h2>

<pre>range(const min, const max);
range(const min, const max, const step);
</pre>

<dl><dd>
<dl>
<dt><tt>min</tt>

<dd>in: int or double, first value <i>m</i>

<dt><tt>max</tt>

<dd>in: int or double, last value <i>n</i>

<dt><tt>step</tt>

<dd>in: int or double, (optional argument) increment
</dl>

<dt><i>Return value</i>

<dd>Returns a 1 <tt>x</tt> (<i>n</i>-<i>m</i>+1) matrix with the values
with values <i>m</i>, <i>m</i>+1, ..., <i>n</i>. If <i>n</i>&lt;<i>m</i>,
<tt>range</tt> returns a 1 <tt>x</tt> (<i>m</i>-<i>n</i>+1) matrix with
the values with values <i>m</i>, <i>m</i>-1, ..., <i>n</i>. The version
which uses the <tt>step</tt> argument uses that as the incrementor (rather
than the default +1 or -1), the returned matrix is a row vector of the
required length.

<dt><i>Description</i>
<dd>
When all arguments are integers, the incrementation arithmetic
is done using integers, else using doubles. Integer arithmetic
could be a bit more precise when using longer ranges.
The following example illustrates the difference:
<pre>
range(-1.1, 1.1, 0.11);
range(-110, 110, 11) / 100;
</pre>

The first line has the loop using floating point arithmetic,
and will not have exactly zero, but something like -1.9e-16 as its
11th element. In the second line, the loop is incremented in
integer arithmetic before conversion to floating point numbers. Here the
11th number will be exactly zero.
Because if these rounding errors, it is best to 
use the integer version, and scale afterwards.

<dt><i>See also</i>

<dd><tt><a href="#constant">constant</a></tt>

<dt><a href="oxstdexamples.html#range"><i>Example</i></a>
</dl>


<h2><a name="rank"></a>rank</h2>

<pre>rank(const ma);
rank(const ma, const eps);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>

<dd>in: arithmetic type

<dt><tt>eps</tt>

<dd>in: arithmetic type, optional tolerance
</dl>

<dt><i>Return value</i>

<dd>Returns the rank of a matrix, of type int. The rank of a scalar is
1, except for the rank of zero,	which is zero. In the one argument
version, the rank is also relative to the norm, so that
<tt>rank(1e-20)</tt> equals one. The two argument version uses
the specified tolerance: <tt>rank(1e-20, 1e-10)</tt> equals zero.

<dt><i>See also</i>

<dd><tt><a href="#decsvd">decsvd</a></tt>,
<tt><a href="#inverteps">inverteps</a></tt>,
<tt><a href="#norm">norm</a></tt>

<dt><a href="oxstdexamples.html#rank"><i>Example</i></a>
</dl>



<h2>
<a name="ranloopseed"></a>ranloopseed
</h2>

<pre>
ranloopseed(const iloop, const istage);
</pre>

<dl><dd>
<dl>
<dt><tt>iloop</tt>

<dd>in: int, loop counter (if <tt>istage</tt> = 0)
<dt><tt>istage</tt>

<dd>in: int, -1: initialization, 0: iterating, 1: exiting
</dl>

<dt><i>No return value</i>

<dt><i>Description</i>

<dd>
Colours the current seed with the loop iterator, so that parallel loops
have the same random number stream independently of how they
are partitioned among threads or processes.
This is automatically done inside Ox for parallel for and parallel foreach loops.
<p>
Note that nested calls to ranloopseed are ignored, as are calls inside a parallel loop.

</dl>


<h2>
<a name="rann"></a>rann
</h2>

<pre>
rann(const r, const c);
</pre>

<dl><dd>
<dl>
<dt><tt>r</tt>
<dd>in: int, number of rows

<dt><tt>c</tt>
<dd>in: int, number of columns
</dl>

<dt><i>Return value</i>

<dd>Returns a <tt>r</tt> by <tt>c</tt> matrix of random numbers from the
standard normal distribution, using drawings from the current
uniform random generator.

<dt><i>See also</i>

<dd><tt><a href="#ranseed">ranseed</a></tt>, <tt><a href="#ranu">ranu</a></tt>,
<a href="oxpackages.html#ProbPack">Probability package</a>

<dt><a href="oxstdexamples.html#rann"><i>Example</i></a>
</dl>



<h2><a name="ranseed"></a>ranseed</h2>

<pre>ranseed(const iseed);
</pre>

<dl><dd>
<dl>
<dt><tt>iseed</tt>

<dd>in: int (1 seed), or array of ints (multiple seeds), or<br>
    in: string, name of random number generator to use.
</dl>

<dt><i>Return value</i>

<dd>
Returns the current seed(s) of the random number generator (RNG).
If the generator only uses one seed, the return type is int.
Otherwise it is an array holding all the seeds (all array
elements are integers).

<dd>A call to <tt>ranseed(0)</tt> only returns the current seed,
without changing it; <tt>ranseed(-1)</tt>
resets to the initial seed and returns the initial seed.

<dd>A call with a string argument to set the RNG returns the name of the new RNG.
Use <tt>ranseed("")</tt> to get the name of the current RNG without changing it.

<dt><i>Description</i>

<dd>Sets and gets the seed(s); <tt>ranseed</tt> can also change the random
number generator:
<ul>
<li><tt>"PM"</tt>: LCG31, Modified Park and Miller (period approx. 2<sup>31</sup>)
<li><tt>"GM"</tt>: MWC60, George Marsaglia (period approx. 2<sup>60</sup>)
<li><tt>"LE"</tt>: LFSR113, Pierre L'Ecuyer (period approx. 2<sup>113</sup>)
<li><tt>"MWC_32"</tt>: MWC8222, George Marsaglia multiply-with-carry (period approx. 2<sup>8222</sup>)
<li><tt>"MWC_52"</tt>, <tt>"default"</tt>: MWC8222_52, George Marsaglia multiply-with-carry (period approx. 2<sup>8222</sup>)
</ul>

<dd>The number of seeds is dependent on the RNG being used:
To set the seed, for example:
<ul>
<li><tt>"PM"</tt> has 1 seed, example: <tt>ranseed(111);</tt>
<li><tt>"GM"</tt> has 2 seeds, example: <tt>ranseed({111, 1111});</tt>
If only one seed is set then both seeds are set to this value.
<li><tt>"LE"</tt> has 4 seeds, example: <tt>ranseed({1,11,111,1111});</tt>
In the this case the seeds have to be larger than 1, 7, 15, 127
respectively, otherwise the call is ignored.
If only one seed is set then all seeds are set to this value
(using 127 if the value is less than 127).
<li><tt>"MWC_32"</tt> and <tt>"MWC_52"</tt> have 256 seeds and a state
and carry, so <tt>ranseed(0)</tt> returns a vector with 258 elements.
It is possible to
set the seed with one element, for example <tt>ranseed(111)</tt>.
In that case 111 is used as a starting point for a procedure that
generates 256 seeds, and the default state and carry are used.
</ul>

<dd><tt>"MWC_52"</tt> generates a random number that makes full use of the
available floating point precision (this carries over to all other
random number functions). The others only use 32 bits, instead of 52.
This is now the default uniform RNG (in Ox 3.4 and earlier, "PM" was
the default). Choosing <tt>"MWC_52"</tt> or <tt>"MWC_32"</tt> will generate
standard normal samples (<tt>rann</tt>) using the ziggurat method,
while the others use the polar method.

<dt><i>See also</i>

<dd><tt><a href="#rann">rann</a></tt>, <tt><a href="#ranu">ranu</a></tt>

<dt><a href="oxstdexamples.html#ranseed"><i>Example</i></a>
</dl>


<h2><a name="ranu"></a>ranu</h2>

<pre>ranu(const r, const c);
</pre>

<dl><dd>
<dl>
<dt><tt>r</tt>

<dd>in: int

<dt><tt>c</tt>

<dd>in: int
</dl>

<dt><i>Return value</i>

<dd>Returns a <tt>r</tt> by <tt>c</tt> matrix of uniform random numbers.
The matrix is filled by row. When both <tt>r</tt> and <tt>c</tt>
are 1, the return value is a scalar of type double.
The <tt>ranseed</tt> function can be used to change the random
number generator.

<dt><i>See also</i>

<dd><tt><a href="#rann">rann</a></tt>, <tt><a href="#ranseed">ranseed</a></tt>

<dt><a href="oxstdexamples.html#ranu"><i>Example</i></a>
</dl>


<h2><a name="reflect"></a>reflect</h2>

<pre>reflect(const ma);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>

<dd>in: square <i>m</i> <tt>x</tt> <i>m</i> matrix
</dl>

<dt><i>Return value</i>

<dd>Returns the reflected version of <tt>ma</tt>
(i.e. the matrix transposed around its secondary diagonal, which
runs from element [m-1][0] to [0][m-1]).

<dt><i>See also</i>

<dd>transpose operator <tt>'</tt>

<dt><a href="oxstdexamples.html#reflect"><i>Example</i></a>
</dl>


<h2>
<a name="replace"></a>replace
</h2>

<pre>replace(const where, const what, const with);
replace(const where, const what, const with, const smode);
</pre>

<dl><dd>
<dl>
<dt><tt>where</tt> 
<dd>in: object to search in
<dt><tt>what</tt> 
<dd>in: what to search for
<dt><tt>with</tt> 
<dd>in: the replacement
<dt><tt>smode</tt> 
<dd>in: (optional argument), string controlling search method: "i", "ir", "r" or nothing
</dl>

<dt><i>Return value</i>
<dd>Returns <tt>where</tt>, with the requested replacements made (if any). 

<dt><i>Description</i>
<dd>
<table border="2" cellpadding="4" cellspacing="2">
<tr><td><tt>where</tt></td><td><tt>what</tt></td><td><tt>with</tt></td><td>action</td></tr>
<tr><td>array      </td><td>string    </td><td>string      </td><td>replace string elements equal <tt>where</tt> with <tt>with</tt>                                   </td></tr>
<tr><td>array      </td><td>string    </td><td>string      </td><td>apply the replace action on each string element                                             </td></tr>
<tr><td>string     </td><td>string    </td><td>string      </td><td>replace one or more occurrences of substring <tt>what</tt>                                     </td></tr>
<tr><td>arithmetic </td><td>int,double</td><td>int,double  </td><td>replace every element that occurs in <tt>what</tt>                                             </td></tr>
<tr><td>arithmetic </td><td>matrix    </td><td>int,double  </td><td>replace every element that occurs in <tt>what</tt>                                             </td></tr>
<tr><td>arithmetic </td><td>matrix    </td><td>matrix      </td><td>replace every element that occurs in <tt>what</tt> with the corresponding element in <tt>with</tt></td></tr>
<tr><td>array      </td><td>arithmetic</td><td>arithmetic  </td><td>apply the replace action on each arithmetic element                                         </td></tr>
</table>
<p>
Arithmetic denotes a matrix, int, or double.

For string replacement, <tt>smode</tt> is an optional string consisting of the letters:
<table border="2" cellpadding="4" cellspacing="2">
<tr><td><tt>"i"</tt></td><td>ignore case, </td></tr>
<tr><td><tt>"*"</tt></td><td>replace all, </td></tr>
<tr><td><tt>"a"</tt></td><td>replace all, </td></tr>
<tr><td><tt>"."</tt></td><td>dot-replacement: apply the string replacement to every string in the array (instead of replacing entire strings only),</td></tr>
<tr><td><tt>"1"</tt> -- <tt>"9"</tt></td><td>perform from one to nine replacements.</td></tr>
</table>
<p>
The default is <tt>"*"</tt>.
<p>
The <tt>smode</tt> argument is ignored for arithmetic replacement.

<dt><i>See also</i>

<dd><tt><a href="#find">find</a></tt>, <tt><a href="#vecindex">vecindex</a></tt>

<dt><a href="oxstdexamples.html#replace"><i>Example</i></a>
</dl>



<h2><a name="reshape"></a>reshape</h2>

<pre>reshape(const ma, const r, const c);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>

<dd>in: arithmetic type

<dt><tt>r</tt>

<dd>in: int

<dt><tt>c</tt>

<dd>in: int
</dl>

<dt><i>Return value</i>

<dd>Returns an <tt>r</tt> by <tt>c</tt> matrix, filled by row from vecr(<tt>ma</tt>).
If there are less than <tt>rc</tt> elements in <tt>ma</tt>, the input matrix
is repeated.

<dt><i>See also</i>

<dd><tt><a href="#shape">shape</a></tt>, <tt><a href="#vecr">vecr</a></tt>

<dt><a href="oxstdexamples.html#reshape"><i>Example</i></a>
</dl>


<h2>
<a name="reversec"></a>reversec,
<a name="reverser"></a>reverser
</h2>

<pre>reversec(const ma);
reverser(const ma);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>

<dd>in: <i>m</i> <tt>x</tt> <i>n</i> matrix <i>A</i>
</dl>

<dt><i>Return value</i>

<dd>The <tt>reversec</tt> function returns an <i>m</i> <tt>x</tt> <i>n</i>
matrix which is <tt>ma</tt>, except that
the elements within each column are in reverse order.

<p>The <tt>reverser</tt> function returns an <i>m</i> <tt>x</tt> <i>n</i>
matrix which is <tt>ma</tt>, except that
the elements within each row are in reverse order.

<dt><i>See also</i>

<dd><tt><a href="#sortc">sortc</a></tt>, <tt><a href="#sortr">sortr</a></tt>

<dt><a href="oxstdexamples.html#reversec"><i>Example</i></a>
</dl>


<h2><a name="round"></a>round</h2>

<pre>round(const ma);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>

<dd>in: arithmetic type
</dl>

<dt><i>Return value</i>

<dd>Returns the rounded elements of <tt>ma</tt>, of double or matrix type.
Rounds to the nearest integer.

<dt><i>See also</i>

<dd><tt><a href="#ceil">ceil</a></tt>, <tt><a href="#floor">floor</a></tt>, <tt><a href="#trunc">trunc</a></tt>

<dt><a href="oxstdexamples.html#ceil"><i>Example</i></a>
</dl>


<h2><a name="rows"></a>rows</h2>

<pre>rows(const ma);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>

<dd>in: any type
</dl>

<dt><i>Return value</i>

<dd>Returns an integer value which is the number of rows in the argument:


<ul>
<li><i>m</i> <tt>x</tt> <i>n</i> matrix: <i>m</i>;

<li>string: number of characters in the string;

<li>array: number of elements in the array;

<li>file: number of columns in the file; (only if opened with <tt>f</tt> format,
see <tt><a href="#fopen">fopen</a></tt>);

<li>other: 0.
</ul>

<dt><i>See also</i>

<dd><tt><a href="#columns">columns</a></tt>, <tt><a href="#sizeof">sizeof</a></tt>

<dt><a href="oxstdexamples.html#columns"><i>Example</i></a>
</dl>


<h2><a name="savemat"></a>savemat</h2>

<pre>savemat(const sname, const ma);
savemat(const sname, const ma, const iFormat);
savemat(const sname, const ma, const asVarNames);
</pre>

<dl><dd>
<dl>
<dt><tt>sname</tt>

<dd>in: string containing a destination file name

<dt><tt>ma</tt>

<dd>in: matrix

<dt><tt>iFormat</tt>

<dd>in: (optional argument)<br>
1: omit the matrix dimensions (.mat file only);<br>
1: save in universal v96 format (.fmt file only)

<dt><tt>asVarNames</tt>

<dd>in: (optional argument)<br>
array of strings with names for data columns
</dl>

<dt><i>Return value</i>

<dd>Returns 0 if the operation failed, 1 otherwise.

<dt><i>Description</i>

<dd>The type of file saved depends on the extension of the file name:


<ul>
<li><tt>.mat</tt>: matrix file (text file),

<li><tt>.dat</tt>: data file (text file) with load information,

<li><tt>.in7</tt>: PcGive 7 data file (with corresponding <tt>.bn7</tt>
file),

<li><tt>.xlsx</tt>: Excel 2007 workbook file (Office Open xml),

<li><tt>.xls</tt>: Excel version 2.1 spread sheet file,

<li><tt>.csv</tt>: comma-separated spread sheet file (text file),
<p>
<i>Warning: Excel may write csv files with only single precision (9 significant
digits, rather than the 17 that are needed for loss-less saving).
</i>
<li><tt>.fmt</tt>: Gauss matrix file: extended v89 (default) or universal v96,

<li><tt>.dta</tt>: Stata 11 data file (version 114),

<li><tt>.dht</tt>: Gauss data file: extended v89, with corresponding <tt>.dat</tt> file,

<li>any other: as <tt>.mat</tt> file.
</ul>

<dt><i>See also</i>

<dd><tt>Database</tt> class, <tt><a href="#loadmat">loadmat</a></tt>

<dt><a href="oxstdexamples.html#loadmat"><i>Example</i></a>
</dl>


<h2><a name="scan"></a>scan</h2>

<pre>scan(const a, ...);
</pre>

<dl><dd>
<dl>
<dt><tt>a</tt>

<dd>in: any type

<dt><tt>...</tt>

<dd>in: any type
</dl>

<dt><i>Return value</i>

<dd>Returns the number of arguments successfully scanned and assigned.


<dt><i>Description</i>

<dd>This function works as <tt><a href="#fscan">fscan</a></tt>, but reading from the console,
not a file. Any text in the scanning string which is not an input is <i>echoed
to the console</i> (this is different from the standard C <tt>scanf</tt>
function).

<dt><i>See also</i>

<dd><tt><a href="#fscan">fscan</a></tt>, <tt><a href="#fwrite">fwrite</a></tt>, <tt><a href="#sscan">sscan</a></tt>

<dt><a href="oxstdexamples.html#scan"><i>Example</i></a>
</dl>

<h2>
<a name="selectc"></a>selectc,
<a name="selectr"></a>selectr,
<a name="selectifc"></a>selectifc,
<a name="selectifr"></a>selectifr,
<a name="selectrc"></a>selectrc
</h2>

<pre>selectc(const ma);
selectc(const ma, const mval);
selectr(const ma);
selectr(const ma, const mval);
selectifc(const ma, const mifc);
selectifr(const ma, const mifr);
selectrc(const ma, const mr, const mc);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>   <dd> in: <i>m</i> <tt>x</tt> <i>n</i> matrix to select from
<dt><tt>mval</tt> <dd> in: <i>p</i> <tt>x</tt> <i>q</i> matrix with values to use for selection
<dt><tt>mifc</tt> <dd> in: <i>p</i> <tt>x</tt> <i>n</i> boolean matrix specifying columns to select
<dt><tt>mifr</tt> <dd> in: <i>m</i> <tt>x</tt> <i>q</i> boolean matrix specifying rows to select
<dt><tt>mc</tt>   <dd> in: <i>p</i> <tt>x</tt> <i>n</i> matrix with indices of columns to select
<dt><tt>mr</tt>   <dd> in: <i>m</i> <tt>x</tt> <i>q</i> matrix with indices of rows to select
</dl>

<dt><i>Return value</i>
<dd>The <tt>selectc</tt> function with one argument returns an <i>m</i> <tt>x</tt> <i>s</i>
matrix, selecting columns from <tt>ma</tt> which have a missing value (NaN: not a number).

<dd>The <tt>selectr</tt> function with one argument returns an <i>s</i> <tt>x</tt> <i>n</i>
matrix, selecting rows from <tt>ma</tt> which have a missing value (NaN).

<dd>The remaining forms expect matrices without missing values.

<dd>The <tt>selectc</tt> function with two arguments returns an <i>m</i> <tt>x</tt> <i>s</i> matrix,
selecting the columns from <tt>ma</tt> which have at least one element equal to
an element in the matrix <tt>mval</tt>.

<dd>The <tt>selectr</tt> function with two arguments returns an <i>s</i> <tt>x</tt> <i>n</i> matrix,
selecting the rows from <tt>ma</tt> which have at least one element equal to
an element in the matrix <tt>mval</tt>.

<dd>The selectif functions can be used to select rows or columns
based on a logical expression: all rows (columns) wich have a
zero in the corresponding row (column) are dropped.

<dd>The <tt>selectifc</tt> function returns an <i>m</i> <tt>x</tt> <i>s</i> matrix,
selecting only those columns from <tt>ma</tt> which have at least one non-zero
element in the corresponding column of <tt>mifc</tt>.

<dd>The <tt>selectifr</tt> function returns an <i>s</i> <tt>x</tt> <i>n</i> matrix,
selecting only those rows from <tt>ma</tt> which have at least one non-zero
element in the corresponding row of <tt>mifr</tt>.

<dd>The <tt>selectrc</tt> function returns a <i>1</i> <tt>x</tt>
max(<i>pn</i>,<i>mq</i>) matrix, which holds the selected elements.
If an index is outside the matrix bounds of <tt>ma</tt>
the corresponding element in the return value is NaN.


<dd>All functions return an empty matrix if the selection is empty.

<dt><i>See also</i>
<dd>
<tt><a href="#deletec">deletec</a></tt>,
<tt><a href="#deleter">deleter</a></tt>,
<tt><a href="#deleteifc">deleteifc</a></tt>,
<tt><a href="#deleteifr">deleteifr</a></tt>,
<tt><a href="#isdotnan">isdotnan</a></tt>,
<tt><a href="#vecindex">vecindex</a></tt>

<dt><a href="oxstdexamples.html#selectrc"><i>Example</i></a>
</dl>


<h2>
<a name="setbounds"></a>setbounds
</h2>

<pre>setbounds(const ma, const dlo, const dhi);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>

<dd>in: <i>m</i> <tt>x</tt> <i>n</i> matrix

<dt><tt>dlo</tt>

<dd>in: scalar, lower bound (may be <tt>-.Inf</tt>)

<dt><tt>dhi</tt>

<dd>in: scalar, upper bound (may be <tt>+.Inf</tt>)
</dl>

<dt><i>Return value</i>

<dd>
Returns the specified matrix, replacing values smaller than <tt>dlo</tt>
by <tt>dlo</tt> and values greater that <tt>dhi</tt> by <tt>dhi</tt>.
Missing values remain missing.

<dt><a href="oxstdexamples.html#setbounds"><i>Example</i></a>
</dl>


<h2>
<a name="setdiagonal"></a>setdiagonal,
<a name="setlower"></a>setlower,
<a name="setupper"></a>setupper
</h2>

<pre>setdiagonal(const ma, const mdiag);
setlower(const ma, const ml);
setupper(const ma, const mu);
setlower(const ma, const ml, const mdiag);
setupper(const ma, const mu, const mdiag);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>

<dd>in: <i>m</i> <tt>x</tt> <i>n</i> matrix

<dt><tt>mdiag</tt>

<dd>in: 1 by min(<i>m</i>,<i>n</i>) or min(<i>m</i>,<i>n</i>) by 1 or matrix
<i>m</i> <tt>x</tt> <i>n</i> matrix or scalar

<dt><tt>ml</tt>

<dd>in: scalar, or <i>m</i> <tt>x</tt> <i>n</i> matrix, or vector, with new strict lower
diagonal

<dt><tt>mu</tt>

<dd>in: scalar or <i>m</i> <tt>x</tt> <i>n</i> matrix with new strict upper
diagonal
</dl>

<dt><i>Return value</i>

<dd><tt>setdiagonal</tt> returns a matrix with the diagonal replaced by
<tt>mdiag</tt>, which is either a vector with the new diagonal elements,
or a matrix from which the diagonal is copied. If <tt>mdiag</tt> is scalar,
all diagonal elements of the returned matrix have that value.

<p><tt>setlower</tt>
returns <tt>ma</tt> with the strict lower diagonal replaced by that of
<tt>ml</tt>. If <tt>ml</tt> is a scalar, each element is set to that value.
If <tt>ml</tt> is a row or column vector, 
the strict lower diagonal is set column-wise to elements of the vector (until the vector
runs out).
<br>
<tt>setlower(ma, ml, mdiag)</tt> corresponds to <tt>setdiagonal(
setlower(ma, ml), mdiag)</tt>.

<p><tt>setupper</tt> returns <tt>ma</tt> with
the strict upper diagonal replaced by that of <tt>ml</tt>.
If <tt>ml</tt> is a scalar, each element is set to that value.
<br>
<tt>setupper(ma,
ml, mdiag)</tt> corresponds to <tt>setdiagonal( setupper(ma, ml), mdiag)</tt>.


<dt><i>See also</i>

<dd><tt><a href="#diag">diag</a></tt>, <tt><a href="#diagonal">diagonal</a></tt>, <tt><a href="#diagonalize">diagonalize</a></tt>, <tt><a href="#lower">lower</a></tt>,
<tt><a href="#upper">upper</a></tt>

<dt><a href="oxstdexamples.html#setdiagonal"><i>Example</i></a>
</dl>


<h2><a name="shape"></a>shape</h2>

<pre>shape(const ma, const r, const c);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>

<dd>in: arithmetic type

<dt><tt>r</tt>

<dd>in: int

<dt><tt>c</tt>

<dd>in: int
</dl>

<dt><i>Return value</i>

<dd>Returns an <tt>r</tt> by <tt>c</tt> matrix, filled by column from
vec(<tt>ma</tt>). If there are fewer than <tt>rc</tt> elements in <tt>ma</tt>,
the value 0 is used for padding.

<dt><i>See also</i>

<dd><tt><a href="#reshape">reshape</a></tt>, <tt><a href="#vec">vec</a></tt>

<dt><a href="oxstdexamples.html#shape"><i>Example</i></a>
</dl>


<h2>
<a name="sin"></a>sin,
<a name="sinh"></a>sinh
</h2>

<pre>sin(const ma);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>

<dd>in: arithmetic type
</dl>

<dt><i>Return value</i>

<dd><tt>sin</tt> returns the sine of <tt>ma</tt>, of double or matrix
type.

<p><tt>sinh</tt> returns the sine hyperbolicus of <tt>ma</tt>, of double
or matrix type.

<dt><i>See also</i>

<dd><tt><a href="#acos">acos</a></tt>, <tt><a href="#asin">asin</a></tt>, <tt><a href="#atan">atan</a></tt>, <tt><a href="#cos">cos</a></tt>, <tt><a href="#cosh">cosh</a></tt>,
<tt><a href="#sinh">sinh</a></tt>, <tt><a href="#tan">tan</a></tt>, <tt><a href="#tanh">tanh</a></tt>
</dl>


<h2><a name="sizec"></a>sizec
<a name="sizeof"></a>sizeof
<a name="sizer"></a>sizer
<a name="sizerc"></a>sizerc
</h2>

<pre>sizec(const ma);
sizeof(const ma);
sizer(const ma);
sizerc(const ma);
</pre>

<dl><dd>
<dt><i>Return value</i>

<dd>Returns an integer value which is the number elements in the argument:
<pre>
                   rows/sizeof  columns   sizer  sizec  sizerc
int, double             0          0        1      1       1
m x n matrix            m          n        m      n      mn
string, length c        c          c        1      c       c
array, length c         c          c        1      c       c
file (f format)         r          c        r      c      rc
</pre>

<dd><tt><a href="#columns">columns</a></tt>, <tt><a href="#rows">rows</a></tt>

<dt><a href="oxstdexamples.html#sizec"><i>Example</i></a>
</dl>


<h2><a name="solveldl"></a>solveldl</h2>

<pre>solveldl(const ml, const md, const mb);
</pre>

<dl><dd>
<dl>
<dt><tt>ml</tt>

<dd>in: <i>m</i> <tt>x</tt> <i>m</i> lower diagonal matrix <i>L</i>, <i>LDL</i>'=<i>A</i>


<dt><tt>md</tt>

<dd>in: 1 <tt>x</tt> <i>m</i> matrix with reciprocals of <i>D</i>

<dt><tt>mb</tt>

<dd>in: <i>m</i> <tt>x</tt> <i>n</i> matrix <i>B</i>, the right-hand side

</dl>

<dt><i>Return value</i>

<dd>Returns the <i>m</i> <tt>x</tt> <i>n</i> matrix <i>X</i> from solving
<i>AX</i>=<i>B</i>.

<dt><i>See also</i>

<dd><tt><a href="#decldl">decldl</a></tt>, <tt><a href="#invertsym">invertsym</a></tt>

<dt><a href="oxstdexamples.html#decldl"><i>Example</i></a>
</dl>


<h2><a name="solveldlband"></a>solveldlband</h2>

<pre>solveldlband(const ml, const md, const mb);
</pre>

<dl><dd>
<dl>
<dt><tt>ml</tt>

<dd>in: <i>p</i> <tt>x</tt> <i>n</i> vector specifying the <i>L<sup>b</sup></i>
matrix

<dt><tt>md</tt>

<dd>in: 1 <tt>x</tt> <i>m</i> matrix with reciprocals of <i>D</i>
or empty matrix (see below).

<dt><tt>mb</tt>

<dd>in: <i>m</i> <tt>x</tt> <i>n</i> matrix <i>B</i>, the right-hand side

</dl>

<dt><i>Return value</i>

<dd>Returns the <i>m</i> <tt>x</tt> <i>n</i> matrix <i>X</i> from solving
<i>AX</i>=<i>B</i>.<p>
If <tt>md</tt> is the empty matrix, the return value is
the <i>m</i> <tt>x</tt> <i>n</i> matrix <i>X</i>=invert(<i>L</i>)<i>B</i>.

<dt><i>See also</i>

<dd><tt><a href="#decldlband">decldlband</a></tt>, <tt><a href="#solvetoeplitz">solvetoeplitz</a></tt>

<dt><a href="oxstdexamples.html#decldlband"><i>Example</i></a>
</dl>


<h2><a name="solvelu"></a>solvelu</h2>

<pre>solvelu(const ml, const mu, const mp, const mb);
</pre>

<dl><dd>
<dl>
<dt><tt>ml</tt>

<dd>in: <i>m</i> <tt>x</tt> <i>m</i> lower diagonal matrix <i>L</i>

<dt><tt>mu</tt>

<dd>in: <i>m</i> <tt>x</tt> <i>m</i> upper diagonal matrix <i>U</i>

<dt><tt>mp</tt>

<dd>in: 2 <tt>x</tt> <i>m</i> matrix with interchange permutations in the
second row

<dt><tt>mb</tt>

<dd>in: <i>m</i> <tt>x</tt> <i>n</i> matrix <i>B</i>, the right-hand side

</dl>

<dt><i>Return value</i>

<dd>Returns the <i>m</i> <tt>x</tt> <i>n</i> matrix <i>X</i> from solving
<i>AX</i>=<i>B</i>.

<dt><i>Description</i>

<dd>
Solves <i>AX</i>=<i>B</i> for <i>X</i> following a LU decomposition
of <i>A</i>.

This function may be used to only do the forward or backward
substitution part:
<dd><tt>solvelu(L, 0, 0, B)</tt>  solves <i>LX</i>=<i>B</i>,
<dd><tt>solvelu(0, U, 0, B)</tt>  solves <i>UX</i>=<i>B</i>.
So can be used to invert a triangular matrix.


<dt><i>See also</i>

<dd><tt><a href="#declu">declu</a></tt>, <tt><a href="#invert">invert</a></tt>

<dt><a href="oxstdexamples.html#declu"><i>Example</i></a>
</dl>


<h2><a name="solvetoeplitz"></a>solvetoeplitz</h2>

<pre>solvetoeplitz(const mr, const cm, const mb);
solvetoeplitz(const mr, const cm, const mb, alogdet);
</pre>

<dl><dd>
<dl>
<dt><tt>mr</tt>

<dd>in: double, or <i>r</i> <tt>x</tt> 1 or 1 <tt>x</tt> <i>r</i> matrix,
specifying the symmetric positive definite (band) Toeplitz matrix

<dt><tt>cm</tt>

<dd>in: dimension of complete Toeplitz matrix: <i>m</i> <tt>x</tt> <i>m</i>,
<i>m</i> &gt;= <i>r</i>

<dt><tt>mb</tt>

<dd>in: <i>m</i> <tt>x</tt> <i>n</i> matrix <i>B</i>, the right-hand side


<dt><tt>alogdet</tt>

<dd>in: (optional argument) address of variable

<dd>out: double, the <i>logarithm</i> of (the absolute value of) the determinant
of <i>A</i>
</dl>

<dt><i>Return value</i>

<dd>Returns the <i>m</i> <tt>x</tt> <i>n</i> matrix <i>X</i> from solving
<i>AX</i>=<i>B</i>, or 0 if the Toeplitz matrix is singular.

<dt><i>See also</i>

<dd><tt><a href="#pacf">pacf</a></tt>,
<tt><a href="#toeplitz">toeplitz</a></tt>

<dt><a href="oxstdexamples.html#solvetoeplitz"><i>Example</i></a>
</dl>


<h2>
<a name="sortbyc"></a>sortbyc,
<a name="sortbyr"></a>sortbyr
</h2>

<pre>sortbyc(const ma, const icol);
sortbyr(const ma, const irow);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>

<dd>in: matrix

<dt><tt>icol</tt>

<dd>in: scalar: index of column to sort, or matrix: specifying
the columns to sort by.

<dt><tt>irow</tt>

<dd>in: index of row to sort
</dl>

<dt><i>Return value</i>

<dd>The reordered (sorted in ascending order) matrix.

<dt><i>See also</i>

<dd><tt><a href="#reversec">reversec</a></tt>, <tt><a href="#reverser">reverser</a></tt>, <tt><a href="#sortc">sortc</a></tt>, <tt><a href="#sortr">sortr</a></tt>

<dt><a href="oxstdexamples.html#sortbyc"><i>Example</i></a>
</dl>


<h2>
<a name="sortc"></a>sortc,
<a name="sortcindex"></a>sortcindex,
<a name="sortr"></a>sortr
</h2>

<pre>sortc(const ma);
sortr(const ma);
sortcindex(const mb);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>
<dd>in: matrix, array or string

<dt><tt>mb</tt>
<dd>in: row vector, column vector, array or string
</dl>

<dt><i>Return value</i>

<dd>If <tt>ma</tt> is a matrix, the return value is <tt>ma</tt> with each
column (<tt>sortc</tt>) or row (<tt>sortr</tt>) sorted in ascending order.
If <tt>ma</tt> is scalar the return type and value are that of <tt>ma</tt>.
<br>
If <tt>ma</tt> is an array of strings, the strings are sorted in
increasing order (all non-string entries are pushed to the end,
and will be in reverse order). If <tt>ma</tt> is a string, the string is
returned unchanged.
<p>
<tt>sortcindex</tt> returns a column vector with the sorted
index which results from applying <tt>sortc(mb)</tt>
(so <tt>v[sortcindex(v)]</tt> equals <tt>sortc(v)</tt>).
A matrix argument to
<tt>sortcindex</tt> must be a column vector or a row vector
(the transpose is used in the latter case, so <tt>sortcindex(v)</tt>
and <tt>sortcindex(v')</tt> are the same).
<p>

Applying <tt>sortcindex</tt> twice, as in <tt>sortcindex(sortcindex(v))</tt>,
returns the ranking.

<br>

<dt><i>See also</i>

<dd><tt><a href="#sortbyc">sortbyc</a></tt>, <tt><a href="#sortbyr">sortbyr</a></tt>

<dt><a href="oxstdexamples.html#sortc"><i>Example</i></a>
</dl>



<h2><a name="spline"></a>spline</h2>

<pre>spline(const my, const mx, const alpha);
spline(const my, const mx, const alpha, agcv);
</pre>

<dl><dd>
<dl>
<dt><tt>my</tt>

<dd>in: <i>T</i> <tt>x</tt> <i>n</i> matrix with variables (observations
in columns) to smooth

<dt><tt>mx</tt>

<dd>in: 0 for evenly spaced <i>Y</i>, else <i>T</i> <tt>x</tt>
<i>m</i> matrix with <i>X</i> (where <i>m</i>=1: same <i>X</i> used for
all <i>Y</i>s, or <i>m</i>=<i>n</i>: corresponding <i>X</i> is used with
<i>Y</i>)

<dt><tt>alpha</tt>

<dd>in: double, bandwidth, 0: automatic bandwidth selection
using GCV, &lt;0: absolute value is bandwidth,
&gt;0: specifies equivalent number of parameters.

<dt><tt>agcv</tt>

<dd>in: (optional) address, returns GCV (generalized cross validation score)
and equivalent number of parameters
</dl>

<dt><i>Return value</i>

<dd>Returns a <i>T</i> <tt>x</tt> <i>n</i> matrix with the smooth from
applying the natural cubic spline. The optional <tt>agcv</tt> argument
is a 2 <tt>x</tt> <i>n</i> matrix, with the generalized cross validation
(GCV) score in the first row, and the equivalent number of parameters in
the second.

<dt><a href="oxstdexamples.html#spline"><i>Example</i></a>
</dl>


<h2><a name="sprint"></a>sprint</h2>

<pre>sprint(const a, ...);
</pre>

<dl><dd>
<dl>
<dt><tt>a</tt>

<dd>in: any type

<dt><tt>...</tt>

<dd>in: any type
</dl>

<dt><i>Return value</i>

<dd>Returns a string containing the written text, or 0 if the sprint buffer
was too small (see <tt><a href="#sprintbuffer">sprintbuffer</a></tt>).

<dt><i>Description</i>

<dd>Each argument is printed to a string. See <tt><a href="#print">print</a></tt> for a description
of formatting.
There is a maximum text length: this is documented under  <tt><a href="#sprintbuffer">sprintbuffer</a></tt>.

<dt><i>See also</i>

<dd><tt><a href="#eprint">eprint</a></tt>, <tt><a href="#print">print</a></tt>, <tt><a href="#sprintbuffer">sprintbuffer</a></tt>

<dt><a href="oxstdexamples.html#sprint"><i>Example</i></a>
</dl>


<h2><a name="sprintbuffer"></a>sprintbuffer</h2>

<pre>sprintbuffer(const len);
</pre>

<dl><dd>
<dl>
<dt><tt>len</tt>

<dd>in: int
</dl>

<dt><i>Return value</i>

<dd>Returns 0 of type int.

<dt><i>Description</i>

<dd>Sets the size of the internal sprint buffer. The default is 16 * 1024 characters,
and this function is only needed if a larger buffer is needed for <tt><a href="#sprint">sprint</a></tt>.

<dt><i>See also</i>

<dd><tt><a href="#sprint">sprint</a></tt>
</dl>


<h2>
<a name="sqr"></a>sqr,
<a name="sqrt"></a>sqrt
</h2>

<pre>sqr(const ma);
sqrt(const ma);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>

<dd>in: arithmetic type
</dl>

<dt><i>Return value</i>

<dd><tt>sqrt</tt> returns the square root of the elements of <tt>ma</tt>,
of double or matrix type.

<p><tt>sqr</tt> returns the square of the elements
of <tt>ma</tt>. If the input to <tt>sqr</tt> is a double or matrix, the
return type is a double or matrix. If the input is an integer, the return
type is integer unless the result would overflow in integer computation.
In that case the return type is double in order to represent the result.

<dt><i>See also</i>

<dd><tt><a href="#pow">pow</a></tt>,
<tt><a href="oxsyntax.html#ox_syntax_power">^ .^</a></tt>

<dt><a href="oxstdexamples.html#sqr"><i>Example</i></a>
</dl>


<h2><a name="sscan"></a>sscan</h2>

<pre>sscan(const string, const a, ...);
sscan(const astring, const a, ...);
</pre>

<dl><dd>
<dl>
<dt><tt>string</tt>

<dd>in: string to scan from

<dt><tt>astring</tt>

<dd>in: address of string to scan from, on return the scanned text has
been removed from the string

<dt><tt>a</tt>

<dd>in: any type

<dt><tt>...</tt>

<dd>in: any type
</dl>

<dt><i>Return value</i>

<dd>Returns the number of arguments successfully scanned and assigned.
If <tt>s</tt> is a string, then <tt>sscan(s, ...)</tt> will leave the string
unchanged, whereas <tt>sscan(&amp;s, ...)</tt> will remove the read characters
from the string. Returns -1 when at the end of the string.

<dt><i>Description</i>

<dd>This function works as <tt><a href="#fscan">fscan</a></tt>, but reading from a string,
not a file. See <tt><a href="#fscan">fscan</a></tt> for a description of formatting;
the <tt>"%#m"</tt> and <tt>"%#M"</tt>
formats may not be used in <tt><a href="#sscan">sscan</a></tt>.

<dt><i>See also</i>

<dd><tt><a href="#fscan">fscan</a></tt>, <tt><a href="#fwrite">fwrite</a></tt>, <tt><a href="#scan">scan</a></tt>

<dt><a href="oxstdexamples.html#sscan"><i>Example</i></a>
</dl>


<h2><a name="standardize"></a>standardize</h2>

<pre>standardize(const ma);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>

<dd>in: <i>T</i> <tt>x</tt> <i>n</i> matrix <i>A</i>
</dl>

<dt><i>Return value</i>

<dd>Returns a <i>T</i> <tt>x</tt> <i>n</i> matrix holding the standardized
columns of <tt>ma</tt>. If any variance is &lt;= 1e-20, then the corresponding
column is set to 0.

<dt><i>See also</i>

<dd><tt><a href="#meanc">meanc</a></tt>, <tt><a href="#meanr">meanr</a></tt>,
<tt><a href="#varc">varc</a></tt>, <tt><a href="#varr">varr</a></tt>, <tt><a href="#variance">variance</a></tt>

<dt><a href="oxstdexamples.html#correlation"><i>Example</i></a>
</dl>


<h2><a name="string"></a>string</h2>

<pre>string(const ma);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>

<dd>in: arithmetic type
</dl>

<dt><i>Return value</i>

<dd>Casts the argument to a string, see
<a href="oxsyntax.html#ox_syntax_RefCast">explicit type conversion</a>.

<dt><i>See also</i>

<dd><tt><a href="#double">double</a></tt>
</dl>


<h2>
<a name="strfind"></a>strfind,
<a name="strfindr"></a>strfindr,
<a name="strifind"></a>strifind
<a name="strifindr"></a>strifindr
</h2>

<pre>strfind(const where, const what);
strfindr(const where, const what);
strifind(const where, const what);
strifindr(const where, const what);
</pre>

<dl><dd>
<table border="2" cellpadding="4" cellspacing="2">
<tr><td><tt>where</tt></td><td><tt>what</tt></td><td>return type</td></tr>
<tr><td>array of strings</td><td>array of <i>c</i> string</td><td>1 <tt>x</tt> <i>c</i> matrix with indices of occurrence (-1 if not found)</td></tr>
<tr><td>array of strings</td><td>string</td><td>int: index of occurrence of string <tt>what</tt>, or -1 if not found</td></tr>
<tr><td>string</td><td>string</td><td>int: index of occurrence of substring <tt>what</tt>, or -1 if not found</td></tr>
<tr><td>string</td><td><i>r</i> <tt>x</tt> <i>c</i> matrix with character values</td><td>1 <tt>x</tt> <i>rc</i> matrix with indices of occurrence (-1 if not found)</td></tr>
<tr><td>string</td><td>character</td><td>int: index of occurrence of character <tt>what</tt>, or -1 if not found</td></tr>
</table>

<table border="2" cellpadding="4" cellspacing="2">
<tr><td><tt>strfind  </tt></td><td>case sensitive search</td></tr>
<tr><td><tt>strifind </tt></td><td>case insensitive search</td></tr>
<tr><td><tt>strfindr </tt></td><td>case sensitive reverse search</td></tr>
<tr><td><tt>strifindr</tt></td><td>case insensitive reverse search</td></tr>
</table>

<dt><a href="oxstdexamples.html#strfind"><i>Example</i></a>
</dl>


<h2>
<a name="strlwr"></a>strlwr,
<a name="strtrim"></a>strtrim,
<a name="strupr"></a>strupr
</h2>

<pre>strlwr(const s);
strtrim(const s);
strupr(const s);
</pre>

<dl><dd>
<dl>
<dt><tt>s</tt>

<dd>in: the strings to convert
</dl>

<dt><i>Return value</i>

<dd>Returns a copy of the string, which is converted to lower case (<tt>strlwr</tt>)
or uppercase (<tt>strupr</tt>). <tt>strtrim</tt> returns the string with
leading and trailing white space removed.

<dt><a href="oxstdexamples.html#strlwr"><i>Example</i></a>
</dl>


<h2><a name="submat"></a>submat</h2>

<pre>submat(const ma, const r1, const r2, const c1, const c2);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>

<dd>in: matrix

<dt><tt>r1</tt>,<tt>r2</tt>

<dd>in: int

<dt><tt>c1</tt>,<tt>c2</tt>

<dd>in: int
</dl>

<dt><i>Return value</i>

<dd>Returns the submatrix of <tt>ma</tt> from row indices <tt>r1</tt>
to <tt>r2</tt> and column indices <tt>c1</tt> to <tt>c2</tt>. This is equivalent
to <tt>ma[r1:r2][c1:c2]</tt>.

<dt><i>See also</i>

<dd><tt><a href="#submat">submat</a></tt>, <tt><a href="oxsyntax.html#ox_syntax_idx">[]</a></tt>
</dl>


<h2>
<a name="sumc"></a>sumc,
<a name="sumr"></a>sumr
</h2>

<pre>sumc(const ma);
sumr(const ma);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>

<dd>in: <i>T</i> <tt>x</tt> <i>n</i> matrix <i>A</i>
</dl>

<dt><i>Return value</i>

<dd>The <tt>sumc</tt> function returns a 1 <tt>x</tt> <i>n</i> matrix
<tt>r</tt> which holds the sum of the column elements of <tt>ma</tt>.

<p>The
<tt>sumr</tt> function returns a <i>T</i> <tt>x</tt> 1 matrix which holds
the sum of the row elements of <tt>ma</tt>.

<dt><i>See also</i>

<dd><tt><a href="#meanc">meanc</a></tt>, <tt><a href="#meanr">meanr</a></tt>, <tt><a href="#prodc">prodc</a></tt>, <tt><a href="#prodr">prodr</a></tt>, <tt><a href="#sumsqrc">sumsqrc</a></tt>,
<tt><a href="#sumsqrr">sumsqrr</a></tt>, <tt><a href="#varc">varc</a></tt>, <tt><a href="#varr">varr</a></tt>

<dt><a href="oxstdexamples.html#sumc"><i>Example</i></a>
</dl>


<h2>
<a name="sumsqrc"></a>sumsqrc,
<a name="sumsqrr"></a>sumsqrr
</h2>

<pre>sumsqrc(const ma);
sumsqrr(const ma);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>

<dd>in: <i>T</i> <tt>x</tt> <i>n</i> matrix <i>A</i>
</dl>

<dt><i>Return value</i>

<dd>The <tt>sumsqrc</tt> function returns a 1 <tt>x</tt> <i>n</i> matrix
<tt>r</tt> which holds the sum of the squares of the column elements of
<tt>ma</tt>.

<p>The <tt>sumsqrr</tt> function returns a <i>T</i> <tt>x</tt>
1 matrix which holds the sum of the squares of the row elements of <tt>ma</tt>.

<dt><i>See also</i>

<dd><tt><a href="#sumc">sumc</a></tt>, <tt><a href="#sumr">sumr</a></tt>, <tt><a href="#varc">varc</a></tt>, <tt><a href="#varr">varr</a></tt>

<dt><a href="oxstdexamples.html#sumc"><i>Example</i></a>
</dl>


<h2><a name="systemcall"></a>systemcall</h2>

<pre>systemcall(const s);
</pre>

<dl><dd>
<dl>
<dt><tt>s</tt>

<dd>in: string with system command
</dl>

<dt><i>Return value</i>

<dd>
Performs a operating system call, and waits for the call to finish.
Returns the exit code from the system call.
<p>
For example, <tt>systemcall("dir")</tt> lists
the directory under Windows, while <tt>systemcall("ls")</tt> does this under Linux.
The output of the command is echoed to the standard output console.


<dt><i>See also</i>

<dd><tt><a href="#chdir">chdir</a></tt>, <tt><a href="#getcwd">getcwd</a></tt>,
<tt><a href="#getenv">getenv</a></tt>
</dl>


<h2>
<a name="tailchi"></a>tailchi,
<a name="tailf"></a>tailf,
<a name="tailn"></a>tailn,
<a name="tailt"></a>tailt
</h2>

<pre>
tailchi(const ma, const df);
tailf(const ma, const df1, const df2);
tailn(const ma);
tailt(const ma, const idf);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>

<dd>in: arithmetic type

<dt><tt>df</tt>

<dd>in: arithmetic type, degrees of freedom

<dt><tt>df1</tt>

<dd>in: arithmetic type, degrees of freedom in the numerator

<dt><tt>df2</tt>

<dd>in: arithmetic type, degrees of freedom in the denominator

<dt><tt>idf</tt>

<dd>in: int, degrees of freedom
</dl>

<dt><i>Return value</i>

<dd>Returns the requested tail probabilities at <tt>ma</tt> (the returned
tail probabilities are between zero and one):

<ul>
<li><tt>tailchi</tt>: tail probabilities from chi<sup>2</sup>(df) distribution,


<li><tt>tailf</tt>: tail probabilities from F(df1, df2) distribution,

<li><tt>tailn</tt>: one-sided standard normal tail probability,

<li><tt>tailt</tt>: one-sided tail probabilities from student-t(df) distribution.

</ul>

<p>The tail probabilities are accurate to about 10 digits.

The return type is derived as follows:

<ul>
<li><i>m</i> <tt>x</tt> <i>n</i> matrix, when <tt>ma</tt> is an <i>m</i>
<tt>x</tt> <i>n</i> matrix, and the rest is scalar (int for <tt>tailt</tt>);


<li><i>m</i> <tt>x</tt> <i>n</i> matrix, when <tt>ma</tt> is a scalar,
and the rest are <i>m</i> <tt>x</tt> <i>n</i> matrices;

<li><i>m</i> <tt>x</tt> <i>n</i> matrix, when <tt>ma</tt> is an <i>m</i>
<tt>x</tt> <i>n</i> matrix, and the rest are <i>m</i> <tt>x</tt> <i>n</i>
matrices;

<li>double, when <tt>ma</tt> is scalar, and the rest is also scalar (int
for <tt>tailt</tt>).
</ul>

<dt><i>See also</i>

<dd><tt><a href="#denschi">dens...</a></tt>, <tt><a href="#probchi">prob...</a></tt>, <tt><a href="#quanchi">quan...</a></tt>

<dt><a href="oxstdexamples.html#tailchi"><i>Example</i></a>
</dl>


<h2>
<a name="tan"></a>tan,
<a name="tanh"></a>tanh
</h2>

<pre>tan(const ma);
tanh(const ma);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>

<dd>in: arithmetic type
</dl>

<dt><i>Return value</i>

<dd><tt>tan</tt> returns the tangent of <tt>ma</tt>, of double or matrix
type.

<p><tt>tanh</tt> returns the tangent hyperbolicus of <tt>ma</tt>, of
double or matrix type.

<dt><i>See also</i>

<dd><tt>
<a href="#acos">acos</a></tt>, <tt><a href="#asin">asin</a></tt>, <tt><a href="#atan">atan</a></tt>, <tt><a href="#cos">cos</a></tt>, <tt><a href="#cosh">cosh</a></tt>,
<tt><a href="#sin">sin</a></tt>, <tt><a href="#sinh">sinh</a></tt>, <tt><a href="#tanh">tanh</a></tt>
</dl>


<h2>
<a name="thinc"></a>thinc,
<a name="thinr"></a>thinr
</h2>

<pre>thinc(const ma, const c);
thinr(const ma, const r);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>

<dd>in: <i>m</i> <tt>x</tt> <i>n</i> matrix <i>A</i>

<dt><tt>c</tt>

<dd>in: int, desired number of columns to extract

<dt><tt>r</tt>

<dd>in: int, desired number of rows to extract
</dl>

<dt><i>Return value</i>

<dd>The <tt>thinc</tt> function returns an <i>m</i> by <tt>c</tt> matrix
consisting of a selection of columns of the original matrix.

The <tt>thinr</tt>
function returns an <tt>r</tt> by <i>n</i> matrix consisting of a selection
of rows of the original matrix.

<dt><i>See also</i>

<dd><tt><a href="#aggregatec">aggregatec</a></tt>, <tt><a href="#aggregater">aggregater</a></tt>

<dt><a href="oxstdexamples.html#thinc"><i>Example</i></a>
</dl>


<h2><a name="time"></a>time</h2>

<pre>time();
</pre>

<dl><dd>
<dt><i>Return value</i>

<dd>A string holding the current time.

<dt><i>See also</i>

<dd><tt><a href="#date">date</a></tt>

<dt><a href="oxstdexamples.html#date"><i>Example</i></a>
</dl>


<h2><a name="timeofday"></a>timeofday</h2>

<pre>timeofday();
timeofday(const index);
timeofday(const hours, const minutes);
timeofday(const hours, const minutes, const seconds);
timeofday(const hours, const minutes, const seconds, const hundreds);
</pre>

<dl><dd>
<dl>
<dt><tt>index</tt>

<dd>in: arithmetic type, calendar index of a certain date with fractional time

<dt><tt>hours</tt>

<dd>in: arithmetic type, hours on 24-hour clock

<dt><tt>minutes</tt>

<dd>in: arithmetic type, minutes

<dt><tt>seconds</tt>

<dd>in: arithmetic type, seconds

<dt><tt>hundreds</tt>

<dd>in: arithmetic type, hundreds
</dl>

<dt><i>Return value</i>

<dd>
The <tt>timeofday</tt> function without any arguments returns the 
fraction of the calendar index representing the current time.
<p>
The <tt>timeofday</tt> function with two or more arguments returns the
fraction of the calendar index of the specified
time (see below).
If all arguments are an integer, the return value will be an integer.
<p>
The <tt>timeofday</tt> function with one argument takes a calendar index (or vector of indices),
as argument,
returning a <i>n</i> <tt>x</tt> matrix with the quadruplet
hours, minutes, seconds, hundreds in each row
(<i>n</i> is the number of elements in the input).

<dt><i>Description</i>

<dd>
The calendar index is the Julian day number, with an optional fractional
part to specifies the fraction of the day: 2453402.75 corresponds to
2005-01-01T18:00. If the day number is zero, it is interpreted as a
time only, so 0.75 is just 18:00 (6 PM).

The <tt>"%C"</tt> print format is available to print or scan a calendar index.

<dt><i>See also</i>

<dd><tt><a href="#dayofcalendar">dayofcalendar</a></tt>,
<tt><a href="#print">print</a></tt>, <tt><a href="#timing">timing</a></tt>

<dt><a href="oxstdexamples.html#timeofday"><i>Example</i></a>
</dl>


<h2>
<a name="timer"></a>timer,
<a name="timespan"></a>timespan
</h2>

<pre>timer();
timespan(const time);
timespan(const time, const time0);
</pre>

<dl><dd>
<dl>
<dt><tt>time</tt>

<dd>in: double, value from previous call to <tt>timer</tt>

<dt><tt>time0</tt>

<dd>in: double, (optional argument) start time
</dl>

<dt><i>Return value</i>

<dd>The <tt>timer</tt> function returns a double representing the current
time in one 100th of a second. (Under Windows this is the elapsed
time since the process started; under Linux/Unix, it
is the CPU time used so far, ignoring time taken by other processes.)

<p>The <tt>timespan</tt> function returns a
string holding the time lapsed since the <tt>time</tt> argument.

<p>The <tt>timespan(time, time0)</tt> function returns a
string holding the lapsed time between <tt>time</tt> and <tt>time0</tt>.
Both arguments must be measured in one 100th of a second.

<dt><i>See also</i>

<dd><tt><a href="#today">today</a></tt>

<dt><a href="oxstdexamples.html#timer"><i>Example</i></a>
</dl>



<h2>
<a name="timestr"></a>timestr,
<a name="timing"></a>timing,
<a name="today"></a>today
</h2>

<pre>timestr(const time);
timing(const mdates);
timing(const mtimes, const mode);
today();
</pre>

<dl><dd>
<dl>
<dt><tt>time</tt>

<dd>in: double, date expressed as number of seconds
since 1 January 1970 at 00:00:00 (e.g. a value from <tt>timing</tt>) 

<dt><tt>mdates</tt>

<dd>in: <i>T</i> <tt>x</tt> <i>k</i> matrix with date and time, in order:
year, month, day, hour, minute, second (see below).

<dt><tt>mtimes</tt>

<dd>in: <i>m</i> <tt>x</tt> <i>n</i> matrix with dates expressed in seconds

<dt><tt>mode</tt>

<dd>in: int, 0 (or absent): convert date/time to seconds; 1:
convert seconds to date/time; 2: convert seconds to calendar index as
used in <tt><a href="#dayofcalendar">dayofcalendar</a></tt> and
<tt><a href="#timeofday">timeofday</a></tt>.

</dl>

<dt><i>Return value</i>

<dd>The <tt>timing</tt> function with <tt>mode</tt> 0 (or no mode specified)
converts a <i>T</i> <tt>x</tt> <i>k</i> matrix of year, month, ..., seconds (see below)
to a <i>T</i> <tt>x</tt> 1 vector with the date/time expressed as the
number of seconds since 1 January 1970 at 00:00:00.

<p>The <tt>timing</tt> function with <tt>mode</tt> 1
converts an <i>m</i> <tt>x</tt> <i>n</i> matrix of seconds, returning
an <i>mn</i> <tt>x</tt> 6 matrix with respectively year, month, day, hour, min, sec  
in the columns.

<p>The <tt>timing</tt> function with <tt>mode</tt> 2
converts an <i>m</i> <tt>x</tt> <i>n</i> matrix (or a single double) of seconds to
calendar indices, returning an <i>m</i> <tt>x</tt> <i>n</i> matrix (or a double).

<p>The <tt>timestr</tt> function returns
the date/time expressed as a text string:
<tt>"year-month-day hour:min:sec"</tt>. The time is omitted if it is 00:00:00.

<p>The <tt>today</tt> function returns a double with
the current date/time expressed in seconds.

<dt><i>Description</i>

<dd>
These functions work with time in seconds: the
number of seconds since 1 January 1970 at 00:00:00. This is more restrictive
and less convenient than the calendar index (with fraction for time) that is
used in <tt><a href="#dayofcalendar">dayofcalendar</a></tt> and
<tt><a href="#timeofday">timeofday</a></tt>.

The input matrix for <tt>timing</tt> with <tt>mode</tt> 0 (or no mode specified)
has a specified data and time in
each row, with the columns organized as:
<pre>
column   item    values
0        year    full year (e.g. 1970)
1        month   month in year, 1 ... 12 (e.g. 2 for February)
2        day     day in month, 1 ... 31
3        hour    hour in day, 0 ... 23
4        min     minutes, 0 ... 60
5        sec     seconds, 0 ... 60
</pre>

The actual input matrix may have fewer columns, in which case the
remainder is assumed to be zero.

<dt><i>See also</i>

<dd><tt><a href="#dayofcalendar">dayofcalendar</a></tt>,
<tt><a href="#timeofday">timeofday</a></tt>, <tt><a href="#timer">timer</a></tt>

<dt><a href="oxstdexamples.html#timestr"><i>Example</i></a>
</dl>



<h2><a name="toeplitz"></a>toeplitz</h2>

<pre>toeplitz(const ma);
toeplitz(const ma, const cm);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>

<dd>in: double, or <i>r</i> <tt>x</tt> 1 or 1 <tt>x</tt> <i>r</i> matrix


<dt><tt>cm</tt>

<dd>in: (optional argument) <i>m</i>: dimension of matrix to be created,
<i>m</i> &gt;= <i>r</i>; if the argument is missing, <i>m</i>=<i>r</i>
is used.
</dl>

<dt><i>Return value</i>

<dd>Returns a symmetric Toeplitz matrix.

<dt><i>See also</i>

<dd><tt><a href="#diag">diag</a></tt>, <tt><a href="#solvetoeplitz">solvetoeplitz</a></tt>

<dt><a href="oxstdexamples.html#solvetoeplitz"><i>Example</i></a>
</dl>


<h2><a name="trace"></a>trace</h2>

<pre>trace(const ma);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>

<dd>in: arithmetic type
</dl>

<dt><i>Return value</i>

<dd>Returns the trace of <tt>ma</tt> (the sum of its diagonal elements).
Return type is double.

<dt><i>See also</i>

<dd><tt><a href="#determinant">determinant</a></tt>

<dt><a href="oxstdexamples.html#trace"><i>Example</i></a>
</dl>


<h2>
<a name="trunc"></a>trunc,
<a name="truncf"></a>truncf
</h2>

<pre>trunc(const ma);
truncf(const ma);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>

<dd>in: arithmetic type
</dl>

<dt><i>Return value</i>

<dd><tt>trunc</tt> returns the truncated elements of <tt>ma</tt>, of double
or matrix type.

<p><tt>truncf</tt> is fuzzy truncation.

<dt><i>See also</i>

<dd><tt><a href="#ceil">ceil</a></tt>, <tt><a href="#floor">floor</a></tt>, <tt><a href="#fuzziness">fuzziness</a></tt>, <tt><a href="#round">round</a></tt>,

<dt><a href="oxstdexamples.html#trunc"><i>Example</i></a>
</dl>


<h2>
<a name="union"></a>union,
<a name="unique"></a>unique
</h2>

<pre>union(const ma);
unique(const ma);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>

<dd>in: matrix
<dt><tt>mb</tt>

<dd>in: matrix
</dl>

<dt><i>Return value</i>

<dd><tt>unique</tt> returns the sorted unique elements of <tt>ma</tt> as a row vector.
<br>
<tt>union</tt> returns a row vector with the sorted unique elements of <tt>ma</tt> and <tt>mb</tt> combined.
<p>
Returns an empty matrix if the result is empty.
Missing values are skipped.

<dt><i>See also</i>

<dd><tt><a href="#exclusion">exclusion</a></tt>,
<tt><a href="#intersection">intersection</a></tt>

<dt><a href="oxstdexamples.html#exclusion"><i>Example</i></a>
</dl>


<h2><a name="unit"></a>unit</h2>

<pre>unit(const rc);
unit(const r, const c);
</pre>

<dl><dd>
<dl>
<dt><tt>rc</tt>

<dd>in: int
<dt><tt>r</tt>

<dd>in: int
<dt><tt>c</tt>

<dd>in: int
</dl>

<dt><i>Return value</i>

<dd>Returns an <tt>rc</tt> by <tt>rc</tt> identity matrix (one argument),
or an <tt>r</tt> by <tt>c</tt> matrix with ones on the diagonal (rest zero).

<dt><i>See also</i>

<dd><tt><a href="#constant">constant</a></tt>, <tt><a href="#unit">unit</a></tt>, <tt><a href="#zeros">zeros</a></tt>

<dt><a href="oxstdexamples.html#unit"><i>Example</i></a>
</dl>



<h2><a name="unvech"></a>unvech</h2>

<pre>unvech(const va);
</pre>

<dl><dd>
<dl>
<dt><tt>va</tt>

<dd>in: arithmetic type, (column or row) vector to make into symmetric matrix
</dl>

<dt><i>Return value</i>

<dd>Returns a symmetric matrix, given the vectorized lower diagonal
of a symmetric matrix.

<dt><i>See also</i>

<dd><tt><a href="#vech">vech</a></tt>

<dt><a href="oxstdexamples.html#vech"><i>Example</i></a>
</dl>



<h2><a name="upper"></a>upper</h2>

<pre>upper(const ma);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>

<dd>in: <i>m</i> <tt>x</tt> <i>n</i> matrix
</dl>

<dt><i>Return value</i>

<dd>Returns the upper diagonal (including the diagonal), i.e.
returns a copy of the input matrix with strict lower-diagonal elements set to zero.


<dt><i>See also</i>

<dd><tt><a href="#lower">lower</a></tt>, <tt><a href="#setdiagonal">setdiagonal</a></tt>, <tt><a href="#setlower">setlower</a></tt>, <tt><a href="#setupper">setupper</a></tt>

<dt><a href="oxstdexamples.html#lower"><i>Example</i></a>
</dl>


<h2><a name="va_arglist"></a>va_arglist</h2>

<pre>va_arglist();
</pre>

<dl><dd>
<dt><i>Return value</i>

<dd>Returns an array holding the arguments starting with the first variable
in the variable argument list.

<dt><i>Description</i>

<dd>See <a href="oxsyntax.html#ox_syntax_RefVarArg">variable arguments</a>.

<dt><a href="oxstdexamples.html#va_arglist"><i>Example</i></a>
</dl>


<h2>
<a name="varc"></a>varc,
<a name="varr"></a>varr
</h2>

<pre>varc(const ma);
varr(const ma);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>

<dd>in: <i>T</i> <tt>x</tt> <i>n</i> matrix <i>A</i>
</dl>

<dt><i>Return value</i>

<dd>The <tt>varc</tt> function returns a 1 <tt>x</tt> <i>n</i> matrix
holding the variances of the columns of <tt>ma</tt>.

<p>The <tt>varr</tt>
function returns a <i>T</i> <tt>x</tt> 1 matrix holding the variances of
the rows of <tt>ma</tt>.

<dt><i>See also</i>

<dd><tt><a href="#meanc">meanc</a></tt>, <tt><a href="#meanr">meanr</a></tt>, <tt><a href="#sumc">sumc</a></tt>, <tt><a href="#sumr">sumr</a></tt>, <tt><a href="#variance">variance</a></tt>

<dt><a href="oxstdexamples.html#varc"><i>Example</i></a>
</dl>

<p>

<a name="variance"></a><h2>variance</h2>

<pre>variance(const ma);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>

<dd>in: <i>T</i> <tt>x</tt> <i>n</i> matrix <i>A</i>
</dl>

<dt><i>Return value</i>

<dd>Returns an <i>n</i> <tt>x</tt> <i>n</i> matrix holding variance-covariance
matrix of <tt>ma</tt>.

<dt><i>See also</i>

<dd><tt><a href="#acf">acf</a></tt>, <tt><a href="#correlation">correlation</a></tt>, <tt><a href="#meanc">meanc</a></tt>, <tt><a href="#meanr">meanr</a></tt>,
<tt><a href="#standardize">standardize</a></tt>, <tt><a href="#varc">varc</a></tt>, <tt><a href="#varr">varr</a></tt>

<dt><a href="oxstdexamples.html#variance"><i>Example</i></a>
</dl>


<h2><a name="vec"></a>vec</h2>

<pre>vec(const ma);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>

<dd>in: arithmetic type
</dl>

<dt><i>Return value</i>

<dd>If <tt>ma</tt> is an <i>m</i> <tt>x</tt> <i>n</i> matrix, the return
value is an <i>mn</i> <tt>x</tt> 1 matrix consisting of the stacked columns
of <tt>ma</tt>. If <tt>ma</tt> is scalar, the return value is an 1 <tt>x</tt>
1 matrix consisting of the value <tt>ma</tt>.

<dt><i>See also</i>

<dd><tt><a href="#shape">shape</a></tt>, <tt><a href="#vech">vech</a></tt>, <tt><a href="#vecr">vecr</a></tt>

<dt><a href="oxstdexamples.html#vec"><i>Example</i></a>
</dl>


<h2><a name="vech"></a>vech</h2>

<pre>vech(const ma);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>

<dd>in: arithmetic type
</dl>

<dt><i>Return value</i>

<dd>If <tt>ma</tt> is an <i>m</i> <tt>x</tt> <i>n</i> matrix, the return
value is an (<i>m</i>(<i>m</i>+1)/2 - <i>j</i>(<i>j</i>+1)/2) by 1 matrix,
where <i>j</i> = max(<i>m</i>-<i>n</i>,0), consisting of the stacked columns
of the lower diagonal of <tt>ma</tt>. If <tt>ma</tt> is scalar, the return
value is a 1 <tt>x</tt> 1 matrix consisting of the value <tt>ma</tt>.

<dt><i>See also</i>

<dd><tt><a href="#unvech">unvech</a></tt>, <tt><a href="#vec">vec</a></tt>,
<tt><a href="#vecr">vecr</a></tt>

<dt><a href="oxstdexamples.html#vech"><i>Example</i></a>
</dl>


<h2><a name="vecindex"></a>vecindex</h2>

<pre>vecindex(const ma);
vecindex(const ma, const mfind);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>

<dd>in: matrix

<dt><tt>mfind</tt>

<dd>in: matrix (optional argument)
</dl>

<dt><i>Return value</i>

<dd><tt>vecindex</tt> with 1 argument
returns a <i>p</i> <tt>x</tt> 1 matrix holding the row index of the
non-zero elements of vec(<tt>ma</tt>), where <i>p</i> is the number of
non-zero elements in <tt>ma</tt>. If there is no non-zero element, the
function returns the empty matrix.
A <tt>.NaN</tt> in <tt>ma</tt> is treated as a non-zero.

<dd><tt>vecindex</tt> with 2 arguments
returns a <i>p</i> <tt>x</tt> 1 matrix holding the row indices
of the elements of vec(<tt>ma</tt>), which appear
in vec(<tt>mfind</tt>). If none are found, the function returns the empty
matrix.

<dt><i>Description</i>

<dd>
The one argument version is often used with a boolean expression:

<xmp>
    vecindex(x .< 0 .|| x .== 10)
</xmp>

A scalar second argument locates all indices that have that value:

<xmp>
    vecindex(x, 5)
</xmp>

If the second argument is a matrix, <tt>vecindex</tt> returns the sorted
indices of elements of the first argument that occur in the second. Use <tt><a href="#find">find</a></tt>
instead to determine the location of the elements of one vector in another.

<dt><i>See also</i>

<dd><tt><a href="#find">find</a></tt>, <tt><a href="#shape">shape</a></tt>, <tt><a href="#vec">vec</a></tt>,
<tt><a href="#vecrindex">vecrindex</a></tt>

<dt><a href="oxstdexamples.html#vecindex"><i>Example</i></a>
</dl>


<h2><a name="vecr"></a>vecr</h2>

<pre>vecr(const ma);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>

<dd>in: arithmetic type
</dl>

<dt><i>Return value</i>

<dd>If <tt>ma</tt> is an <i>m</i> <tt>x</tt> <i>n</i> matrix, the return
value is an <i>mn</i> <tt>x</tt> 1 matrix consisting of the stacked transposed rows
of <tt>ma</tt>. If <tt>ma</tt> is scalar, the return value is a 1 <tt>x</tt>
1 matrix consisting of the value <tt>ma</tt>.

<dt><i>See also</i>

<dd><tt><a href="#reshape">reshape</a></tt>, <tt><a href="#vech">vech</a></tt>, <tt><a href="#vec">vec</a></tt>

<dt><a href="oxstdexamples.html#vecr"><i>Example</i></a>
</dl>


<h2><a name="vecrindex"></a>vecrindex</h2>

<pre>vecrindex(const ma);
vecrindex(const ma, const mfind);
vecrindex(const ma, const mfind, const bunique);
</pre>

<dl><dd>
<dl>
<dt><tt>ma</tt>

<dd>in: matrix

<dt><tt>mfind</tt>

<dd>in: matrix (optional argument)

<dt><tt>bunique</tt>

<dd>in: int (optional argument when <tt>mfind</tt> is present)
</dl>

<dt><i>Return value</i>

<dd><tt>vecrindex</tt> with 1 argument
returns a <i>p</i> <tt>x</tt> 1 matrix holding the row index of the
non-zero elements of vecr(<tt>ma</tt>), where <i>p</i> is the number of
non-zero elements in <tt>ma</tt>. If there is no non-zero element, the
function returns the empty matrix.
A <tt>.NaN</tt> in <tt>ma</tt> is treated as a non-zero.

<dd><tt>vecrindex</tt> with 2 arguments
returns a <i>p</i> <tt>x</tt> 1 matrix holding the row indices
of the elements of vecr(<tt>ma</tt>), which appear
in <tt>mfind</tt>.
If none are found, the function returns the empty matrix.

If the optional third argument is <tt>TRUE</tt>, then the return value has at most
the dimension of <tt>vecr(mfind)</tt>; for each element in <tt>vecr(mfind)</tt>
the first occurrence in <tt>ma</tt> is reported (if any). This can be faster
when <tt>ma</tt> is large, and you know that each occurrence occurs only once.

<dt><i>See also</i>

<dd><tt><a href="#find">find</a></tt>, <tt><a href="#vecr">vecr</a></tt>,
<tt><a href="#vecindex">vecindex</a></tt>

<dt><a href="oxstdexamples.html#vecrindex"><i>Example</i></a>
</dl>



<h2><a name="zeros"></a>zeros</h2>

<pre>zeros(const r, const c);
zeros(const ma);
</pre>

<dl><dd>
<dl>
<dt><tt>r</tt>

<dd>in: int

<dt><tt>c</tt>

<dd>in: int

<dt><tt>ma</tt>

<dd>in: matrix
</dl>

<dt><i>Return value</i>

<dd><tt>zeros(r,c)</tt> returns an <tt>r</tt> by <tt>c</tt> matrix filled with zeros.

<dd><tt>zeros(ma)</tt> returns a matrix of the same dimension as <tt>ma</tt>, filled with zeros.

<dt><i>See also</i>

<dd><tt><a href="#nans">nans</a></tt>, <tt><a href="#ones">ones</a></tt>, <tt><a href="#unit">unit</a></tt>, <tt><a href="#zeros">zeros</a></tt>

<dt><a href="oxstdexamples.html#zeros"><i>Example</i></a>
</dl>


<hr><p><b>Ox version 4.08.</b>
&copy; <i><a href="http://www.doornik.com" target="_top">
JA Doornik</a></i>
This file last changed <script type="text/javascript">document.write(document.lastModified);</script>.

</div><!-- /page-frame -->
</body>
</html>
