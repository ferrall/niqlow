/**Start to use <span class="n">DDP</span> by following some examples.

@sortkey AAA

This document illustrates how basic aspects of discrete dynamic programming are handled by <span class="n">DDP</span>.
<details class="aside"><summary>This document uses the HTML <code>details</code> tag ...</summary> So it is best viewed in Safari, Chrome or Opera. In those browsers this material is minimized until you click on the wedge.<p> <code>details</code> is not supported by Firefox or Explorer as of this writing.
</details>


<OL class="contents"> Contents
<LI><a href="#GS0">Design and Solve a simple DDP model of <em>searching for a low purchase price</em>.</a></LI>
<LI><a href="#GS1">Simulate Data and Compute the likelihood for the search problem</a></LI>
<LI><a href="#GS2">Re-design the search model with continuous offers and reservation prices.</a></LI>
<LI><a href="#GS3">Where to go next</a></LI>
</OL>

<OL class="body">

<a name="GS0"><LI>Design and Solve a simple DDP model of <em>searching for a low purchase price</em>.</LI></a>

Here we set up a very simple sequential choice problem.  Then we translate the elements of the model into the terms used in <span class="n">DDP</span>.  Then code that implements the model and solves for optimal decision rules is presented.  The output generated by <span class="n">DDP</span> is shown.

<DT>Files referred to:</DT>
<DD><pre>niqlow/examples/GetStarted.ox
niqlow/examples/GetStartedMain.ox</pre>
To run the program and see results:
<pre>oxl GetStartedMain
</pre></dd>


<DT>Steps to Take From Design to Solution</DT>
<OL class="chaplist">
<LI><a href="#A">Define the model</a></LI>
<LI><a href="#AB">Translate the model into <span="n">DDP</span> terms</a></LI>
<LI><a href="#B">Code the model and apply a solution method to it.</a></LI>
<LI><a href="#C">Run the code and look at the output</a></LI>
</OL>

<OL class="chapter">

<a name="A"><LI>Define The Model</LI></a>
A person must purchase an item. They search, <em>potentially forever</em>, for an acceptably low price.<details class="aside"><summary><em>What does N&oline; mean?</em></summary>N&oline; &equiv; N-1.  So, 5&oline; = 4.  Since counting starts at 0 the larges value is always the number of values minus 1. But putting <q>N-1</q> everywhere is not elegant.<br> For more on notation see <a href="DDP.ox.html#NC">Notation and Conventions</a>. <p></details>
Each period a price $p$ is drawn from a discrete set $\{0,1,2,...,N^-\}$.</p>
Over time, price offers are IID and, for simplicity, each value is equally likely:
$$Prob(p' = z) = P_p(z) = 1/N,  z \in\ \left\{0,...,N^-\right\}.$$
Here p&prime; is the price next period and $P_p()$ is its <em>transition</em>.</p>

While searching the person chooses $a$, where $a=1$ means buy at the offered price and $a=0$ means reject and keep searching. The state variable <var>d</var> indicates whether a decision as been made or not. <var>d=0</var> means still searching, and <var>d=1</var> means a price has been accepted.  The transition for <var>d</var> today to <var>d</var> next period can written:
$$d' = a\quad \Rightarrow\quad P_d(d';a,d) = I\{d'=a\}.$$
And $d=1$ is a terminal value, which means that decision making ends whenever that value is reached. <var>Utility</var> equals realized costs: search costs,  $\lambda > 0$, and the price paid if purchased:
$$U(a,p,d) = -(1-d)[ \lambda + ap ]$$
Future returns are discounted by $\delta<1$.</p>

The Solution: prices above the value of continued search are rejected.
<DD><img src="GetStarted.png"></img></DD>
The red lines indicate discrete price offers.  There is a reservation price but it will generically fall between possible offers. </p>

<a name="AB"><LI>Translate the model into <span class="n">DDP</span> terms</LI></a>

The notation used here uses <span class="n">DDP</span>'s notation for describing a model.  Presuming you are starting with this example this notation is shown here to demonstrate how all aspects of DP problems are part of <span class="n">DDP</span>.</p>

The model's <b>clock</b> is stationary, which is a predefined clock type, <code>InfiniteHorzion</code>. The <b>action</b> vector $\alpha$ contains a single binary `ActionVariable`: $\alpha = (a).$ The offer price is <var>p</var> is an instance (object) of the `SimpleJump` class.
    <details class="aside"><summary>State Variable Classes</summary>To keep track of all aspects of a state variable, including how it evolves, state variables are objects of a particular class.  A class describes both data and methods (functions) that operate on the data.  Further, Ox allows for derived classes and virtual methods, which make it possible to build up a library of different kinds of state variables in <span class="n">DDP</span>.  Many kinds of state variables that appear in the literature are already coded and available to be included in your model.</details>.
The decision-made-already state variable, <var>d</var> is an object of the  <code>`LaggedAction`</code> class.   <code>d=1</code> is in the terminal set, $\overline{\Theta}$.</p>

Because price offers are IID it can be put into the <b>exogenous</b> state vector $\epsilon$ contains one variable, <code>&epsilon; = (p)</code>. Since the transition for <var>d</var> depends the current action it is placed in the <b>endogenous</b> state vector $\theta$, which always contains a time variable as well:  $\theta = (d t)$.<details class="aside"><summary>Why multiple state vectors</summary>To conserve memory and computation, <span class="n">DDP</span> allows the user to put state variables in different vectors that are treated differently.  There are actually two other special state vectors not required in this example, $\eta$ and $\gamma$.</details>
Since the model is stationary, the current time is always <code>t=0</code>.</p>

<b>Utility</b> depends on current state variables, actions and parameters:
<DD>$U(\alpha,\epsilon,\theta) = U( (a), (p), (d) ) $ <code>= -(1-d)*[ lam + a*p ]</code></DD>
Because Ox does not recognize Greek letters, <code>lam</code> &equiv; &lambda;.  Further, multiplication uses <code>*</code>. However, since p, a, and d are <em>objects</em>, the Ox code to implement <var>U()</var> will require more than just referring to the variable in the expression.</p>

<a name="B"><LI>Code the model in <span class="n">DDP</span></LI></a>

<DT>The full DDP source code is in <a href="javascript:popoxcode('../../examples/DDP/GetStarted.ox');">examples/DDP/GetStarted.ox</a>.</DT>
<DT>Declare a class derived from `Bellman` to represent the problem.</DT>
<DD><pre>
 1:   #import "DDP"
 2:   class Search : Bellman {
 3:   		enum{Noff=10}
 4:   		static 	const		decl 	lam = 2.3;
 5:   		static 	     		decl 	p, d, a;
 6:   		static 	Run();
 7:         static  Model();
 8:   		 	    Utility();	
 }
 </pre></DD>
    <details class="aside"><summary>.h and .ox files</summary>Usually the segment code above would appear in a separate header (<code>.h</code> or <code>.oxh</code>) file, but in the source code for this example it simply appears at the top of the <code>.ox</code> file.</details>
<div class="page-break"> </div>
<DL>Line-by-line Description
<DT>1. Import</DT>
    <DD>The Ox code relies on the <span class="n">DDP</span> package, so import the compiled code and header information for it. See <a href="http://www.doornik.com/ox/oxtutlan.html#ox_tutlan_link">Multiple files in Ox</a>.</DD>
<DT>2-8. Class Declaration</DT>
    <DD>A user's DP model is represented by a <code>class</code> (or <code>struct</code>). See <a href="http://www.doornik.com/ox/oxtutlan.html#ox_tutlan_oo">OOP in Ox</a>. The class name is <code>Search</code>. It is <em>derived</em> from an underlying class, <code>`Bellman`</code>.   The code inside <code>{}</code> declares variables (data members) and functions (method members) that are needed to code the model.   Each <q>instance</q> of a <code>Search</code> created while the program executes will represent one point in the state space. Aspects of the model that are shared across points in the state space are stored as <em>static</em> members of the class. Non-static elements are called <em>automatic</em> in Ox, but something is automatic by default unless the tag <code>static</code> appears when it is declared.
    <details><summary>More on static and automatic variables</summary>
    Here is a single class called <code>A</code> with two static members and one automatic member.</a>  Then three new instances (objects) of class <code>A</code> are created using the <code>new</code> operator.
<dd><pre>
class A {
        static decl  a, b;
        decl  c;
}
d = new A();
e = new A();
f = new A();
</pre>
There are now three versions of <code>A.c</code> in memory but still only two locations <code>A.a</code> and <code>A.b</code>.<code><table border="1" width="25%" cellpadding="3"><tr><th colspan="3">A<br> A::a<br> A::b</td></tr><tr><th>d</th><th>e</th><th>f</th></tr><tr><td>d.c</td><td>e.c</td><td>f.c</td></tr></table></code>
Note that <pre>
A::a  &equiv;  d.a  &equiv;  e.a  &equiv;  f.a.
A::b  &equiv;  d.b  &equiv;  e.b  &equiv;  f.b.
d.c !&equiv; e.c !&equiv; f.c
</pre>
However it is referenced, <code>a</code> and <code>b</code> refer to the same place.  On the other hand, each instance of A has a distinct <code>c</code>.  So there are 5 distinct storage locations, two shared and three specific to the instance of A.</dd>
</details>

<DD>3: The number of offers <var>N</var> is an <em>enumeration</em>, a way of storing integer constants that Ox shares with C. </DD>
<DD>4: The parameter $\lambda$ is stored as a static constant (its value is fixed at declaration).  More powerfully it could be represented as an object of the `Parameter` class discussed later.</DD>
<DD>5: Three data members are declared static but variable (their value can change after the object is created).  They store the state variables <var>p</var> and <var>d</var> and the action variable <var>a</var>.</DD>
<div class="page-break"> </div>
<DD>6: A function associated with an object is called a <code>method</code>.  <span class="n">DDP</span> requires two methods.  <details class="aside"><summary>NB:</summary> <span class="n">DDP</span> uses the name <code>Method</code> for the class of DP solution methods.  (Upper and lower case do matter in Ox.) Unfortunately this may cause some confusion.  An attempt in these notes will be made to use "solution method" for dynamic programming method and just "method" when using it to refer to a function that belongs to a class. </details> The methods <code>Run()</code> and <code>Model()</code> are not required, but they help organize the set up and solution of the model. In addition, they are organized to make it easy to build on the basic <code>Search</code> class without having to modify this code (see Get Started With Data).</DD>
<DD>7:  The required  <code>method</code> <code>Utility()</code> cannot be <code>static</code> and must have the name and declaration <code>Utility()</code>.  It returns the one-period payoff.</DD>
</DL>
<div class="page-break"> </div>
<DL>
<DT>Define the required functions for the model</DT><DD><pre>
23:	Search::Utility()  {
24:		return -(1-CV(d))*(lam + CV(p)*CV(a));
25:		}
</pre></DD>
<DD>Utility returns a column of values for feasible actions.  It gets the current value of state variables by sending their objects to the <code>`CV`()</code> function.</DD>
<div class="page-break"> </div>
<DT>Define the code to set up and solve the model</DT><DD><pre>
10:  Search::Run()	{
11:  		Initialize(new Search());
12:         Model();
13:  		CreateSpaces();
14:         VISolve();
15:   }
16:  Search::Model() {
17:  	SetClock(InfiniteHorizon);
18:  	SetDelta(0.99);
19:  	Actions(a = new ActionVariable("a",2));
20:  	EndogenousStates(d = new LaggedAction("d",a));
21:  	d->MakeTerminal(1);	
22:  	ExogenousStates(p = new SimpleJump("p",Noff));
        }
</pre></dd>
</DL>
<div class="page-break"> </div>

<DL>Line-by-line Description
<DT>Set Up and Run the Problem</DT>
    <DD>11. The user's code must call the <code>Initialize()</code> method before setting up or solving the model.
    <details class="aside"><summary>More on <code>Initialize</code></summary>
    `DP::Initialize`() works only on <em>static</em> elements of the model, and these must be set before any instances of the model are created with <code>new</code>.  So it is not possible to put these tasks in the <q>constructor</q> for DP. The user may declare a <code>Initialize()</code> method if they expect the class (<code>Search</code>)  to be used as a base for other derived classes. Then <code>Search::Initialize()</code> would call <code>DP::Initialize()</code> and the prefix will be required to resolve the name.</details>
    The argument sent to <code>Initialize</code> is an object of the model class.  An example of the simplest way to do this is show above: <code>new Search()</code>.  This creates an object of the user's model class, in the example <code>Search</code>.  Initialize will <q>clone</q> this object for each point in the state space of the model.</DD>

    <DD>12:  Code to set up the model must appear after <code>Initialize()</code> and before the <code>CreateSpaces()</code> method is called. This code is contained in <code>Model()</code>.</DD>

<DT>Add elements to the model</DT>

    <DD>17: Every DDP model has a clock. There are several predefined clock types, and the user can create their own if necessary.  <code>InfiniteHorizon</code> is an enumeration like <code>Noff</code> in the file above which <code>`DP::SetClock`()</code> uses to create the right kind of clock. </DD>
    <DD>18: Every DDP model has a discount factor $\delta$.  <code>`DP::SetDelta`()</code> sets its value, which is constant here but could be set to a variable `Parameter`..</DD>
    <DD>19:  The action <var>a</var> is an instance of the `ActionVariable` class.  It is not an ordinary <code>integer</code> as it might be coded in FORTRAN or C.  By making it an instance of a class  <span class="n">DDP</span> can keep track of all the requirements of having a binary choice in the model without making the user do additional programming.  When it is created, the user gives the action a label and says how many different values are feasible for the variable, in this case <code>a.N=2</code>. This happens <em>inside</em> the call to `DP::Actions`(). DDP must know about the action variables in your model.  It cannot peer into the derived <code>Search</code> class and see that a variable <code>a</code> is there and stores an action variable object.  On the other side, action variables cannot insert themselves into your model.  The routine <code>`DP::Actions`()</code> adds the argument(s) sent to it to the model, putting them in the action vector $\alpha$.
    <details class="aside"><summary>Assignments in expressions</summary>
    The fancy bit is that in Ox, like C and other languages, an assignment expression returns a value.  So <code>v=6</code> stores 6 in <code>v</code> <em>and</em> returns 6 as a result.  <code>print(v=6)</code> will print 6.  A subtle point that is further explained in other parts of the documentation is that Ox will return a <em>reference</em> to <code>a</code>. So what `DP::Actions`() stores is a <em>pointer</em> to <code>a</code> not a clone or copy of it.</details></DD>
    <DD>20-21: Like the action, the state variables <var>d</var> and <var>p</var> are not just a place to store an integer nor a spot in a vector. State variables are objects of a class derived from the <code>`StateVariable`</code> class. States require more information than actions to be handled properly.   In the model <var>d</var> tracks the choice made in the previous period.  This kind of state variable appears in many models so a class for that kind of variable is predefined in <span class="n">DDP</span>: the <code>`LaggedAction`</code> class.  The action that <code>d</code> should track is sent as an argument when a <code>new</code> object of the class is created.
    <details class="aside"><summary>Derived Classes</summary>Actually, this class is a great-great-granddaughter of `StateVariable`, because it is derived from the `LaggedAction` class which is derived from `Lagged` which is derived from `Deterministic` which is derived from <code>StateVariable</code>.  Indeed, <code>d</code> and <code>a</code> are fourth cousins, because states and actions are both derived from an underlying `Discrete` class.</details>
    The method `DP::EndogenousStates`() adds the arguments sent to it to the $\theta$ vector. Recall that <code>d=1</code> is a terminal state.  <span class="n">DDP</span> must know this so that the value of reaching that state is taken from its utility not iterated on using Bellman's equation.  <code>MakeTerminal()</code> is a  <code>StateVariable</code> method that can take either an integer or a vector of integer values as its argument.  <code>d->MakeTerminal(1)</code> would not work if <var>d</var> had not be assigned a state variable in the previous line.</DD>

    <DD>22: The state variable <var>p</var> takes on one of <var>p.N</var> different values with equal probability. In <span class="n">DDP</span> this is a <code>`SimpleJump`</code> state variable.  Since its transition  does not depend on the current state or actions, <span class="n">DDP</span> can be told this an <em>exogenous</em> state variable, reducing memory and computations.   </DD>

<DT>Create the DP environment</DT>
    <DD>13: After <code>Model()</code> is complete we return to line 13.  All elements have been created and added to the model, the user's code calls <code>CreateSpaces()</code>.  <code>CreateSpaces()</code> uses all the information available about elements added to the model to create the state space, the feasible Action sets and many other aspects of the problem.  To conserve memory requirements and computational time <span class="n">DDP</span> does not create separate points for the exogenous elements of the state space (here <var>p</var>). It treats these separately and <q>attaches</q> values related to the exogenous states to the points in the endogenous state space, $\Theta$.</DD>

<DT>Solve the Model (and more)</DT>
    <DD>The DP model is separate from methods to solve it or use it in some way, including simulation and parameter estimation.  Solution methods are derived from the `Method` class, which itself is derived from the `Task` class.  Tasks are coded to go through the state space and do something at each point.  Tasks share the <code>static</code> aspects of the user's model, but they do not have the <code>automatic</code> variables that are specific to each point.  </dd>
    <DD>14:  However, all those details can be left to <span class="n">DDP</span> by calling the function `VISolve`().  This routine creates an object of the  `ValueIteration` solution type and calls its `ValueIteration::Solve`() method to compute the solution to Bellman's equation for <code>MyModel</code>.  It also calls `DPDebug::outAllV`() so that a summary of the solution is printed to the screen. </DD>
    <DD>`ValueIteration` is the most straightforward method for solving a DP model is iteration on Bellman's equation, either until convergence with an infinite horizon or backwards from the final decision period in a finite horizon.  Other solution methods could be created as well if more than one method will be used to solve the model (for example, to compare them or one to simulate data and another to use while estimating the model).</DD>
    <DD>Using the `VISolve`() is convenient for testing and illustrating the code.   In most real applications the model will be solved repeatedly to estimate parameters, compare solution methods, conduct policy experiments, etc.  For more control on output and for repeated use it is better for the user to create the `Method` object and call its <code>Solve()</code> routine directly.  One reason is efficiency.  `VISolve`() creates and destroys the value iteration object each time it is called, which would waste computation if it were called repeated.</DD>.
    <DD>Representing solution methods with different classes that are dynamic (do not rely heavily on static data) means that different solution methods can be applied to the same model and compared to each other.</DD>
</DL>

</DL>
<div class="page-break"> </div>

<UL class="ul"><h3>Summary</h3>
<LI>A user DP model is derived from <code>Bellman</code> or another class derived from <code>Bellman</code>. The user code must always call <code>Initialize()</code> for the parent class.</LI>
<LI>Actions and state variables are instances of predefined classes or user-defined classes.  They are added the model using DP methods (functions).</LI>
<LI>Once all elements of the model have been added the user must call <code>CreateSpaces()</code> to set up the state space and other aspects of the model. The user's code must define a function that returns a <code>new</code> instance of their class which is passed to <code>CreateSpaces()</code>, which will call that function for each point in the state space $\Theta$.</LI>
<LI>The user must provide a <code>Utility</code> method and a function.  This replace the <em>virtual</em> method in Bellman of the same name.</LI>
<LI>The model is solved by creating an solution object and calling its `Method::Solve`() function.  The `VISolve`() routine will do all this for you when more control of options and repeated solutions is not needed.</LI>
</UL>

<a name="C"><LI>Run the code and see the output</LI></a>

<DT>The program that implements the simple search model:</DT>
    <DD><details><summary><a href="javascript:popoxcode('../../examples/DDP/GetStarted.ox');">examples/DDP/GetStarted.ox</a>.</summary>
    <pre><object width="75%" height="200" type="text/plain" data="../../examples/DDP/GetStarted.ox" border="1" ><p style="font-size:24pt"></object>
    </pre></details>
    The code in <code>GetStarted.ox</code> does not run on its own.  Like C, Ox needs to find a single routine called <code>main()</code> which is where execution of the program starts.  Often <code>main()</code> is defined in a file on its own.  To run the code from there the <code>#include</code> directive can be used to bring other code into the program.</DD>

<DT>A <code>main()</code> program file to run GetStarted:</DT>
    <DD><details><summary><a href="../../examples/DDP/GetStartedMain.ox">examples/DDP/GetStartedMain.ox</a>.</summary>
    <pre><object width="75%" height="200" type="text/plain" data="../../examples/GetStartedMain.ox" border="1" ><p style="font-size:24pt"></object>
    </pre></details>
    <code>main()</code> does only one thing.  It calls <code>Run()</code> which does all the work. Since <code>Run()</code> is static it can be called without referring to an instance of the class previously created with the <code>new</code> operator. There does not have to be an instance of the class for a static  variable to exist.  In general a user will only call static elements of their model.  The DDP code will create instances of the class to represent states and process them internally.</details>

    <DD>From a command prompt in the examples directory (and assuming  <code>niqlow/include</code> is on the include path)
    <details class="aside"><summary>Include Path?</summary><DD>When your program relies on external code through the use of <code>#include</code> or <code>#import</code> then Ox needs to be able to find the code on the machine.  Computer languages like Ox are designed to look in different places for code so that you do not have to copy everything to the same folder as your program.  The list of places to look for things you include is called the <em>include path</em>.  And Ox calls its list <code>OX7Path</code>, which is an system environmental variable (if that helps explain it).  You can add a folder, such has <code>\Users\Me\Oxpgms</code> to <code>OX7PATH</code> when you run Ox by doing this:
    <pre>oxl -i\Users\Me\Oxpgms myprog
    </pre>
    If you use <code>OxEdit</code> or some other code editing program then you can set it up so folder(s) are added to the include path automatically so you do not have to type it each type. See <a href="http://www.doornik.com/ox/index.html#oxpath">Ox Path</a></dd> </details>
    <pre>oxl GetStartedMain
    </pre></dd>

    <DD><details><summary>Source: <a href="../examples/output/GetStarted.txt">../examples/output/GetStarted.txt</a></summary>
    <object width="75%" height="200" type="text/plain" data="../examples/output/GetStarted.txt" border="1" ></object>
    </pre></details>
    By default DDP prints out information (you can control the amount by setting <code>DP::Volume</code>).  When the spaces are created a summary of the state variables, state spaces, action vectors, and feasible action sets is produced.  The <code>Vprint()</code> routine prints out information for each point in the endogenous state space $\Theta$:  The value of state variables in $\theta$, $EV(\theta)$, and choice probabilities averaging over the exogenous states.  Since EV = -6.26 the searcher will accept any offer with a price below 6.26.  There are 7 such offers, 0 through 6, and each is equally likely.  So the probability that <var>a=1</var> is 7/10 or 0.7.  The rejection probability is 0.3.</DD>

</OL>

<a name="GS1"><LI>Simulate Data and Compute the likelihood for the search problem</LI></a>

<span class="n">DDP</span> knows about data, and it integrates data with solutions of the DP model in different ways.  This an example is shown that discusses some of these elements.</p>

A <a href="Data.ox.html#Outcome">Outcome</a> tracks realizations of a dynamic program including features to account for micro data and maximum likelihood estimation. Unobserved values are accounted for by averaging over their value. a <a href="Data.ox.html#PD">Prediction</a> is like Outcomes except it tracks expected outcomes.  It accounts for integrating over probabilities of states and actions.  It includes features to account for averaged data and GMM estimation. <a href="Variables.ox.html#AuxiliaryValues">Auxiliary Values</a> is a mechanism to track things other than states and action.  Auxiliary values are defined by the user and added to the model.  These are then added to Outcomes and Predictions.</p>

<H3>A small example based on simulated data from the simple search model above</H3>

This example is based on the <code>Search</code> model described at <a href="GetStarted.html#GS0">GetStarted</a>.

<OL class="chapter">

<li>Extending the basic <code>MyModel</code> class</li>

Using a <a href="http://www.doornik.com/ox/oxsyntax.html#ox_syntax_RefDerClass">derived class</a> the simple search model in GetStarted is extended without touching the existing code or copying it to a new file and modifying. The original code is <em>included</em> (or if it had been split into <code>.h</code> and <code>.ox</code> files, <em>imported</em>), and a new class is derived from the <code>Search</code> class.
<DD><pre>
#include "GetStarted.ox"
struct DerivedSearch : Search {
	static decl u, simdata;
	static Run();
	}
</pre></DD>
The <code>DerivedSearch</code> class adds three members for data operations.  The plan is to simulate behaviour of optimal search behaviour and to collect realized utility and indicators for price offers.  `Outcome`s have space to store all realized actions and states, but utility or other functions of the outcome are not tracked automatically.  The new code will track realized utility with an object stored in <code>u</code>. Simulated data are generated and stored as a `OutcomeDataSet ` object, and <code>simdata</code> will be that object. The static <code>Run()</code> procedure will do the new work. All members of the base <code>Search</code> class are inherited and do not need to be declared or defined.</p>

<li>Auxiliary Values</li>

Realized utility is recorded as an `AuxiliaryValue`.  A user may have to define their own new auxiliary value classes, but one of the built-in auxiliary values is <code>RealizedUtility</code>.  Here is the code for it, appearing in <code>AuxiliaryValues.h</code> and the source code <code>AuxiliaryValues.ox</code>:
<pre>
struct RealizedUtility : AuxiliaryValue {
	RealizedUtility();
	virtual Realize(y);
	}

RealizedUtility::RealizedUtility() { 	AuxiliaryValue("U"); 	}

RealizedUtility::Realize(y) {
	v = I::curth->Utility()[I::ialpha];
	}
</pre></DD>
The constructor for an auxiliary variable simply has to call the base constructor and send a label.  (It could do other things of course.) Auxiliary values need to provide a <code>Realize()</code> function. code>Realize</code> will be called only when simulating data (or in econometric estimation that involves matching predicted outcomes).  Its first argument is the realized point in the state space $\theta$).  The second is the current realized outcome $Y$.  This allows the auxiliary variable to access everything else.</p>

Since `AuxiliaryValue` is derived from `Quantity` it has a current member, <code>v</code>.  The job of <code>Realize()</code> is to set <code>v</code> for other aspects of the code to use.  In this case, the auxiliary outcome calls <code>Utility()</code> and extracts the element of the vector returned that corresponds to the realized action.  By using a virtual method <code>Realize</code>, the base <span class="n">DDP</span> code can update your auxiliary variables for you without knowing ahead of time what those variables are. Also note that an auxiliary value can be sent to `CV`() after the call to <code>Realize()</code>.  For example, here <code>CV(u)</code> will return the realized value of utility of the current outcome.   So it is straightforward to build auxiliary variables into econometric objectives, equilibrium conditions, etc. (Besides <code>Realize()</code>, auxiliary values include a virtual <code>`AuxiliaryValue::Likelihood`()</code> method.  This is called when computing `Panel::Loglikelihood`().</p>

<li>Modified Run()</li>

<code>DerivedSearch</code> relies on the base <code>Run()</code> routine discussed in <a href="GetStarted.html">GetStarted</a>.  All it has to do is create the auxiliary variable and then create a specialized data set object:
<dd><pre>
DerivedSearch::Run()	{
	Search::Run();
	AuxiliaryOutcomes(u = new RealizedUtility());
    simdata = new SearchData();
	}
</pre></dd>

<li>DataSet Objects</li>
    <DT>A data set can be simulated or read into <span class="n">DDP</span> using the base `OutcomeDataSet` class, but it can be convenient to create a derived class to do the work.</DT>
    <DD><pre>
struct SearchData : DataSet {
	enum{N=15,MaxOb=20}
    SearchData();
    }
</pre></DD>
<DD>We have stored the size of the simulation we want to run: the enumerated values <code>N</code> and <code>MaxOb</code> will be used in <code>SearchData()</code>.  Fifteen searchers will be simulated for up to 20 price draws.</DD>

<DT>The creator function will do the work.</DT>
<DD><pre>
SearchData::SearchData() {
	DataSet("Search Data");
	Simulate(N,MaxOb,0,TRUE); //TRUE censors terminal states
	Print(1);
	Observed(Search::a,UseLabel,Search::p,UseLabel,Search::d,UseLabel,DerivedSearch::u,UseLabel);
	Mask();
	println("Vector of likelihoods when offered price is observed:",exp(EconometricObjective()));
	UnObserved(Search::p);
	Mask();
	println("Vector of likelihoods when offered prices is unobserved:",exp(EconometricObjective()));
	}
</pre></DD>
<DT><code>SearchData</code> first calls its parent creator method.</DT>
    <DD>The first argument is a name to associate with the data set and the solution method to use during simulation or estimation.  Two other arguments can be sent, but in this case they are not needed. In particular, the second argument can be a solution method object so that the dynamic program is solved before the simulation occurs.  (In this case, <code>DataSet("Search Data",meth)</code> where member <code>meth</code> was set by the parent <code>Search</code>. However, since <code>Search::Run()</code> is run first and it has already solved the DP model it would be redundant to solve it again.</DD>

<DT><code>Simulate()</code> generates the simulated sample by applying the conditional choice probabilities and transitions to initial states. </DT>
    <DD>The simulated panel will consist of <code>N</code> paths of the search model, each of maximum length <code>MaxOb</code>.  Since the model has a terminal state, then any path may end before the maximum length.  If there were not terminal conditions then the second argument determines how long each path really is.  The third argument is a matrix of initial state vectors to use in the simulation.  In this case a single state vector is sent.  Since the model is stationary (<code>t=0</code>), and the non-absorbing state happens to be <code>d=0</code>, then sending a vector of zeros is appropriate for initial conditions.  But in other situations this may not be the desired or well-defined initial state.  </DD>
    <DD>The fourth argument being TRUE indicates that when a terminal condition (<code>d=1</code>) is reached that outcome should not be included in the simulated path. The effect is to trim outcomes that are not needed.  Once the agent has accepted a price the process is done.  So the next state with <code>d=1</code> is redundant for estimation purposes.</DD>
    <details  class="aside"><summary>Note:  <code>DataSet</code> class does not have a <code>Simulate()</code> method of its own.</summary>
    Since <code>DataSet</code> is derived from the `Panel` class the command <code>simdata-&gt;Simulate(&hellip;)</code> is equivalent to <code>simdata-&gt;Panel::Simulate(&hellip;)</code>. This also means that the user could have made <code>simdata</code> a Panel object instead, if simulation was all that was required, but the data manipulation coming next require a <code>DataSet</code> object.</details>
    <DT><code>Print(1)</code> constructs a matrix representation of the data set and prints it to the output screen or log file.</DT>
    <DD>A data set is really a multi-leveled linked list of panels, paths, and outcomes.  This makes it possible to write general purpose routines for analyzing the data under various assumptions, such as the likelihood of the panel when some states are unobserved.  The object <code>simdata</code> can be printed out to see all this structure, but a great deal of output is produced which is not particularly helpful.  </DD>

    <DD>`Panel::Print` process the outcomes into a standard matrix representation.If <code>Print()</code> had been sent a file name with a valid extension then the simulated matrix would have been saved to a file (e.g. such as <q>sim.data</q> or <q>search.xls</q>).  <code>Print()</code> calls <code>Flat()</code> to flatten this data structure into a <q>long</q> matrix, one row for each outcome and one column for each element of the full outcome Y* (except for the pointers to other outcomes).  Columns for path id and simulated time are added.  <code>Flat()</code>is itself a recursive task that builds up the matrix by processing fixed panels, paths and outcomes recursively.</dd>

<li>Observability and Masking</li>
    <DT>`OutcomeDataSet::ObservedWithLabel`(), 	`OutcomeDataSet::MatchToColumn`() and 	`OutcomeDataSet::UnObserved`() allow you to control which parts of the outcome is seen in data (and available to econometric methods) and which are missing and require integration over.</DT>
    <DD>By default nothing is observed, so the user must explicitly add variables to the observed list.  State variables that are `Fixed`, are placeholders that take on only one value, so they are implicitly observed.  These are marked as <code>force0</code> so that if reading in from external data the values will be filled in and they do not have to be explicitly observed. `OutcomeDataSet::ObservedWithLabel`() takes one or more action/state/auxiliary objects as arguments.  `Quantity::L` label of the object is the same as the label or name of the column in the data set, which is how the data is matched with the model variable.</dd>
    <DD>`OutcomeDataSet::MatchToColumn`() takes two arguments.  The first is the model variable object.  The second is either a label or the index of the column to match the variable with.</DD>
    <DT>Since the code is working with simulated data, the data set already has the full outcome <code>Y*</code> in memory.  </DT>
    <DD>When reading in external data, the observability of variables is specified <em>ex ante</em> and then the observable data is read in using <code>`OutcomeDataSet::Read`(const filename)</code>.  But here, observability is specified <em>ex post</em>. With simulated data, the user must apply `OutcomeDataSet::Mask`() before sending the data to an econometric method.  When reading in external data the mask is applied internally by `OutcomeDataSet::Read`().</DD>
    <DT>Masking accounts for unobservability using a fairly complex process (which will be documented more completely in later releases.</DT>
    <DD>Essentially missing observations spawn loops over all possible values when processing the outcome.  And the model's probabilistic elements must be used to weight the paths. Further, procedures such as likelihood computation is carried out using backwards recursion not the usual forward recursion.  Unless the DataSet <code>Volume</code> is set to <code>SILENT</code> the masking method will print out a table summarizing the observability of the total outcome.</DD>

<li>Econometric Objective</li>

<DT>DataSet has a virtual method, `OutcomeDataSet::EconometricObjective`().  The default is to compute and return `Panel::LogLikelihood`()</DT>
    <DD>The user can derive their own DataSet class and replace it with an alternative procedure (and other built in objectives, such as GMM, will be provided in later releases). Since it is log-likelihood it is easier to check the <code>exp()</code> in this small example .  As with all <a href="..\FiveO\Objective.ox.html">objectives</a> in  <span class="n">FiveO</span>, it returns a vector of values that an <a href="..\FiveO\Algorithms.ox.html">algorithm</a> will sum up or use directly to compute Jacobians as needed.</DD>

<DT>Once data is masked or read in from an external source the value of any variable that was not marked as observed for force0 is now lost even if it were observed originally.  </DT>
    <DD>So it is not possible to undo <em>un</em>observability within a program and a single data set.  A second data set can be created without different observability and read in from the same source. (And simulated data could be saved using <code>`Panel::Print`(filename)</code> and read into a new data set.) However, it is possible to undo observability, as the next line illustrates.  In the first evaluation of the likelihood the offered price, <em>p</em> was treated as observed.  Now, that mark is undone by sending the variable <code>p</code> to `OutcomeDataSet::UnObserved`() and re-masking the data.  The next likelihood will integrate out the offered price.</DD>
<DT>A note on observing the terminal state <code>d</code>.  </DT>
    <DD>Since the terminal condition <code>d=1</code> was censored from the simulated data all the observations have active searchers.  However, <code>Mask()</code> does not know this so unless <code>d</code> is marked as unobserved. This creates a problem for rejected offer observations (<code>a=0</code>), because that is feasible when <code>d=1</code>.  Thus, the built in log-likelihood will integrate over <code>d=0</code> and <code>d=1</code> when offers are rejected unless <code>d</code> is marked as observed.  The user should remove <code>d,UseLabel</code> from the observed list and see the implications of this change.</DD>

<li>Output</li>

<details><summary>Output produced by running GetStartedData.ox is here:</summary>
    <dd><pre>Source: <a href="javascript:popoxcode('../../examples/output/Get_Started_with_data.txt');">../../examples/output/Get_Started_with_data.txt</a>
    <object width="75%" height="200" type="text/plain" data="../../examples/output/Get_Started_with_data.txt" border="1" ></object>
    </pre></dd></details>
<DT>First, note that the same output is produced as GetStarted.ox, because <code>Search::Run()</code> is called.</DT>
<DT>Next, the simulation is conducted.  Because a `Method` object was passed to the DataSet the value function was solved again, with the same results.</DT>
<DT>As requested, the simulated data is printed as a flat matrix.</DT>
    <DD>The column labeled <code>path</code> is an identifier for the realization, and since 10 were requested the ID goes from 0 to 9. Since the probability of accepting an offer is 0.7, most simulated paths will end after one period (<code>t=0</code>).   Paths 2 and 7 include rejection of high prices in the first period followed by acceptances in the next period.  Also, note that terminating states <code>d=1</code> are excluded as requested.</DD>
    <DD>The final column of the matrix is the realized utility, which is the auxiliary variable.  </DD>

<DT>The observability of variables is summarized next, in three rows for each aspect of Y*.</DT>
    <DD>The program marked <code>a, p, d</code> as observed. Five aspects of the outcome are fixed (only take on the value 0), so <code>force0</code> is equal to 1 for them. Since the data are simulated rather than external, each column index is -1. </DD>

 <DT>When <code>EconometricObjective</code> is called the method is used and the model is again solved (in this case unnecessarily because nothing has changed).</DT>
    <DD>The output of the call is a 10x1 vector of log-likelihoods for each IID outcome: that is, each path.  The exponent is taken before printing it out in order to get back to a probability (in levels). The fact that each likelihood is exactly 1.0 may be unexpected.  But recall, in this simple model there is no continuous shock $\zeta$ and no <em>ex post</em> smoothing of choice probabilities. So the choice probability $P*$ is 1.0 for the optimal choice and 0 otherwise.  Since the data are simulated the optimal choice is always chosen, and <em>since p is treated as observed</em> the likelihood conditions on its value.</DD>
     <DD>If external data were read in that included an inconsistent choice (such as rejecting a price of 2), then the likelihood of that observation would be 0.0.  (As a modern mathematical language, Ox represents <code>log(0)</code> as <em>-&infty;</em>, and <code>exp(-&infty;)</code> as 0.</DD>

 <DT>Next, the observability of <code>p</code> is undone and the objective is computed again.</DT>
    <DD>The model is resolved, again with the same results and in this case unnecessarily. The new observability is summarized.  As noted above, it is not possible to reverse unobservability within a data set, since the observed values are destroyed.  But there is no issue with removing <code>p</code> from the observed list and re-masking the data. Now, with prices as treated as unobserved, the model is probabilistic.  The model's chance that <code>a=0</code> is the probability that realized <code>p&ge;7</code>, or 3/10.  The chance of acceptance is 0.7, and for the 8 paths for which the first offer was accepted this is indeed the computed likelihood.  This demonstrates that <span class="n">niqlow</span> is able to account for unobservability of states (or actions) based on the model set up and the specified information about outcomes, which are treated independently of the model output and the full outcome Y*.</DD>
    <DD>For the two observations where the first price is rejected the likelihood is <em>0.21 = 0.7 &times; 0.3</em>.  This demonstrates that a panel of realizations from a single DP is handled properly.</DD>

</OL>

<a name="#GS2"><LI>Re-design the search model with continuous offers and reservation prices.</LI></a>

<OL class="chapter">
<LI> The model is a continuous version of the <a href="#GS1">model above</a>.</LI>
    <OL class="steps">
    <li class="fragment">Finite time horizon (<code>T=10</code>) to search over job offers</li>
    <li class="fragment">Offers are continuous: &emsp; $z \sim \Phi(x)$.</li>
    <li class="fragment">Wages not prices: &emsp; $U = (1-a)\eta + az$</li>
    <li class="fragment">Optimal choice: a reservation wage <code>z*</code> at each <code>t</code>.<br> That is: <q>policy</q> iteration not <q>value function</q> iteration.</li>
    </OL>
<LI>Optimal Behaviour: accept offers above a reservation value z*.</LI>
<LI>z* solves a non-linear system:</LI><DD><pre>v(1,z*)-v(0,z*)=0</pre></DD>
    <img src="./ContinuousOffers2.png"/>

<LI>Required Information to solve z*</LI>
    <h4>4 functions of <code>z*</code></h4>
    <OL class="steps">
    <LI>Utility differences at any candidate z*:  $U(0,z*)-U(1,z*)$. This information is received by the user-provided method called <code>Uz(z)</code>.  It returns a column vector with <code>U(0,z*)|U(1,z*)|&hellip;</code>. (More generally when there are <code>N</code> choices and <code>N-1</code> cut-off values it should return a <code>N &times; N-1</code> matrix.)</LI>
        &nbsp;</p>
    <LI>Expected utility for <code>a=0</code> given z*: $E[U(0,z)|z\le z*]$.  </LI>&nbsp;</p>
    <LI>Expected utility for <code>a=1</code> given z*: $E[U(1,z)|z\gt z*]$.</LI>&nbsp;</p>
    <LI>Probability of acceptable offers: $Prob(z>z*)$</LI>
    </OL>
    The user provides a method <code>EUtility()</code> which returns an array.  The first element is a vector of expected utility differences.  The second is a vector of probabilities.
<LI>Inputs for solving z*</LI>
    <img src="./ContinuousOffers.png"/>
<LI>Code and Output</LI>
<DT>Header File</DT>
<dd><pre>Source: <a href="javascript:popoxcode('../../examples/misc/WstarTestb.h');">examples/misc/WstarTestb.h</a>
<object width="100%" height="100" type="text/plain" data="../../examples/misc/WstarTestb.h" border="1" ></object></pre></dd>
<DT>Ox File</DT>
<DD><pre>Source: <a href="javascript:popoxcode('../../examples/misc/WstarTestb.ox');">examples/misc/WstarTestb.ox</a>
<object width="100%" height="200" type="text/plain" data="../../examples/misc/WstarTestb.ox" border="1" ></object></pre></dd>
<DT>Output</DT>
<DD><pre>Source: <a href="javascript:popoxcode('../../examples/output/Reservation_Wage_Test.txt');">examples/output/Reservation_Wage_Test.txt</a>
<object width="100%" height="200" type="text/plain" data="../../examples/output/Reservation_Wage_Test.txt" border="1" ></object></pre></dd>

<DT>Graph of Reservation values</DT>
<DD><pre>Source: <a href="../../examples/misc/WstarTestb.pdf">examples/misc/WstarTestb.pdf</a>
<object width="100%" height="200" type="application/pdf" data="../../examples/misc/WstarTestb.pdf"  border="1" >PDF</object></pre></dd>
</OL>

<a name="#GS3"><LI>Where to go next</LI></a>
<DD><a href="../../examples/replications/RustEmet1987mle.ox.html">Rust Emet 1987 mle</a> is an example of using external data.</DD>

<dd>The program <code>/niqlow/examples/main.ox</code> is an interactive program to run examples, test code, and replications.  One of the options is to run <code>GetStarted</code>, <code>GetStartedData</code> and <code>GetStartedRValues</code>. To get started with optimization of non-linear objectives, see <a href="../FiveO/GetStarted.html">FiveO/GetStarted</a>.</dd>

</OL>

**/
