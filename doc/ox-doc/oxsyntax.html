<!DOCTYPE html>
<html>
<head>
<link href='http://fonts.googleapis.com/css?family=PT+Mono|Open+Sans:400italic,700italic,400,700,800,300&subset=latin,latin-ext,greek-ext,greek' rel='stylesheet' type='text/css'></link>
<link rel="stylesheet" type="text/css" href="..\oxdoc.css">
<link rel="stylesheet" type="text/css" media="print" href="..\print.css">
	<meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Ox Syntax Reference</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta name="author" lang="en" content="Jurgen A Doornik">
  <meta name="copyright" content="&copy; Jurgen A Doornik">
  <base target="content-frame">
</head>

<!-- Copyright Jurgen A. Doornik -->
<body>

<h1>Ox Programming</h1>

<p><h2>Chapter contents:</h2><p><p>


<dl>
<dt><a href="#ox_syntax_lex">Lexical conventions</a>
<dd><dl>
<dt><a href="#ox_syntax_comment">Comment</a>
</dl><p>
<dt><a href="#ox_syntax_ident">Identifiers</a>
<dd><dl>
<dt><a href="#ox_syntax_keyword">Keywords</a>
<dt><a href="#ox_syntax_RefConstant">Constants</a>
<dd><dl>
<dt><a href="#ox_syntax_intconst">Integer constants</a>
<dt><a href="#ox_syntax_RefChConst">Character constants</a>
<dt><a href="#ox_syntax_dblconst">Double constants</a>
<dt><a href="#ox_syntax_matconst">Matrix constants</a>
<dt><a href="#ox_syntax_strconst">String constants</a>
<dt><a href="#ox_syntax_arconst">Array constants</a>
</dl><p>
</dl><p>
<dt><a href="#ox_syntax_objects">Objects</a>
<dd><dl>
<dt><a href="#ox_syntax_RefTypes">Types</a>
<dd><dl>
<dt><a href="#ox_syntax_typeconv">Type conversion</a>
</dl><p>
<dt><a href="#ox_syntax_lvalue">Lvalue</a>
<dt><a href="#ox_syntax_scope">Scope</a>
</dl><p>
<dt><a href="#ox_syntax_RefExtDecl">External declarations</a>
<dd><dl>
<dt><a href="#ox_syntax_RefEnum">Enumerations</a>
<dt><a href="#ox_syntax_spec">Storage class specifiers</a>
<dt><a href="#ox_syntax_qualifier">Type qualifiers</a>
<dt><a href="#ox_syntax_RefExtVarDecl">External variable declarations</a>
<dt><a href="#ox_syntax_RefFunctions">Functions</a>
<dd><dl>
<dt><a href="#ox_syntax_RefFuncDecl">Function declarations</a>
<dt><a href="#ox_syntax_funcdef">Function definitions</a>
<dt><a href="#ox_syntax_RefReturn">Returning values</a>
<dt><a href="#ox_syntax_RefDefaultargs">Default values for function arguments</a>
<dt><a href="#ox_syntax_RefVarArg">Variable length argument list</a>
</dl><p>
<dt>
<dt><a href="#ox_syntax_stat">Statements</a>
<dd><dl>
<dt><a href="#ox_syntax_RefSelection">Selection statements</a>
<dt><a href="#ox_syntax_RefSwitch">Switch statements</a>
<dt><a href="#ox_syntax_iter">Iteration statements</a>
<dt><a href="#ox_syntax_Jumpstatements">Jump statements</a>
<dt><a href="#ox_syntax_decl">Declaration statements</a>
<dd>
</dl><p>
<dt><a href="#ox_syntax_exp">Expressions</a>
<dd><dl>
<dt><a href="#ox_syntax_primary">Primary expressions</a>
<dt><a href="#ox_syntax_MultAssign">Multiple assignment</a>
<dt><a href="#ox_syntax_postfix">Postfix expressions</a>
<dd><dl>
<dt><a href="#ox_syntax_memref">Member reference</a>
<dt><a href="#ox_syntax_RefFuncCall">Function calls</a>
<dt><a href="#ox_syntax_RefCast">Explicit type conversion</a>
<dt><a href="#ox_syntax_idx">Indexing vector and array types</a>
<dt><a href="#ox_syntax_postfixinc">Postfix incrementation</a>
<dt><a href="#ox_syntax_RefTranspose">Transpose</a>
</dl><p>
<dt><a href="#ox_syntax_unary">Unary expressions</a>
<dd><dl>
<dt><a href="#ox_syntax_prefix">Prefix incrementation</a>
<dt><a href="#ox_syntax_uminus">Unary minus and plus</a>
<dt><a href="#ox_syntax_neg">Logical negation</a>
<dt><a href="#ox_syntax_address">Address operator</a>
<dt><a href="#ox_syntax_new">New and delete</a>
</dl><p>
<dt><a href="#ox_syntax_power">Power expressions</a>
<dt><a href="#ox_syntax_RefMultExpr">Multiplicative expressions</a>
<dt><a href="#ox_syntax_add">Additive expressions</a>
<dt><a href="#ox_syntax_concat">Concatenation expressions</a>
<dt><a href="#ox_syntax_rel">Relational expressions</a>
<dt><a href="#ox_syntax_RefEqExpr">Equality expressions</a>
<dt><a href="#ox_syntax_dotand">Logical dot-AND expressions</a>
<dt><a href="#ox_syntax_and">Logical-AND expressions</a>
<dt><a href="#ox_syntax_dotor">Logical dot-OR expressions</a>
<dt><a href="#ox_syntax_or">Logical-OR expressions</a>
<dt><a href="#ox_syntax_CondExp">Conditional expression</a>
<dt><a href="#ox_syntax_assign">Assignment expressions</a>
<dt><a href="#ox_syntax_comma">Comma expression</a>
<dt><a href="#ox_syntax_RefConstExp">Constant expressions</a>
</dl><p>
</dl><p>

<p><big>Tables:</big>
<dl>
<dt><a href="#TabSyntax1">Escape sequences</a>
<dt><a href="#TabSyntaxOXPREC">Operator precedence</a>
<dt><a href="#TabSyntaxOXDOTOP">Result from dot operators</a>
<dt><a href="#TabSyntaxOXDOTREL">Result from relational operators</a>
<dt><a href="#TabSyntaxOXOPEMPTY">Result from operators involving an empty matrix as argument</a>
<dt><a href="#TabSyntaxOXMISREL">Result from relational operators involving missing values</a>
</dl><p>

<h3><a name="ox_syntax_comment"></a>Comment</h3><p>
Anything between <tt>/*</tt> and <tt>*/</tt> is considered comment. This comment <em>can</em> be nested (unlike C and C++). Everything following <tt>//</tt> up to the end of the line is also comment, but is ignored inside <tt>/*</tt> ... <tt>*/</tt> type comment. So nested comment is possible:

<xmp>
    one = cons + 1;   // comment
    /* two = cons + 1;   // comment
    */
</xmp>

<h2><a name="ox_syntax_ident"></a>Identifiers</h2>

An "Identifiers are made up of letters and digits. The first character must be a letter. Underscores (_) count as a letter.

<h3><a name="ox_syntax_keyword"></a>Keywords</h3><p>
The following keywords are reserved:

<xmp>
array     default   foreach    operator   static
break     delete    goto       parallel   string
case      do        if         private    struct
char      double    inline     protected  switch
class     else      int        public     switch_single
const     enum      matrix     return     this
continue  extern    namespace  serial     virtual
decl      for       new        short      while
</xmp><p>

<h3><a name="ox_syntax_RefConstant"></a>Constants</h3><p>

<h4><a name="ox_syntax_intconst"></a>Integer constants</h4>

A sequence of digits is an integer constant. 

<h4><a name="ox_syntax_dblconst"></a>Double constants</h4>

A double constant consists of an integer part, a decimal point, a fraction part, an <tt>e</tt>, <tt>E</tt>, <tt>d</tt> or <tt>D</tt> and an optionally signed integer exponent. Either the integer or the fraction part may be missing (not both); either the decimal point or the full exponent may be missing (not both). .

Double constants in an <a href="#ox_syntax_RefExtVarDecl">external declaration</a> may use a dot to represent a missing values. This sets the variable to NaN (Not a Number).

<h4><a name="ox_syntax_matconst"></a>Matrix constants</h4>

A matrix constant lists within <tt>&lt;</tt> and <tt>&gt;</tt> the elements of the matrix, row by row. Each row is delimited by a semicolon, successive elements in a row are separated by a comma. For example:

<xmp>
    < 00, 01, 02; 10, 11, 12 >
    < 0.0, 0.1, 0.2 >
    < 1100 >
</xmp>

which are respectively a 2 by 3 matrix, a 1 by 3 matrix and a 1 by 1  matrix, the first constant is:

<xmp>
00   01   02
10   11   12
</xmp>

The comma is optional, so the first matrix constant may be written as (the semicolon is still required):
<xmp>
    < 00 01 02; 10 11 12 >
</xmp><p>

The index of each row is one higher than the previous row. Within each row, the column index of an element is one higher than that created with the previous element in the same row.

<p>
An <i>integer range</i> may be specified, e.g. <tt>2:5</tt> corresponds to <tt>2,3,4,5</tt>.
The range may decrease, so that <tt>5.3:2.8</tt> corresponds to <tt>5.3,4.3,3.3</tt>.<p>

A <i>stepsize</i> may be specified, as in <tt>2:[2]8</tt>, which gives <tt>2,4,6,8</tt>.<p>

A <i>specific element</i> in the matrix can be set. This overrides the location implicit in the position of the element in the matrix constant. Note that the top left element is <tt>[0][0]</tt>, the second element in
the first row <tt>[0][1]</tt>, etc.<p>

A number of <i>identical elements</i> can be specified, e.g. <tt>[3]*0</tt> corresponds to <tt>0,0,0</tt>. Unspecified elements are set to zero.<p>

As an example involving all types, consider:

<xmp>
    < [4]*1,2; 10,11,14-2; 1:4; [3][4]=99,2; 8:[-3]2 >
</xmp><p>
which corresponds to:
<xmp>
 1    1    1   1   2   0
10   11   12   0   0   0
 1    2    3   4   0   0
 0    0    0   0  99   2
 8    5    2   0   0   0
</xmp><p>

Missing values in a matrix constant could be represented with a dot or <tt>.NaN</tt>, which represents NaN (Not a Number), e.g.:
<xmp>
    < .,2,3; 4,.,6 >
</xmp><p>
Similarly, <tt>.Inf</tt> represents infinity.

An empty matrix can be writen as:
<xmp>
    < >
</xmp><p>


<h4><a name="ox_syntax_strconst"></a>String constants</h4><p>

<p>A string constant is a text enclosed in double quotes, for example: <tt>"tailor"</tt>. Adjacent string
constants are concatenated. A null character is always appended to indicate the end of a string. The maximum length of a string constant is 1024 characters. 

<h4><a name="ox_syntax_arconst"></a>Array constants</h4><p>

<p>An array constant is a list of constants in braces, separated by a comma. This is a recursive definition, because the constant can itself be an array constant. The terminating level consists of non-array constants. Each level of array constants creates an array of references. For example:

<xmp>
    { "tinker", "tailor", "soldier" }
    {{ "tinker", "tailor"}, {"soldier"} }
</xmp><p>

<p><h2><a name="ox_syntax_objects"></a>Objects</h2><p><p>

<h3><a name="ox_syntax_RefTypes"></a>Types</h3><p>

Variables in Ox are <em>implicitly typed</em>, and can change type during their lifetime. The life of a variable corresponds to the level of its declaration. Its scope is the section of the program in which it can be seen. Scope and life do not have to coincide.<p>

There are three basic types and four derived types.

<ul>
<li><i>int</i>: a signed integer.
<li><i>double</i>: double precision floating point type.
<li><i>matrix</i>: a two-dimensional array of doubles which can be manipulated as a whole.
<li><i>string</i>
<li><i>array</i>: an array of references.
<li><i>function</i>
<li><i>class</i>
<li><i>reference to class object</i>
</ul><p>

<h4><a name="ox_syntax_typeconv"></a>Type conversion</h4><p>

<p>When a double is converted to an int, the fractional part is discarded; if the resulting value cannot be represented, the behaviour is undefined. When an int is converted to a double, the nearest representation will be used. For example, conversion to int of 1.3 and 1.7 will be 1 on both
occasions.


<h3><a name="ox_syntax_scope"></a>Scope</h3><p>
Variables declared at the start of a statement block have scope and life restricted to the block. These variables are called <i>automatic</i>: they are created and initialized whenever the block is entered, and removed as soon as the block is exited. 

Variables declared outside any statement block have global scope and life; these are called <i>static</i>.

Note that Ox assignment of arithmetic types and string type implies copying over the contents from the right-hand side to the left-hand side. Automatic variables of any type can be assigned to variables with broader scope.

<p><h2><a name="ox_syntax_RefExtDecl"></a>External declarations</h2><p><p>

An Ox program consists of a sequence of external declarations. These either reserve storage for an object, or serve to inform of the existence of objects created elsewhere. Each program must define one function called <tt>main</tt>, where execution of the program will start. The return value from <tt>main</tt> (if any) is returned to the console window.

<h3><a name="ox_syntax_RefEnum"></a>Enumerations</h3><p>
An enumeration defines a list of integer constants. By default, the first member will have value 0, and each successive member will have a value of one plus that of the previous member. The value of a member can be set by assigning it a constant integer value.

<p>Enumerator names only exist in the file in which they occur. Enumerations should be placed in header files if they need to be shared between several source files.

<p>Here are some examples with corresponding values:

<xmp>
    enum { C_FIRST, C_SECOND, C_THIRD };               // 0,1,2
    enum { T_INT, T_DBL=2, T_STR, T_MAT=C_THIRD };   // 0,2,3,2
    enum { FLAG0,FLAG1, FLAG2=FLAG1*2, FLAG3=FLAG2*2};//0,1,2,4
    enum { T_ERR = 1.0 } ;                             // error
</xmp><p>

<h3><a name="ox_syntax_spec"></a>Storage class specifiers</h3><p>
External variable declarations (i.e. declared outside a function) create global variables: such variables exist while the program runs. The <tt>static</tt> specifier restricts the scope of the declared object to
the remainder of the file. Although it will exist throughout the program's life, it cannot be seen from other files. 
<p>
The <tt>extern</tt> specifier informs the remainder of the file that the object can be accessed, although defined (created) in another file. The <tt>extern</tt> and <tt>static</tt> specifiers are mutually exclusive.
External declarations are most conveniently placed in header files.

<h3><a name="ox_syntax_qualifier"></a>Type qualifiers</h3><p>
A <tt>const</tt> object can only be initialized once, and not changed thereafter. The use of <tt>serial</tt> is explained in <a href="#ox_syntax_RefParallel">this section</a>. The <tt>const</tt> and <tt>serial</tt> qualifiers are  mutually exclusive.

<h3><a name="ox_syntax_RefExtVarDecl"></a>External variable declarations</h3><p>
The <tt>static</tt> or <tt>extern</tt> specifier and the <tt>const</tt> qualifier preceding an external variable declaration list applies to all variables in the list. Each identifier creates space for an object with global lifetime, unless declared <tt>extern</tt> or <tt>const</tt>.

<p>A <tt>const</tt> object must be initialized (unless declared <tt>extern</tt>) but its value may not be changed thereafter. Unless declared <tt>extern</tt>, a <tt>const</tt> object cannot be accessed from other files. If of scalar <a href="#ox_syntax_RefTypes">type</a>, a <tt>const</tt> can appear in a constant-expression.

<p>At the external level of declarations, as treated here, it is possible to specify a matrix size, and initialize that matrix to zero. If an external variable is created without explicit value and without
dimensions, it will default to an int with value 0. Here are some examples:

<xmp>
    decl a, b;                  // default to type int, value 0
    enum { AAP, NOOT, MIES, WIM };
    const decl ia = NOOT, ib = NOOT + WIM;         // type: int
    const decl ma = < NOOT, AAP; 0, 1 >;        // type: matrix
    const decl aa = {"tinker", "tailor"};        // type: array
    decl id = ia * (WIM - 1) * MIES + ib;          // type: int
    decl da = ia + 0.;                          // type: double
    decl mb = <0:3; 4:7; 8:11>;                 // type: matrix
    decl ab = { ma, ma};                         // type: array
    extern decl elsewhere;             // defined in other file

    decl mc[3][3] = 1.5;        // 3 x 3 matrix with values 1.5
    static serial decl s_md[2][1];     // 3 x 1 matrix of zeros

    enum { ZUS = id };                // error: id is not const
    decl ih = id;                     // error: id is not const
    decl ia;                          // error: already defined
</xmp><p>

<h3><a name="ox_syntax_RefFunctions"></a>Functions</h3><p>

<h4><a name="ox_syntax_RefFuncDecl"></a>Function declarations</h4><p>
A function declaration communicates the number of arguments and their types to a file, so that the function can be called correctly from that file. The actual creation of the function is done through a function definition (which at the same time declares the function). A function can be declared many times, but type and number of arguments must always be identical:

<xmp>
    test0();                     // function takes no arguments
    test1(const a1);                      // one const argument
    test2(const a2, a3);       // two arguments, first is const
    static test3(a1);       // cannot be used outside this file
    extern test4(a1);     // function defined outside this file
    print(a1, ...);             // variable number of arguments
    test1(a1);     // error: previous declaration was different
</xmp><p>


<h4><a name="ox_syntax_funcdef"></a>Function definitions</h4><p>
A function definition specifies the function header and body, and declares the function so that it can be used in the remainder of the file. A function can be declared many times, but defined only once.
<p>
The use of <tt>const</tt> is recommended: arguments declared <tt>const</tt> can be referenced, but cannot be changed inside the function. If the argument is a <tt>const</tt> reference, the reference cannot be changed, but what it references can. The <tt>decl</tt> keyword is optional in front of an argument. An empty argument list indicates that the function takes no arguments at all. The <tt>...</tt> indicates a variable
number of arguments; it must have the last position in the header, but cannot be the first.

<xmp>
    test1(const a1);                    // declaration of test1
    print(a1, ...);             // variable number of arguments
    test2(const a1, a2)                  // definition of test2
    {
        test1(a2);                       // call function test1
        print(a1, 1, 2, "\n");         // at least one argument
        test1(a2, 1);       // error: wrong number of arguments
        a2 = 1;                            // a2 may be changed
        a1 = 1;                           // error: a1 is const
        /* ... */
    }
</xmp><p>

All function arguments are passed by value. This means that a copy of the actual object is made (although the compiler will avoid this internally if the argument is not assigned to). For int, double, matrix and string types the whole object is copied. Any changes to the copy are lost as soon as the function returns. Derived <a href="#ox_syntax_RefTypes">types</a> are accessed through a reference, and that reference is passed by value. However, what is pointed to may be changed, and that change will remain in effect after function return. So passing references allows a function to make a permanent change to a variable, for examples see <a href="#ox_syntax_RefFuncCall">function calls</a>. It is good practice to label an argument <tt>const</tt> if a function doesn't change the variable.

<h4><a name="ox_syntax_RefReturn"></a>Returning a value</h4><p>

<p>All functions may have a return value, but this return value need not be used by the caller. 
<p>
The <tt>return</tt> statement returns a value from the function, <i>and also exits the function</i>. So, when the program flow reaches a <tt>return</tt> statement, control returns to the caller, without executing the remainder of the function.
<p>
The syntax of the return statement is:<br>
    <tt>return</tt> <i>return_value</i> <tt>;</tt>
<br>
Or, to exit from a function which does not have a return value:<br>
    <tt>return;</tt>

<p>
The following example illustrates the use of <tt>return</tt>:
<xmp>
    threes(const r, const c)                // definition of threes
    {
        return constant(3, r, c);
    }
    otherfunc()
    {
        println(threes(2, 2));
    }
</xmp>



<h4><a name="ox_syntax_RefDefaultargs"></a>Default values for function arguments</h4><p>
<p>

Default values for function arguments can be supplied, subject to the following constraints
<ol>
<li>A default value cannot be replaced by another default.
<li>The value must be within scope when the call is made, so that it can be substituted when compiling.
<li>When a default value is supplied for an argument, all subsequent arguments must have a default value.
</ol>

Default values for member calls and functions that are called as a string are injected at run-time. This is possible, because the default values become a property of the function.

The following example illustrates the use of a default argument:

<xmp>
    #include <oxstd.oxh>
    func(arg=<1,1>);              // forward declaration

    main()
    {
        func();                   // same as func(<1,1>);
    }
    func(arg)                     // definition
    {
        println("func arg=", arg);
    }
</xmp>

<h4><a name="ox_syntax_RefVarArg"></a>Variable length argument list</h4><p>

<p>A special library function <tt>va_arglist()</tt> is used to access arguments in the variable argument list. It returns the arguments supplied for the ellipse as an array. An example illustrates:

<xmp>
    test(const a, ...)
    {
        decl i, args = va_arglist();

        for (i = 0; i < sizeof(args); i++)
            print (" vararg ", i, ": ", args[i]);
    }
    main()
    {
        test("tinker", "tailor", "soldier");
    }
</xmp><p>

which prints <tt>vararg 0: tailor vararg 1: soldier</tt>.

<p><h2><a name="ox_syntax_stat"></a>Statements</h2><p><p>

The executable part of a program consists of a sequence of statements. Expression statements are expressions or function calls. 

<h3><a name="ox_syntax_RefSelection"></a>Selection statements</h3><p>

The conditional expression in an <tt>if</tt> statement is evaluated, and if it evaluates to true (<em>for a matrix: no element evaluates to false</em>), the statement is executed. Zero (0), the empty matrix (<tt>&lt;&gt;</tt>) and a missing value (<tt>.NaN</tt>) all evaluate to false. 
<p>
The conditional expression may not be a declaration statement.
<p>
Some examples for the <tt>if</tt> statement:

<xmp>
    if (i == 0)
        i++;                           // do only if i equals 0

    if (i >= 0)
        i = 1;                             // do only if i >= 0
    else
        i = 0;                           // set negative i to 0

    if (i == 0)
        if (k > 0)
            j = 1;               // do only if i != 0 and k > 0
        else                  // this else matches the inner if
            j = -1;             // do only if i != 0 and k <= 0

    if (i == 0)
    {   if (k > 0)
            j = 1;               // do only if i != 0 and k > 0
    }
    else                      // this else matches the outer if
        j = -1;                            // do only if i != 0
</xmp><p>

Each <tt>else</tt> part matches the closest previous <tt>if</tt>, but this can be changed by using braces. When coding nested <tt>if</tt>s, it is advisable to use braces to make the program more readable and avoid potential mistakes.

<p>Further examples involving matrices are given in <a href="#ox_syntax_RefEqExpr">equality expressions</a>.

<h3><a name="ox_syntax_RefSwitch"></a>Switch statements</h3><p>

A <tt>switch</tt> statement is a compact way of writing a sequence of <tt>if</tt> statements involving the same variable for comparison:

<xmp>
    decl i = 1;
    switch (i)
    {
        case 0:
            println("zero");
            break;
        case 1:
            println("one");
            break;
        default:
            println("not zero, not one");
            break;
    }
</xmp><p>

which prints: "<tt>one</tt>". There is a sequence of <tt>case</tt> blocks, and an optional <tt>default</tt> block, which must be the last. The <tt>break</tt> statement jumps out of the <tt>switch</tt> statement.

Here, the value of <tt>i</tt> is compared to each value in turn, until a comparison is true. Then all the statements for that case <em>and all subsequent cases</em> are executed (including the default) until a <tt>break</tt> is encountered. If no case is true, the default statements are executed. So, once inside a case, we automatically fall through to the next case. The advantage is that several cases can be grouped together:

<xmp>
    switch (i)
    {
        case 0:
            println("zero");
            break;
        case 1:
        case 2:
            println("one,two");
            break;
        default:
            println("default");
            break;
    }
</xmp><p>

printing <tt>one,two</tt> when <tt>i</tt> is 1 or 2.

The drawback is that is easy to forget the <tt>break</tt> statements, and get unexpected results. The following code

<xmp>
    switch (i)
    {
        case 0:
            println("zero");
        case 1:
        case 2:
            println("one or two");
        default:
            println("default");
    }
</xmp><p>

will print when <tt>i</tt> equals zero:

<xmp>
    zero
    one or two
    default
</xmp><p>

To emphasize that distinction, and allow for more readable code, Ox also has the <tt>switch_single</tt> statement. Then, one and only one case (or default) is executed:

<xmp>
    switch_single (i)
    {
        case 0:
            println("zero");
        case 1:
            println("one");
        case 2:
            println("two");
        default:
            println("default");
    }
</xmp><p>

<h3><a name="ox_syntax_iter"></a>Iteration statements</h3><p>

The <tt>while</tt> statement excutes the substatement as long as the test expression is nonzero (for a matrix: all elements are nonzero). The test is performed before the substatement is executed.

<p>The <tt>do</tt> statement executes the substatement, then repeats this as long as the test expression is nonzero (for a matrix: all elements are nonzero). The test is performed after the substatement is executed.
So for the <tt>do</tt> statement the substatement is executed one or more times, whereas for the <tt>while</tt> statement this is zero or more times.

<p>The <tt>for</tt> expression:

<tt>for (</tt><i>init_expr</i><tt>;</tt> <i>test_expr </i><tt>;</tt> <i>increment_expr</i><tt>)</tt>  <i>statement</i>

corresponds to:

<dl>
<dt><tt>{</tt>
<dt>&nbsp;&nbsp;<i>init_expr</i><tt>;</tt>
<dt>&nbsp;&nbsp;<tt>while (</tt><i>test_expr </i><tt>)</tt>
<dt>&nbsp;&nbsp;<tt>{</tt>
<dd>&nbsp;&nbsp;<i>statement</i>
<dd>&nbsp;&nbsp;<i>increment_expr</i><tt>;</tt>
<dt>&nbsp;&nbsp;<tt>}</tt>
<dt><tt>}</tt>
</dl><p>

Note that, when the <i>init_expr</i> is a declaration statement, the declaration is local to the <tt>for</tt> statement.

<p>
The <tt>foreach</tt> expression is used to loop over all elements in a matrix, array or string. The most simple form:

<dl>
<dt>&nbsp;&nbsp;<tt>foreach (</tt><i>element-identifier</i> <tt>in</tt> <i>collection-identifier</i><tt>)</tt>  <i>statement</i>
</dl><p>

implements a loop over all elements in the collection.

The following restrictions apply to the <tt>foreach</tt> loop:
<ul>
<li>The <i>collection-identifier</i> must be an lvalue; it can be an object member, but may not
contain an index, because that would be interpreted as the <i>foreach-index-expression</i>.
<li>The <i>element-identifier</i> and the identifiers in the <i>foreach-index-expression</i>
must be local variables
<li>The dimension of the <i>collection-identifier</i> must be fixed during the loop, but its contents may change.
<li>Assigning to the <i>element-identifier</i> does not change the <i>collection-identifier</i>.
<li>When the loop terminates, the <i>element-identifier</i> is undefined.
</ul>

The <i>foreach-index-expression:</i> part determines how the loop is performed:
<ul>
<li><tt>foreach (el in a)</tt>         --- loop over all elements (matrix, array, string), no access to iterators;
<li><tt>foreach (el in a[i][j])</tt>   --- loop over all elements of a matrix with access to iterators i and j;
<li><tt>foreach (el in a[i][])</tt>    --- loop over all rows i, with access to i;
<li><tt>foreach (el in a[][j])</tt>    --- loop over all columns j, with access to j;
<li><tt>foreach (el in a[i])</tt>      --- loop over all elements i (row/column vector, string or array).
</ul>

<p>
Some examples:
<xmp>
    decl x, m = rann(2,2), i, j;
    // Example 1: print all elements
    foreach (x in m)
        println(x);
    foreach (x in m[i][j])
        println("element ", i, ",", j, ": ", x);
		
    // Example 2: create a Toeplitz matrix
    decl c = zeros(10, 10);
    foreach (x in c[i][j])
        c[i][j] = fabs(i - j) + 1;
		
    // Example 3: print all strings in an array:
    decl a = {"aaa", m, "BBB"}, s;
    foreach (s in a)
        if (isstring(s))
            println(s);
</xmp>

<h3><a name="ox_syntax_Jumpstatements"></a>Jump statements</h3><p>

The <tt>return</tt> statement exits the function; if it is followed by an expression, the value of the expression is returned to the caller, see <a href="#ox_syntax_RefReturn">returning values</a>.

<p>A <tt>continue</tt> statement may only appear within an iteration statement and causes control to pass to the loop-continuation portion of the smallest enclosing iteration statement.

<p>The use of <tt>goto</tt> should be kept to a minimum, but could be useful to jump out of a nested loop, jump to the end of a routine or when converting Fortran code. It is always possible to rewrite the code such that no <tt>goto</tt>s are required.

<p>A <tt>break</tt> statement may only appear within an iteration statement and terminates the smallest enclosing iteration statement.

<p>Two examples:

<xmp>
    for (i = 0; i < 10; i++)
    {
        if (test1(i))
            continue;
        test2();             // only done if test1(i) returns 0
    }
    for (i = 0; i < 10; i++)
    {
        if (test1(i) == 0)
            break;    // jump out of loop if test1(i) returns 0
        test2();
    }
</xmp><p>

<h3><a name="ox_syntax_decl"></a>Declaration statements</h3><p>

Declarations at the <a href="#ox_syntax_RefExtDecl">external level</a> were discussed before. Here we treat declaration within a block.
<p>
Declaration statements create a `local' variable for further manipulation as long as it stays within scope. The created object is removed as soon as the block in which it was created is exited. Variables can be intitialized in a declaration statement. Variables in Ox are implicitly typed, and their type can change during program execution. Non-externally declared variables must be initialized before they can be used in an expression. It is not possible to specify matrix dimension as can be done at the external level, so instead of <tt>decl ma[3][3] = 1.5</tt> write <tt>decl ma = constant(1.5,3,3)</tt>. Unlike C, declaration statements do not have to occur at the start of a block. Consider for example:

<xmp>
    test1(arg0)
    {
        decl k, a = arg0;
        decl ident = <1, 0; 0, 1>;
        decl identsq = ident * ident;

        print("test\n");

        decl i, j;
        for (i = 0; i < 10; i++)
        {
            test2(i);
            test3(j);                  // error: j has no value
        }
</xmp><p>

Variables declared in an inner block hide variables in the outer block.

<h4><a name="ox_syntax_Canonical"></a>Canonical <tt>for</tt> and <tt>foreach</tt> loops</h4><p>

A <tt>for</tt> loop is <i>canonical</i> if:
<ol>
<li> the iterator is a local variable,
<li> the iterator is an integer,
<li> the iterator is not changed in the loop body,
<li> the iterator is incremented (or decremented) by an integer constant,
<li> the upperbound can be computed before the loop starts,

In particular, it is either the value of a variable, or <tt>sizer</tt>, <tt>sizec</tt>, <tt>sizerc</tt>, <tt>sizeof</tt>, <tt>rows</tt>, <tt>columns</tt> of a variable.

<li> the upperbound is fixed while the loop executes,
<li> the loop body is a closed statement list.
</ol>

Except for the last condition, all are automatically satisfied by a <tt>foreach</tt> loop.

Ox can determine whether a <tt>for</tt> or <tt>foreach</tt> loop is canonical, and use compiled code for the iteration aspect, which is more efficient. If you use the <tt>-v</tt> command line switch, a message will indicate if a loop was optimized this way.

<p><h2><a name="ox_syntax_exp"></a>Expressions</h2><p><p>

<dl>
<dt><b>Operator tables:</b>
<dt><a href="#TabSyntaxOXPREC">Operator precedence</a>
<dt><a href="#TabSyntaxOXDOTOP">Result from dot operators</a>
<dt><a href="#TabSyntaxOXDOTREL">Result from relational operators</a>
<dt><a href="#TabSyntaxOXOPEMPTY">Result from operators involving an empty matrix as argument</a>
<dt><a href="#TabSyntaxOXMISREL">Result from relational operators involving missing values</a>
</dl><p>

<h3><a name="TabSyntaxOXPREC"></a>Table syn.2: Operator precedence</h3><p>
<xmp>
Category            operators                     associativity

primary             () :: []                      left to right
postfix             -> . () [] ++ -- '            left to right
power               ^ .^                          left to right
unary               ++ -- + - ! & new delete      right to left
multiplicative      ** * .* / ./                  left to right
additive            + -                           left to right
horizontal concat.  ~                             left to right
vertical concat.    |                             left to right
relational          < > <= >= < > <= >=           left to right
equality            == != .== .!=                 left to right
logical dot-and     .&&                           left to right
logical-and         &&                            left to right
logical dot-or      .||                           left to right
logical-or          ||                            left to right
conditional         ? : .? .:                     right to left
assignment          = *= /= += -= ~= |= .*= ./=   right to left
comma               ,                             left to right
</xmp><p>

Table <a href="#TabSyntaxOXPREC">syn.2</a> gives a summary if the operators available in Ox, together with their precedence (in order of decreasing precedence) and associativity. The precedence is in decreasing order. Operators on the same line have the same precedence, in which case the associativity gives the order of the operators. Note that the order of evaluation of expressions is not fully specified. In:

<xmp>
    i = a() + b();
</xmp><p>
it is unknown whether <tt>a</tt> or <tt>b</tt> is called first.

<a name="ox_syntax_lvalue"></a>
Subsections below give a more comprehensive discussion. Several operators require an <i>lvalue</i>, which is a region of memory to which an assignment can be made. Note that an object which was declared <tt>const</tt> is not an lvalue. Many operators require operands of arithmetic type, that is int, double or matrix.

<p>The most common operators are <em>dot-operators</em> (operating element-by-element) and relational operators (operating element by element, but returning a single boolean value). The resulting value is given Tables <a href="#TabSyntaxOXDOTOP">syn.3</a> and <a href="#TabSyntaxOXDOTREL">syn.4</a> respectively. In addition, there are special matrix operations, such as matrix multiplication and division; the result from these operators is explained below. A scalar consists of: int, double or 1 <tt>x</tt> 1 matrix.

<h3><a name="TabSyntaxOXDOTOP"></a>Table syn.3: Result from dot operators</h3><p>
<xmp>
left  a        op   right b         result         computes

int            op   int             int            a op b
int/double     op   double          double         a op b
double         op   int/double      double         a op b
scalar         op   matrix  m x n   matrix m x n   a op b_{ij}
matrix m x n   op   scalar          matrix m x n   a_{ij} op b
matrix m x n   op   matrix  m x n   matrix m x n   a_{ij} op b_{ij}
matrix m x n   op   matrix  m x 1   matrix m x n   a_{ij} op b_{i0}
matrix m x n   op   matrix  1 x n   matrix m x n   a_{ij} op b_{0j}
matrix m x 1   op   matrix  m x n   matrix m x n   a_{i0} op b_{ij}
matrix 1 x n   op   matrix  m x n   matrix m x n   a_{0j} op b_{ij}
matrix m x 1   op   matrix  1 x n   matrix m x n   a_{i0} op b_{0j}
matrix 1 x n   op   matrix  m x 1   matrix m x n   a_{0j} op b_{i0}
string n       op   string  n       matrix 1 x n   a_{j}  op b_{j}
string n       op   int             matrix 1 x n   a_{j}  op i
int            op   string  n       matrix 1 x n   i      op b_{j}
</xmp><p>


<h3><a name="TabSyntaxOXDOTREL"></a>Table syn.4: Result from relational operators</h3><p>
<xmp>
left  a        op   right b         result   computes

int            op   int             int      a op b
int/double     op   double          int      a op b
double         op   int/double      int      a op b
scalar         op   matrix  m x n   int      a op b_{ij}
matrix m x n   op   scalar          int      a_{ij} op b
matrix m x n   op   matrix  m x n   int      a_{ij} op b_{ij}
matrix m x n   op   matrix  m x 1   int      a_{ij} op b_{i0}
matrix m x n   op   matrix  1 x n   int      a_{ij} op b_{0j}
matrix m x 1   op   matrix  m x n   int      a_{i0} op b_{ij}
matrix 1 x n   op   matrix  m x n   int      a_{0j} op b_{ij}
string         op   string          int      a op b
</xmp><p>

<h3><a name="TabSyntaxOXOPEMPTY"></a>Table syn.5: Result from operators involving an empty matrix as argument</h3><p>
<xmp>
operator        a op <>    <> op b    <> op <>
==               FALSE      FALSE       TRUE
!=               TRUE       TRUE        FALSE
>=               FALSE      FALSE       TRUE
>                FALSE      FALSE       FALSE
<=               FALSE      FALSE       TRUE
<                FALSE      FALSE       FALSE
other             <>         <>          <>
</xmp><p>
<hr>

<h3><a name="TabSyntaxOXMISREL"></a>Table syn.6: Result from relational operators involving missing values</h3><p>
<xmp>
operator   either argument .NaN      both arguments .NaN
==                0                       1
!=                0                       1
>=                0                       1
>                 0                       0
<=                0                       0
<                 1                       0
</xmp><p>
<hr>

<h3><a name="ox_syntax_primary"></a>Primary expressions</h3><p>

An expression in parenthesis is a primary expression. Its main use is to change the order of evaluation, or clarify the expression.

<p>An expression in curly braces creates an array of the comma-separated expressions.

<p>All types of <a href="#ox_syntax_RefConstant">constants</a> form a primary expression.

<p>The operator <tt>::</tt> followed by an identifier references a variable declared <a href="#ox_syntax_RefExtDecl">externally</a>. <a href="#ox_syntax_RefThis">Examples</a> are given. A class name followed by <tt>::</tt> and a <a href="#ox_syntax_RefMemFunc">function member</a> of that class references
a <a href="#ox_syntax_RefMemStatic">static</a> function member, or any function member if preceded by an object reference.

<p>The <tt>this</tt> reference is only available inside non-static class member functions, and points to the object for which the function was called.


<h4><a name="ox_syntax_memref"></a>Member reference</h4><p>

The <tt>-></tt> operator selects a member from an object reference. The left-hand expression must evaluate to a reference to an object, the right-hand expression must result in a member of that object. 


<h4><a name="ox_syntax_RefFuncCall"></a>Function calls</h4><p>

A function call is a postfix expression consisting of the function name, followed in parenthesis by a possibly empty, comma-separated list of assignment expressions. All argument passing is by value, but when an array is passed, its contents may be changed by the function (unless they are <tt>const</tt>). The order of evaluation of the arguments is unspecified; all arguments are evaluated before the function is entered. Recursive function calls are allowed. A function must be declared before it can be called, and the number of arguments in the call must coincide with the number in the <a href="#ox_syntax_RefFuncDecl">declaration</a>, unless the declaration has <tt>...</tt> as the last argument.

<p>Some examples:

<xmp>
    func1(a0, a1, a2, a3)
    {   print("func1(", a0, ",", a1, ",", a2, ",", a3, ")\n");
    }
    func2()
    {   return 0;
    }
    func3(a0)
    {   a0[0] = 1;
    }
    test1()
    {   decl a, b;

        a = 1;
        func1(a, b = 10, func2(), a != 0);   // func1(1,10,0,1)
        a = func2();                                   // a = 0
        func3(&a);                                     // a = 1
        func3(a);                                      // error
    }
</xmp><p>

In the latter example <tt>a</tt> will have been changed by <tt>func3</tt>. Function arguments are passed by giving the name of the function:

<xmp>
    func4(a0, a1)
    {   a1(a0);                           // make function call
    }
    func5(a0)
    {   print("func5(", a0, ")\n");
    }
    test2()
    {   decl a = func5;

        func4(1, func5);                   // prints "func5(1)"
        func4(1, a);                       // prints "func5(1)"
        func4(1, func5(a));         // error: requires function
        func4(1, func2);        // error: func2 takes incorrect
    }                           //          number of arguments
</xmp><p>

Note that the parentheses in <tt>func5()</tt> indicate that it is a function call,
whereas lack of brackets just passes the function itself.

<h4><a name="ox_syntax_idx"></a>Indexing vector and array types</h4><p>

Vector types (that is, string or matrix) and array types are indexed by postfixing square brackets. A matrix can have one or two indexes, a string only one. For an array type it depends on the level of indirection. <em>Note that indexing always starts at zero.</em> So a 2 by 3 matrix has elements:

<xmp>
     [0][0]   [0][1]   [0][2]
     [1][0]   [1][1]   [1][2]
</xmp><p>

Three ways of indexing are distinguished:

<xmp>
indexing type   matrix, string   array    example
scalar               yes          yes     m[0][0]
matrix               yes          yes     m[0][<0,1,2>]
range                yes          yes     m[][1:]
</xmp><p>

In the first indexing case (allowed for all non-scalar types), the expression inside square brackets must have scalar type, whereby double is converted to integer.

<p>Vector types may also be indexed by a matrix or have a range expression inside the brackets. In a matrix index to a string the first <em>column</em> of the matrix specifies the selected elements of the string.

<p>It is possible to use only one index to a matrix. If a matrix <tt>x</tt> is a column or row vector, <tt>x[i]</tt> it will pick the <i>i</i>th element from the vector. If <tt>x</tt> is a matrix, it will treat the matrix as a vector (row by row, which corresponds to the <tt>vecr</tt>).

<p>If a matrix is used as an index to a matrix, then each element (row by row, i.e. the <tt>vecr</tt> of the argument) is used as an index. As a consequence, indexing by a column vector or its transpose (a row vector) has the same effect. A matrix in the first index selects rows, a matrix in the second index selects columns. The resulting matrix is the intersection of those rows and columns.

<p>A range index has the form <i>start-index</i> <tt>:</tt> <i>end-index</i>. Either the start-index or the end-index may be missing, which results in the lower-bound or upper-bound being used respectively. An empty index selects all elements. The resulting type from a range or empty index is always a vector type.

<p>Indexing beyond the end will result in a fatal run-time error. An exception is indexing a string for reference: this can be done one position beyond the end, which returns 0. For example, <tt>i=s[sizeof(s)]</tt> sets <tt>i</tt> to 0.

<p>Some examples:

<xmp>
    decl mat = < 0:3; 10:13 >, d, m;
    decl str = "tinkertailor", s;
    decl arr = { "tinker", "tailor", "soldier" };

                                // mat = <0,1,2,3; 10,11,12,13>
    d = mat[0][0];                                     // d = 0
    d = mat[1][2];                                    // d = 12
    m = mat[1][];                          // m = <10,11,12,13>

    d = m[1];                                       // d = <11>
    d = m'[1];                            // the same: d = <11>
    d = mat[5];                                     // d = <11>

    m = mat[][2];                                // m = <2; 12>
    m = mat[][];                           // same as: m = mat;
    m = mat[0][<1:3>];   // matrix indexes columns: m = <1,2,3>
    m = mat[<1,0,1>][<1,3>];       // m = < 11,13; 1,3; 11,13 >
    mat[0][1:3] = 9;                  // range indexes columns:
                                // mat = <0,9,9,9; 10,11,12,13>
    s = str[6:11];                              // s = "tailor"
    str[6:11] = 'a';                    // str = "tinkeraaaaaa"
    s = arr[1];                                 // s = "tailor"
    arr[1][0] = 'a';                       // arr[1] = "aailor"

</xmp><p>

<h4><a name="ox_syntax_postfixinc"></a>Postfix incrementation</h4><p>

A postfix expression followed by <tt>++</tt> or <tt>--</tt> leads to the value of the expression being evaluated and then incremented or decremented by 1. The operand must be an lvalue and must have arithmetic type. For a matrix the operator is applied to each element separately. The result of the expression is the value prior to the increment/decrement operation.

<h4><a name="ox_syntax_RefTranspose"></a>Transpose</h4><p>

The postfix operator <tt>'</tt> takes the transpose of a matrix. It has no effect on other arithmetic types of operands. Note that the single quote is also used in a character constant; the context avoids any ambiguity:

<xmp>
    mat = m' * a';
    mat = m'a';                       // interpreted as m' * a'
    mat = m'';                             // two '' cancel out
    mat = m + 'a';               // 'a' is a character constant
</xmp><p>

<h3><a name="ox_syntax_power"></a>Power expressions</h3><p>

The operands of the power operator must have arithmetic type, and the result is given in the table. If the first operand is not a matrix .^ and ^ are the same.

<xmp>
left  a      operator  right b        result         computes

int            ^  .^   int or double  int            a^b
int/double     ^  .^   double         double         a^b
double         ^  .^   scalar         double         a^b
scalar         ^  .^   matrix  m x n  matrix m x n   a^{b_{ij}}
matrix m x n   .^      int/scalar     matrix m x n   a_{ij}^b
matrix m x n   .^      matrix  m x n  matrix m x n   a_{ij}^{b_{ij}}
matrix m x m   ^       scalar         matrix m x m   a^int(b)
</xmp><p>

When <i>a</i> and <i>b</i> are integers, then <tt>a ^ b</tt> is an integer if <i>b</i> &gt;= 0 and if the result can be represented as a 32 bit signed integer. If <i>b</i> < 0 and <i>a</i> != 0 or the integer result would lead to overflow, the return type is double, giving the outcome of the floating point power operation.

<p>The first line in the example shows that power has higher precedence than unary minus:

<xmp>
    i = - 2 ^ 2;                                      // i = -4
    decl r, m1 = <1,2; 2,1>, m2 = <2,3; 3,2>;
    r = m1 .^ 3;                                  // <1,8; 8,1>
    r = m1 .^ 3.7;                      // <1,12.996; 12.996,1>
    r =  3 .^ m1;                                 // <3,9; 9,3>
    r =  3 ^  m1;                                 // <3,9; 9,3>
    r = m1 .^ m2;                                 // <1,8; 8,1>
    r = m1 ^  3;                              // <13,14; 14,13>
    r = m1 ^  3.7;                            // <13,14; 14,13>
    r = m1 ^  -3;           // equivalent to: r = (1 / m1) ^ 3;
    r = m1 ^  m2;                                      // error
</xmp><p>

<h3><a name="ox_syntax_unary"></a>Unary expressions</h3><p>

<h4><a name="ox_syntax_prefix"></a>Prefix incrementation</h4><p>

A prefix expression preceded by <tt>++</tt> or <tt>--</tt> leads to the lvalue being incremented or decremented by 1. This new value is the result of the operation. The operand must be an lvalue and must have arithmetic type. For a matrix the operator is applied to each element separately.

<h4><a name="ox_syntax_uminus"></a>Unary minus and plus</h4><p>

The operand of the unary minus operator must have arithmetic type, and the result is the negative of the operand. For a matrix each element is set to its negative. Unary plus is ignored.

<h4><a name="ox_syntax_neg"></a>Logical negation</h4><p>

The operand of the logical negation operator must have arithmetic type, and the result is 1 if the operand is equal to 0 and 0 otherwise. For a matrix, logical negation is applied to each element. Negating a missing value returns 0, and negating an empty matrix returns an empty matrix.

<xmp>
    j = 0;  k = 10;
    i = !j;                                            // i = 1
    i = !k;                                            // i = 0
</xmp><p>

<h4><a name="ox_syntax_address"></a>Address operator</h4><p>

The operand of the address operator <tt>&</tt> must be an lvalue. In addition, it must be an object: it is possible to take the address of a class object, a function, or an array element, but not of a matrix
element. The result is an array of one element, pointing to the region of space occupied
by the lvalue.  Referencing works through arrays; unlike C and C++ (but like the Java programming language),
Ox does not have pointers.

Some examples were in the section on <a href="#ox_syntax_RefFuncCall">function calls</a>.

<h4><a name="ox_syntax_new"></a>New and delete</h4><p>

The <tt>new</tt> operator can be used to create an object of a class, or to create a matrix, string or array. The <tt>delete</tt> operator removes an object created by <tt>new</tt>. Note that matrices, strings and arrays are automatically removed when they go out of scope; this is not the case for objects. A class object, on the other hand, must be removed explicitly using the <tt>delete</tt> operator. If not, it will exist until the program terminates (which may be acceptable).

Only one or two array levels at a time can be created by <tt>new</tt>; however, <tt>delete</tt> removes all sublevels. A string created by <tt>new</tt> consists of null characters, a matrix will have all elements zero. Matrix, string and array objects with dimension zero are allowed (this can be useful to start concatenation
in an iterative loop; remember that an empty matrix constant is <tt>&lt;&gt;</tt>, and an empty array <tt>{}</tt>). Matrices and arrays can be created with either one or two dimensions.

<p>Examples involving objects of <a href="#ox_syntax_RefClasses">classes</a> are given.

<h3><a name="ox_syntax_RefMultExpr"></a>Multiplicative expressions</h3><p>

The operators <tt>**</tt>, <tt>*</tt>, <tt>.*</tt>, <tt>/</tt>, and <tt>./</tt> group left-to-right and require operands of arithmetic type. Strings are not allowed. These operators conform to Table <a href="#TabSyntaxOXDOTOP">syn.3</a>, except for:

<xmp>
left   a     operator  right b        result          computes
matrix m x n    *      matrix  n x p  matrix m x p    a_{i.}b_{.k}
matrix m x n    **     matrix  p x q  matrix mp x nq  a_{ij}b
scalar          *      matrix  n x p  matrix n x p    ab_{ij}
matrix m x n    *      scalar         matrix m x n    a_{ij}
matrix m x n    /      matrix  p x n  matrix p x m    a_{i.}b_{.k}^{+}
scalar          /      matrix  m x n  matrix n x m    ab_{ij}^{+}
matrix m x n    /      scalar         matrix m x n    a_{ij}/b
scalar          / ./   scalar         double          a/b
</xmp><p>

This implies that <tt>* **</tt> are the same as <tt>.*</tt> when one or both arguments are scalar, and similarly for <tt>/</tt> and <tt>./</tt> when the right-hand operand is not a matrix.

<p>The binary <tt>*</tt> operator denotes multiplication. If both operands are a matrix, this is matrix multiplication and the number of columns of the first operand has to be identical to the number of rows of the second operand. <p>The <tt>.*</tt> operator defines element by element multiplication. It is only
different from <tt>*</tt> if both operands are a matrix (these must have identical dimensions, however, if one or both of the arguments is a 1 <tt>x</tt> 1 matrix, <tt>*</tt> is equal to <tt>.*</tt>). 

<p>The product of two integers remains an integer. This means that overflow could occur (when it would not occur in operations where one of the argument is a double). For example <tt>5000 * 50000</tt> fits in an integer and yields 250,000,000, but <tt>50000 * 50000</tt> overflows, yielding -1.794,967,296. When using double arithmetic: <tt>50000.0 * 50000</tt> = 2500,000,000.0.

<p>The binary <tt>/</tt> operator denotes division. If the second operand is a matrix, this is identical to post-multiplication by the inverse (if the matrix is square the matrix is inverted using the <tt>invert()</tt> library function; if that fails, or the matrix is non-square, the generalized inverse is used). If the second operand is a scalar, each element of the first is divided by it. If the first operand is a scalar, it is multiplied by the inverse of the second argument.

<p>The <tt>./</tt> operator defines element by element division. If either argument is not a matrix, this is identical to normal division. It is only different from <tt>/</tt> if both operands are a matrix (these must have identical dimensions).

<p>Note that <tt>/</tt> does not support integer division (such as e.g. 3 / 2 resulting in 1). In Ox, the result of dividing two integers is a double (3 / 2 gives 1.5). Integer division can be performed using the <tt>idiv</tt> library function. The remainder operator (<tt>%</tt> in C and C++) is supported through the library function <tt>imod</tt>. Multiplication of two integers returns an integer.


<p>Some examples of multiplication and division involving matrices:

<xmp>
    decl m1 = <1,2; 2,1>, m2 = <2,3; 3,2>, r;

    r = m1 * 2.;                                      // <2,4; 4,2>
    r = 2. * m2;                                      // <4,6; 6,4>
    r = m1 * m2;                                      // <8,7; 7,8>
    r = m1 .* m2;                                     // <2,6; 6,2>
    r = m1 .* <2,3>;                                  // <2,6; 4,3>
    r = m1 ** m2;           // <2,3,4,6; 3,2,6,4; 4,6,2,3; 6,4,3,2>
    r = 2 / 3;                                          // 0.666667
    r = 2 / 3.;                                         // 0.666667
    r = m1 / 2.;                                  // <0.5,1; 1,0.5>
    r = m1 ./ <2;3>;                    // <0.5,1; 0.66667,0.33333>
    r = 2./ m2;                             // <-0.8,1.2; 1.2,-0.8>
    r = 2 ./ m2;                          // <1,0.66667; 0.66667,1>
    r = m2 / m2;                                      // <1,0; 0,1>

    r = 1/<1;2>;                                       // <0.2,0.4>
    r = 1/<1,2>;                                      // <0.2; 0.4>
    r = 1/<0,0;0,0>;                                  // <0,0; 0,0>
</xmp><p>


Notice the difference between <tt>2./ m2</tt> and <tt>2 ./ m2</tt>. In the first case, the dot is interpreted as part of the real number <tt>2.</tt>, whereas in the second case it is part of the <tt>./</tt> dot-division operator. The white space is used here to change the syntax (as in the example in <a href="#ox_syntax_RefTranspose">transpose</a>); it would be more clear to write the second case as <tt>2.0 ./ m2</tt>. The same difference applies for dot-multiplication, but note that <tt>2.0*m2</tt> and <tt>2.0.*m2</tt> give the same result.

<h3><a name="ox_syntax_add"></a>Additive expressions</h3><p>

The additive operators <tt>+</tt> and <tt>-</tt> are dot-operators, conforming to Table <a href="#TabSyntaxOXDOTOP">syn.3</a>. The exception is that adding strings amounts to concatenation, and subtraction involving strings is not allowed. Both operators group left-to-right. They respectively return the sum and the difference of the operands, which must both have arithmetic type. Matrices must be conformant in both dimensions, and the operator is applied element by element. For example:

<xmp>
    decl m1 = <1,2; 2,1>, m2 = <2,3; 3,2>;

    r = 2 - m2;                                 // <0,-1; -1,0>
    r = m1 - m2;                              // <-1,-1; -1,-1>
</xmp><p>

<h3><a name="ox_syntax_concat"></a>Concatenation expressions</h3><p>

<xmp>
left        operator   right           result
int/double     ~       int/double      matrix 1 x 2
int/double     ~       matrix  m x n   matrix m x (1+n)
matrix m x n   ~       int/double      matrix m x (n+1)
matrix m x n   ~       matrix  p x q   matrix max(m,p) x (n+q)
int/double     |       int/double      matrix 2 x 1
int/double     |       matrix  m x n   matrix (1+m) x n
matrix m x n   |       int/double      matrix (m+1) x n
matrix m x n   |       matrix  p x q   matrix (m+p) x max(n,q)
int            ~  |    string          string
string         ~  |    int             string
string         ~  |    string          string
array          ~  |    array           array
array          ~  |    any basic type  array
</xmp><p>

If both operands have arithmetic type, the concatenation operators are used to create a larger matrix out of the operands. If both operands are scalar the result is a row vector (for ~) or a column vector (for <tt>|</tt>). If one operand is scalar, and the other a matrix, an extra column (~) or row  (<tt>|</tt>) is
pre/appended. If both operands are a matrix, the matrices are joined. Note that the dimensions need not match: missing elements are set to zero (however, a warning is printed of non-matching matrices are concatenated). Horizontal concatenation has higher precedence than vertical concatenation.

<p>Two strings or an integer and a string can be concatenated, resulting in a longer string. Both horizontal and vertical concatenation yield the same result. 

<p>The result is most easily demonstrated by examples:

<xmp>
    print(1 ~ 2 ~ 3 | 4 ~ 5 ~ 6);             // <1,2,3; 4,5,6>
    print("tinker" ~ '&' ~ "tailor" );       // "tinker&tailor"
    print(<1,0; 0,1> ~ 2);                    // <1,0,2; 0,1,2>
    print(2 | <1,0; 0,1>);                   // <2,2; 1,0; 0,1>
    print(<2> ~ <1,0; 0,1>);                  // <2,1,0; 0,0,1>
</xmp><p>

 The first two lines could have been written as:

<xmp>
    print(<1,2,3; 4,5,6>);
    print("tinker" "&" "tailor" );
</xmp><p>

In the latter case, the matrix and string are created at compile time, whereas in the former case this is done at run time. Clearly, the compile time evaluation is more efficient. However, only the concatenation expressions can involve non-constant variables:

<xmp>
    decl  i1 = 1, i2 = 2, s1 = "tinke";

    print(i1 ~ i2);                                    // <1,2>
    print(s1 ~ 'r');                                // "tinker"
</xmp><p>

Array concatenation results in an array with combined size, with assignment of each member of both arrays to the new array.

<xmp>
    decl  i, a1 = {"tinker", "tailor"}, a2 = {"soldier"};

    a1 ~= a2;
    print(a1);
</xmp><p>

This prints:

<xmp>
    [0] = tinker
    [1] = tailor
    [2] = soldier
</xmp><p>

Often, concatenation is required in a loop. In that case, it is convenient to start from a matrix of dimension zero, for example:

<xmp>
    decl m, i;

    for (i = 0, m = <>; i < 4; ++i)
        m ~= i;
    print(m);                           // m = <0, 1, 2, 3>
</xmp><p>


<h3><a name="ox_syntax_rel"></a>Relational expressions</h3><p>

The relational operators are <tt>&lt;</tt>, <tt>&lt;=</tt>, <tt>></tt>, <tt>>=</tt>, standing for `less',
`less or equal', `greater', `greater or equal'. They all yield 0 if the specified relation is false, and 1 if it is true. The type of the result is always an integer, see Table <a href="#TabSyntaxOXDOTREL">syn.4</a>. If both operands are a matrix the return value is true if the relation holds for each element. If one of the operands is of scalar-type, and the other of matrix-type, each element in the matrix is compared to the scalar, and the result is true if each comparison is true.

<p>The dot relational operators are <tt>.&lt;</tt>, <tt>.&lt;=</tt>, <tt>.&gt;</tt>, <tt>.&gt;=</tt>,
standing for `dot less', `dot less or equal', `dot greater', `dot greater or equal'. They conform to Table <a href="#TabSyntaxOXDOTOP">syn.3</a>.

<p>If both arguments are scalar, the result type inherits the higher type, so <tt>1 >= 1.5</tt> yields a double with value <tt>0.0</tt>. If both operands are a matrix the return value is a matrix with a 1 in each position where the relation is true and zero If one of the operands is of scalar-type, and the other of matrix-type, each element in the matrix is compared to the scalar returning a matrix with 1 at each position where the relation holds.

<p>String-type operands can be compared in a similar way. If both operands are a string, the results is int with value 1 or 0, depending on the case sensitive string comparison.

Examples are given in the next section.

<h3><a name="ox_syntax_RefEqExpr"></a>Equality expressions</h3><p>

The <tt>==</tt> (is equal to), <tt>!=</tt> (is not equal to), <tt>.==</tt> (is dot equal to) and <tt>.!=</tt> (is not dot equal to) are analogous to the relational operators, but have lower precedence.

The non-dotted versions conform to Table <a href="#TabSyntaxOXDOTREL">syn.4</a>. 

<p>The dotted versions conform to Table <a href="#TabSyntaxOXDOTOP">syn.3</a>.

<p>For example:

<xmp>
    decl m1 = <1,2; 2,1>, m2 = <2,3; 3,2>, s1 = "tinke";

    print(m1 == 1);                                        // 0
    print(m1 != 1);                                        // 0
    print(!(m1 == 1));                                     // 1
    print(m1 > m2);                                        // 0
    print(m1 < m2);                                        // 1
    print(s1 <= "tinker");                                 // 1
    print(s1 <= "tink"  );                                 // 0
    print(s1 == "tinker");                                 // 0
    print(s1 >= "tinker");                                 // 0
    print(s1 == "Tinke");                                  // 0

    print(m1 .== 1);                               // <1,0; 0,1>
    print(m1 .!= 1);                               // <0,1; 1,0>
    print(m1 .> m2);                               // <0,0; 0,0>
    print(m1 .< m2);                               // <1,1; 1,1>

    print("AACGTGGC" .== "ACCTTGGC");       // <1,0,1,0,1,1,1,1>
    print("AACGTGGC" .== 'A');              // <1,1,0,0,0,0,0,0>
</xmp><p>


The non-dotted versions only return true if the relation holds for each element. In the first two examples neither <tt>m1 == 1</tt> nor <tt>m1 != 1</tt> is true for each element, hence the return value 0. The third example shows how to test if a matrix is not equal to a value. The parenthesis are necessary, because <tt>!</tt> has higher precedence than <tt>==</tt>, and <tt>!m1 == 1</tt> results in <tt><0,0; 0,0> == 1</tt> which is false.

<p>The last four examples use dot-relational expressions, resulting in a matrix of zeros and ones. In <tt>if</tt> statements, it is possible to use such matrices. Remember that a matrix is true if all elements are true (i.e. no element is zero).

<p>The <tt>any</tt> library function evaluates to TRUE if any element is TRUE, e.g.

<xmp>
                    evaluates to         leads to
if (any(m1 .== 1))  if (any(<1,0;0,1>))  if part
if (any(m1 .!= 1))  if (any(<0,1;1,0>))  if part
if (m1 == 1)        if (0)               else part
if (m1 != 1)        if (0)               else part
</xmp><p>

<h3><a name="ox_syntax_dotand"></a>Logical dot-AND expressions</h3><p>

The <tt>.&amp;&amp;</tt> operator returns 1 if both of its operands compare unequal to 0, 0 otherwise. Both operands must have arithmetic type. Handling of matrix-type is as for dot-relational operators: if one or both operands is a matrix, the result is a matrix of zeros and ones. Unlike the non-dotted version, both operands will always be executed. For example, in the expression <tt>func1() .&amp;&amp; func2()</tt> the second function is called, regardless of the return value of <tt>func1()</tt>.

<h3><a name="ox_syntax_and"></a>Logical-AND expressions</h3><p>

The <tt>&amp;&amp;</tt> operator returns the integer 1 if both of its operands compare unequal to 0, and the integer 0 otherwise. Both operands must have arithmetic type. First the left operand is evaluated, if it is false (for a matrix: there is at least one zero element), the result is false, and the right operand will not be evaluated. So in the expression <tt>func1() &amp;&amp; func2()</tt> the second function will <em>not</em>
be called if the first function returned false.


<h3><a name="ox_syntax_dotor"></a>Logical dot-OR expressions</h3><p>

The <tt>.||</tt> operator returns 1 if either of its operands compares unequal to 0, 0 otherwise. Both operands must have arithmetic type. Handling of matrix-type is as for dot-relational operators: if one or both operands is a matrix, the result is a matrix of zeros and ones. Unlike the non-dotted version, both operands will always be executed. For example, in the expression <tt>func1() .|| func2()</tt> the second function is called, regardless of the return value of <tt>func1()</tt>.


<h3><a name="ox_syntax_or"></a>Logical-OR expressions</h3><p>

The <tt>||</tt> operator returns the integer 1 if either of its operands compares unequal to 0, integer value 0 otherwise. Both operands must have arithmetic type. First the left operand is evaluated, it it is true (for a matrix: no element is zero), the result is true, and the right operand will not be evaluated. So in the expression <tt>func1() || func2()</tt> the second function will <em>not</em> be called if the first function returned true.


<h3><a name="ox_syntax_CondExp"></a>Conditional expression</h3><p>

Both the conditional and the dot-conditional expression are ternary expressions. For the conditional expression, the first expression (before the <tt>?</tt>) is evaluated. If it is unequal to 0, the result is the second expression, otherwise the third expression.

<p>The dot-conditional expression only differs from the conditional expression if the first expression evaluates to a matrix, here called the test matrix. In that case the result is a matrix of the same size as the test matrix, and the test matrix can be seen as a filter: non zero elements get a value corresponding to the second expression, zero elements corresponding to the third expression. If the second or third expression
is scalar, each matrix element will get the appropriate scalar value. If it is a matrix, the corresponding matrix element will be used, unless the matrix is too small, in which case the value 0. will be used. <em>Note that in the dot-conditional expression both parts are executed, whereas in the conditional expression only one of the two parts is executed.</em>

<xmp>
    decl r, m2;

    r = <1,0; 0,1> ? 4 : 5;  // 5, matrix is true if no element is 0
    r = <1,0; 0,1> .? 4 .: 5;                          // <4,5; 5,4>
    m2 = <1>;
    r = r .== 4 .? m2 .: 0;                            // <1,0; 0,0>
</xmp><p>

<h3><a name="ox_syntax_assign"></a>Assignment expressions</h3><p>

The assignment operators are the  simple assignment <tt>=</tt> as well as the compound  <tt>*=  /=  +=  -=  ~=  |=  .*=  ./=</tt> operators. An lvalue is required as the left operand. The type of an assignment is that of its right operand. The compoundd assignment <i>l</i> <i>op</i><tt>=</tt> <i>r</i> is equivalent to <i>l</i> <tt>=</tt> <i>l op (r)</i>.

<p>If the left-hand side is a comma-separated list in square brackets, the statement is a <a href="#ox_syntax_MultAssign">Multiple assignment</a> expression.

<p>The following code:

<xmp>
    decl i, k;
    for (i = 0, k = 1; i < 5; i += 2)
        k *= 2, print("i = ", i, " k = ", k, "\n");
</xmp><p>

writes:

<xmp>
    i = 0 k = 2
    i = 2 k = 4
    i = 4 k = 8
</xmp><p>

Assigning an object to another variable only passes a reference: both will refer to the same object. The <tt>clone</tt> library function makes a copy which should be removed using <tt>delete</tt>.


<h3><a name="ox_syntax_comma"></a>Comma expression</h3><p>

A pair of expressions separated by a comma is evaluated left to right, and the value of the left expression is discarded. The result will have type and value corresponding to the right operand. The example in the previous section has two instances of the comma operator in the for loop: <tt>i = 0, k = 1</tt>.

<h3><a name="ox_syntax_RefConstExp"></a>Constant expressions</h3><p>

An expression that evaluates to a constant is required in initializers and certain preprocessor expressions.
A constant expression can have the operators <tt>*  /  +  -</tt>, but only if the operands have scalar type.
Some examples were given in sections on <a href="#ox_syntax_RefEnum">enumerations</a> and <a href="#ox_syntax_RefExtVarDecl">external declarations</a>.


</body>
</html>
